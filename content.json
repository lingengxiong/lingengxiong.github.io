{"meta":{"title":"呵呵到天亮","subtitle":"","description":"","author":"lingengxiong","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2020-01-06T08:16:40.000Z","updated":"2020-01-17T02:01:54.714Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"git笔记","slug":"git笔记","date":"2020-03-27T07:46:19.389Z","updated":"2020-03-27T07:46:19.389Z","comments":true,"path":"2020/03/27/git笔记/","link":"","permalink":"http://yoursite.com/2020/03/27/git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设置用户名、密码12345git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;git remote &#x2F;&#x2F;查看远程库信息git remote -v显示更详细的信息 提交文件12git add readme.txtgit commit -m &quot;message&quot; 查看状态12345git status 告诉你有文件被修改过git diff 可以查看修改内容。git diff HEAD -- readme.txt 查看工作区与版本库最新版的区别git log 命令显示从最近到最远的提交日志，git log --pretty&#x3D;oneline 一行显示 版本回退12git reset --hard HEAD^ &#x2F;&#x2F;回退到上一版本git reset --hard commit_id &#x2F;&#x2F;回退到指定版本 撤销修改123git checkout -- file &#x2F;&#x2F;丢弃工作区修改git reset HEAD &lt;file&gt; &#x2F;&#x2F;缓存区回退到工作去如果修改已经提交到版本区，使用版本回退 删除123a.rm test.txt &#x2F;&#x2F;删除本地工作去文件 （误删可用git checkout --test.txt把误删的文件恢复到最新版本)b.git rm test.txt &#x2F;&#x2F;删除版本库文件d.git commit -m &lt;message&gt; 上传到github1234561.生成ssh key: $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;2.git remote add origin git@github.com:michaelliao&#x2F;learngit.git 要关联一个远程库3.$ git push -u origin master 本地库的所有内容推送到远程库上：由于远程库是空的，我们第一次推送master分支时，加上了-u参数git push origin master推送最新修改 从远程库克隆123 git clone git@github.com:lingengxiong&#x2F;testAgain.git（还可以用https:&#x2F;&#x2F;github.com&#x2F;michaelliao&#x2F;gitskills.git这样的地址。实际上，Git支持多种协议，默认的git:&#x2F;&#x2F;使用ssh，但也可以使用https等其他协议。） 分支管理查看分支：1git branch 创建分支：1git branch &lt;name&gt; 切换分支：1git checkout &lt;name&gt; 创建+切换分支：1git checkout -b &lt;name&gt; 合并某分支到当前分支：1git merge &lt;name&gt; 删除分支：12git branch -d &lt;name&gt;git branch -D &lt;name&gt; &#x2F;&#x2F;强行删除未合并的分支 查看分支合并情况1git log --graph --pretty&#x3D;oneline --abbrev-commit 分支管理策略1git merge --no-ff -m &quot;merge with no-ff&quot; dev --no-ff参数，表示禁用Fast forward 保存工作现场1git stash 查看现场保存情况1git stash list 回复现场12git stash popgit stash apply stash@&#123;0&#125; 多次stash,恢复时，指定stash 创建远程origin的dev分支到本地1git checkout -b dev origin&#x2F;dev 指定本地dev分支与远程origin/dev分支的链接1git branch --set-upstream-to&#x3D;origin&#x2F;dev dev 多人协作1234567891011因此，多人协作的工作模式通常是这样：首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt;。 标签管理创建标签1git tag &lt;name&gt; &#x2F;&#x2F;如git tag v1.0 查看标签1git tag 补打标签12345git log --pretty&#x3D;oneline --abbrev-commit &#x2F;&#x2F;查看历史提交的commit idgit tag v0.9 f52c633git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb &#x2F;&#x2F;创建带有说明的标签，用-a指定标签名，-m指定说明文字git show &lt;tagname&gt;可以看到说明文字 删除标签123git tag -d v0.1git push origin :refs&#x2F;tags&#x2F;v0.9 &#x2F;&#x2F;从远程删除 推送标签123git push origin &lt;tagname&gt;git push origin --tags &#x2F;&#x2F;一次性推送全部尚未推送到远程的本地标签","categories":[],"tags":[],"keywords":[]},{"title":"Shader学习3——数学","slug":"Shader学习1_初识计算机图形学","date":"2020-03-14T14:22:14.000Z","updated":"2020-03-27T07:53:39.786Z","comments":true,"path":"2020/03/14/Shader学习1_初识计算机图形学/","link":"","permalink":"http://yoursite.com/2020/03/14/Shader%E5%AD%A6%E4%B9%A01_%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","excerpt":"","text":"一. 初识计算机图形学图形与图形 图像纯指计算机内以位图（Bitmap)形式存在的灰度信息 图形含有几何属性，更强调场景的几何表示，是场景几何模型和景物的物理属性共同组成的 图形主要分成两类： 基于线条信息表示 明暗图（Shading） GPU 流水线1. 渲染管线顶点着色器 —&gt; 光栅化 —&gt; 片段着色器 —&gt; alpha测试 —&gt; 模板测试 —&gt; 深度测试 —&gt; Blend —&gt; Gbuffer —&gt; frontBuffer —&gt; frame buffer —&gt;显示器 1.1 顶点着色器 流水线的第一个阶段，输入来自CPU 处理单位为顶点，即输入的每个顶点都会调用一次顶点着色器 顶点着色器本身无法创建或者销毁任何顶点，也无法得到顶点之间的关系，例如无法知道两个顶点是否属于同一个三角网格 所以GPU可以并行处理每一个顶点，故此阶段处理速度很快 主要工作：坐标转换和逐顶点光照 1.2 光栅化​ 将顶点转成像素 1.3 片段着色器 纹理采样，从纹理像素 赋给顶点生成的像素 像素跟灯光计算 1.4 Alpha 测试​ 挑选合格的alpha 像素显示 1.5 模板测试​ 像素可携带模板信息，达到模板条件的显示出来 1.6 深度测试​ 符合条件的像素通过，否则丢弃 1.7 Blend​ 将当前要渲染的像素和已经渲染出来的像素混合运算 1.8 GBuffer​ RGBA、 模板值 、深度值等 2.屏幕坐标系屏幕坐标系在OpenGL和DirectX之间存在差异： OpenGL把屏幕左下角当成最小的窗口坐标 DirectX则把屏幕左上角当成最小的窗口坐标 GPU编程语言GLSLOpenGL Shading Language 优点：有较好的跨平台性，可在Windows、Linux、Mac甚至移动平台等多种平台上工作 原因：跨平台性是由于OpenGL没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作，也就是说只要显卡驱动支持GLSL的编译，就能运行它，它依赖硬件，而非系统层级 缺点：因为编译结果取决于供应商，供应商编译实现不尽相同，所以存在编译结果不一致的情况。 HLSLHigh Level Shading Language，DirectX 由微软控制着色器的编译，即使不同的硬件，同一着色器的编译结果相同，故而支持HLSL的平台相对有限，几乎都是微软自己的产品，其他平台没有可以编译HLSL的编译器。 CGC for Graphic 真正意义上的跨平台，会根据平台的不同，编译成相同的中间语言，因为它和微软合作，导致CG语言的语法和HLSL非常相似。CG语言可以无缝移植成HLSL代码。 固定管线渲染固定函数的流水线(Fixed-Function Pipeline)，也称固定管线，指在较旧的GPU上实现的渲染流水线，这种流水线只给开发者提供一些配置操作，开发者没有对流水线阶段的完全控制权。 固定管线通常只提供一系列接口，接口包含一个函数入口点，这些函数入口点匹配GPU上的特定逻辑功能，开发者通过这些接口来控制渲染流水线。 标注：已逐渐弃用，不建议继续使用 名词解释NDC：归一化设备坐标(Normalized Device Coordinates)","categories":[],"tags":[{"name":"Unity Shader","slug":"Unity-Shader","permalink":"http://yoursite.com/tags/Unity-Shader/"}],"keywords":[]},{"title":"Shader学习3——数学","slug":"Shader学习3_数学","date":"2020-03-14T14:22:14.000Z","updated":"2020-03-27T07:52:07.407Z","comments":true,"path":"2020/03/14/Shader学习3_数学/","link":"","permalink":"http://yoursite.com/2020/03/14/Shader%E5%AD%A6%E4%B9%A03_%E6%95%B0%E5%AD%A6/","excerpt":"","text":"笛卡尔坐标系1. 二维笛卡尔坐标系其实我们小学就开始接触的二维坐标系就是笛卡尔坐标系，只是我们当时并不知道这个名字而已。 x轴和y轴互相垂直，也称为该坐标系的基矢量。 在OpenGL和DirectX中使用了不同的二维笛卡尔坐标系 2. 三维笛卡尔坐标系三维笛卡尔坐标系中，需要定义三个坐标轴和一个原点，如下图： 这三个坐标轴也称为基矢量(basis vector)，通常三个坐标轴是互相垂直的，而且长度为1，这样的基矢量称为标准正交基。假如长度不为1，这样的基矢量称为正交基。 3. 左手坐标系、右手坐标系笛卡尔三维坐标系又分为左手坐标系和右手坐标系 4. Unity使用的坐标系 在模型空间和世界空间中，Unity使用的是左手坐标系 对于观察空间来说，Unity使用的是右手坐标系。 观察空间，就是摄像机为原点的坐标系，此坐标系中，摄像机前向是z轴的负方向，也就是说，z轴坐标减少，场景深度增加。 矢量1. 矢量与点点(point)是n维空间中的一个位置，没有大小与宽度。 矢量(vector，也称向量)，是指在n维空间一种包含模和方向的有向线段。 矢量的模，指的是矢量的长度，是一个任意非负数 矢量的方法，指描述了这个矢量在空间中的指向 表示方法： 二维矢量：v = (x, y) 三维矢量： v = (x, y, z) 四维矢量： v = (x, y, z, w) 2. 矢量计算 矢量与标量的乘除法 乘法：只需要把矢量的每个分量都与标量相乘。 kv = (kv_x, kv_y, kv_z)除法：等同于和这个标量的倒数相乘 \\frac vk = \\frac {(x,y,z)}k = \\frac 1k (x,y,z) = \\left( \\frac xk, \\frac yk, \\frac zk \\right), k\\neq 0 矢量加减法 两矢量进行相加减，结果为一个相同维度的新矢量。计算过程中只需要两矢量的相应分量进行相加减即可： a+b = (a_x+b_x,a_y+b_y,a_z+b_z) 注意：矢量不可以跟标量相加减，或者和不同维度的矢量进行运算。 3. 矢量的模矢量的模式一个标量，可理解为矢量在空间中的长度。三维矢量的模计算公式如下： |v| = \\sqrt{v_x^2+v_y^2+v_z^2}其他维度的模计算类似，都是对每个分量平方后相加再开根号。 4. 单位矢量单位矢量指模为1的矢量，也称为被归一化的矢量，非零矢量转为单位矢量的过程称为归一化。 矢量归一化公式： \\hat v = \\frac v{|v|}零矢量：每个分量都是0，如v = (0,0,0)，零矢量是不可以被归一化的。 5. 矢量的点积矢量的乘法有两种常用的种类： 点积，也称内积 叉积，也称外积 两矢量的点积是把矢量对应分量相乘后再取和，最终得到一个标量。 公式一： a \\cdot b = (a_x,a_y,a_z) \\cdot (b_x,b_y,b_z) = a_xb_x+a_xb_y+a_zb_z点积的几何意义：投影(projection) 点积的性质： 性质1：点积可结合标量乘法$(ka)·b = a \\cdot (kb) = k(a \\cdot b)$ 也就是说点积对一个矢量进行缩放，相当于对最后的结果进行缩放 性质2：点积可结合矢量加法和减法 a \\cdot (b+c) = a \\cdot b + a\\cdot c 性质3：一个矢量和自身进行点积的结果，是该矢量的模的平方 v\\cdot v = |v|^2 6. 矢量的叉积矢量的叉积的结果仍然是一个矢量。叉积公式如下： a \\times b = (a_x,a_y,a_z) \\times (b_x,b_y,b_z) = (a_yb_z-a_zb_y,a_zb_x-a_xb_z,a_xb_y-a_yb_x)叉积不满足交换律，即$ a \\times b \\neq b\\times a$，但是实际上 $a \\times b = - (b\\times a)$ 叉积不满足结合律，即$(a \\times b)\\times c \\neq a \\times (b \\times c)$ 几何意义：对两个矢量进行叉积的结果会得到一个同时垂直于这两个矢量的新矢量。 应用：计算一个垂直于一个平面、三角形的矢量。 矩阵1. 矩阵运算1.1 矩阵和标量的乘法 kM = Mk = k \\left[ \\begin{matrix} m_{11}&m_{12}&m_{13}\\\\ m_{21}&m_{22}&m_{23}\\\\ m_{31}&m_{32}&m_{33}\\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} km_{11}&km_{12}&km_{13}\\\\ km_{21}&km_{22}&km_{23}\\\\ km_{31}&km_{32}&km_{33}\\\\ \\end{matrix} \\right]1.2 矩阵和矩阵的乘法两矩阵的乘法结果是一个新的矩阵，维度跟两个矩阵维度相关。 矩阵A为r x n的矩阵，矩阵B为n x c的矩阵。AB将是r x c大小的矩阵。 注意：第一个矩阵的列数必须等于第二个矩阵的行数，结果为第一个矩阵的行数，第二个矩阵的列数 矩阵A跟矩阵B相乘，结果得到矩阵C，C中的每个元素$c_{ij}$,由A中的第i行和B中的第j列，相乘后相加，即： c_{ij} = a_{i1}b_{1j}+a_{i2}b_{2j}+ ... + a_{in}b_{nj} = \\sum_{k=1}^n a_{ik}b_{kj}例如： A= \\left[ \\begin{matrix} a_{11}&a_{12}\\\\ a_{21}&a_{22}\\\\ a_{31}&a_{32}\\\\ \\end{matrix} \\right] B = \\left[ \\begin{matrix} b_{11}&b_{12}&b_{13}&b_{14}\\\\ b_{21}&b_{22}&b_{23}&b_{24}\\\\ \\end{matrix} \\right]相乘结果C： C = \\left[ \\begin{matrix} c_{11}&c_{12}&c_{13}&c_{14}\\\\ c_{21}&c_{22}&c_{23}&c_{24}\\\\ c_{31}&c_{32}&c_{33}&c_{34}\\\\ \\end{matrix} \\right]则$c_{23} = a_{21}b_{13}+a_{22}b_{23}$ 矩阵乘法性质： 性质一：不满足交换律，即$AB \\neq BA$ 性质二：满足结合律，即$(AB)C = A(BC)$ 2. 特殊矩阵在Shader中经常见到的特殊矩阵，这些矩阵往往具有一些重要的性质。 2.1 方块矩阵简称方阵，指行数和列数相等的矩阵。三维渲染中最常见的就是$3 \\times 3$和$4 \\times 4$的方阵。 角元素：行号跟列号相等的元素，如$m_{11}$,$m_{22}$等。因为这些元素排在正方形的对角线上，故而称为角元素。 对角矩阵：除了角元素外的所有元素都是0，这样的矩阵称为对角矩阵。如： \\left[ \\begin{matrix} 1&0&0&0\\\\ 0&2&0&0\\\\ 0&0&3&0\\\\ 0&0&0&4\\\\ \\end{matrix} \\right]2.2 单位矩阵对角元素都为1的对角矩阵，称为单位矩阵(identity matrix)，用$I_n$来表示，如： \\left[ \\begin{matrix} 1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&1&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right]与单位矩阵相乘的矩阵，结果还是原来的矩阵，这就是单位矩阵名字的由来。即： MI = IM = M2.3 转置矩阵转置矩阵其实是对原矩阵的一种运算，即转置运算。例如$r \\times c$的矩阵M，它的转置矩阵为$M^T$,$M^T$为一个$c \\times r$的矩阵。 M_{ij}^T = M_{ji}例如： \\left[ \\begin{matrix} 1&2&3&4\\\\ 5&6&7&8\\\\ \\end{matrix} \\right]^T = \\left[ \\begin{matrix} 1&5\\\\ 2&6\\\\ 3&7\\\\ 4&8\\\\ \\end{matrix} \\right]转置矩阵性质： 性质一：矩阵转置的转置等于原矩阵，即 (M^T)^T = M 矩阵串接的转置，等于反向串接各个矩阵的转置。 (AB)^T = B^TA^T 2.4 逆矩阵逆矩阵是一种特俗的方阵，它的特殊之处在于原矩阵和其逆矩阵相乘，结果为一个单位矩阵，例如矩阵M，其逆矩阵未$M^{-1}$ MM^{-1} = M^{-1}M = I不是所有方阵都有对应的逆矩阵，例如元素都为0的矩阵就不存在逆矩阵(因为相乘都为0)。 矩阵有对应逆矩阵，我们称该矩阵是可逆的，或者非奇异的，没有逆矩阵的则称为不可逆的，或者奇异的。 逆矩阵性质： 性质一：逆矩阵的逆矩阵还是原来的矩阵本身 (M^{-1})^{-1} = M 性质二：单位矩阵的逆矩阵是它本身。 I^{-1} = I 性质三：转置矩阵的逆矩阵是逆矩阵的转置 (M^T)^{-1} = (M^{-1})^T 性质四：矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵。 (AB)^{-1} = B^{-1}A^{-1} 2.5 正交矩阵正交是矩阵的一种属性，如果一个方阵M和它的转置矩阵的成绩是单位矩阵的话，则称这个矩阵是正交的，即 MM^T = M^TM = I这个式子跟逆矩阵公式：$MM^{-1} = M^{-1}M = I$ 很相似，两个公式结合就能得到一个重要的性质，即如果一个矩阵是正交的，那么他的转置矩阵和逆矩阵是一样的。也就是说 M^T = M^{-1}矩阵的几何意义:变换1. 变换变换(transform)，指把数据通过某种方式进行转换的过程，这些数据可以是点、方向甚至颜色等。 线性变换：那些可以保留矢量加和标量乘的变换。 f(x)+f(y) = f(x+y) kf(x) = f(kx)常见的线性变换：缩放(scale)、旋转(rotation)、错切(shear)、镜像(morroring，也称reflection)、正交投影(orthographic projection) 2. 齐次坐标齐次坐标就是把n维向量，用n+1维向量表示。齐次坐标只是为了方便计算的一种表示方式而已。 例如：3*3矩阵不能表示平移操作，拓展到4*4就能实现。 如何将三维矢量变成四维矢量？ 对于一个点，只需要把其w分量设为1； 对于方向矢量来说，需要把其w分量设为0； 这样操作后，用4*4的矩阵对一个点进行变换时，平移、旋转、缩放都会施加于该点 对一个方向矢量进行变换时，将不起作用。 3. 分解基础变换矩阵4*4的矩阵能表示平移、旋转和缩放。我们把表示纯平移、纯旋转和纯缩放的变换叫做基础变换矩阵。基础变换矩阵分解如下： \\left[ \\begin{matrix} M_{3\\times3}&t_{3\\times1}\\\\ 0_{1\\times3}&1 \\end{matrix} \\right] $M_{3\\times 3}$用于表示旋转和缩放 $t_{3*3}$用于表示平移 $0_{1*3} = \\left[ \\begin{matrix} 0&amp;0&amp;0\\\\ \\end{matrix}\\right] $ 右下角是标量1 4. 平移矩阵 我们可以用矩阵乘法来对一个点（x,y,z）进行平移变换： 该点齐次坐标为(x,y,z,1) \\left[ \\begin{matrix} 1&0&0&t_x\\\\ 0&1&0&t_y\\\\ 0&0&1&t_z\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} x+t_x\\\\ y+t_y\\\\ z+t_z\\\\ 1\\\\ \\end{matrix} \\right]​ 从几何上看，就是把点$(x,y,z)$在空间中移动了$(t_x,t_y,t_z)$个单位。 对一个方向矢量（x,y,z）进行平移变换，结果如下： 该矢量的齐次坐标为（x,y,z,0） \\left[ \\begin{matrix} 1&0&0&t_x\\\\ 0&1&0&t_y\\\\ 0&0&1&t_z\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 0\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 0\\\\ \\end{matrix} \\right]​ 可以发现，平移变换不会对方向矢量产生任何影响。 构建平移矩阵： 基础变换矩阵中的$t_{3\\times 1}$矢量对应了平移矢量，左上角的矩阵$M_{3\\times 3}$为单位矩阵$I_3$。 平移矩阵的逆矩阵就是方向平移得到的矩阵，即 \\left[ \\begin{matrix} 1&0&0&-t_x\\\\ 0&1&0&-t_y\\\\ 0&0&1&-t_z\\\\ 0&0&0&1\\\\ \\end{matrix} \\right]可以看出，平移矩阵并不是一个正交矩阵。 5. 缩放矩阵我们可以对一个模型沿空间的x轴、y轴、z轴进行缩放。矩阵乘法表示如下： \\left[ \\begin{matrix} k_x&0&0&0\\\\ 0&k_y&0&0\\\\ 0&0&k_z&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} k_xx\\\\ k_yy\\\\ k_zz\\\\ 1\\\\ \\end{matrix} \\right]对反向矢量进行同样的矩阵进行缩放： \\left[ \\begin{matrix} k_x&0&0&0\\\\ 0&k_y&0&0\\\\ 0&0&k_z&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 0\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} k_xx\\\\ k_yy\\\\ k_zz\\\\ 0\\\\ \\end{matrix} \\right]统一缩放：缩放系数$k_x = k_y = k_z$,其余都是非统一缩放。缩放矩阵的逆矩阵是使用原缩放系数的倒数来对点或方向矢量进行缩放，即 \\left[ \\begin{matrix} \\frac{1}{k_x}&0&0&0\\\\ 0&\\frac{1}{k_y}&0&0\\\\ 0&0&\\frac{1}{k_z}&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right]缩放矩阵一般不是正交矩阵。 6. 旋转矩阵 把点绕x轴旋转$\\theta$度，可以使用下面矩阵： R_x(\\theta)=\\left[ \\begin{matrix} 1&0&0&0\\\\ 0&\\cos\\theta&-\\sin\\theta&0\\\\ 0&\\sin\\theta&\\cos\\theta&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] 绕y轴： R_y(\\theta)=\\left[ \\begin{matrix} \\cos\\theta&0&\\sin\\theta&0\\\\ 0&1&0&0\\\\ -\\sin\\theta&0&\\cos\\theta&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] 绕z轴 R_z(\\theta)=\\left[ \\begin{matrix} \\cos\\theta&-\\sin\\theta&0&0\\\\ \\sin\\theta&\\cos\\theta&0&0\\\\ 0&0&1&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] 旋转矩阵的逆矩阵是旋转相反角度得到的变换矩阵。旋转矩阵是正交矩阵，多个旋转矩阵之间的串联同样是正交的。 7. 复合变换可以将平移、旋转和缩放进行组合，形成一个复杂的变换过程。例如，可以对模型先缩放(2,2,2),再绕y轴旋转$30^。$，最后向z轴平移4个单位。符合变换可以通过矩阵串联来实现： P_{new} = M_{translation}M_{rotation}M_{scale}P_{old}(阅读顺序从右往左)变换的结果依赖于变换的顺序，矩阵乘法不满足交换律，因此不同的乘法顺序得到的结果不相同。 约定顺序：先缩放，再旋转，最后平移 坐标空间1. 坐标空间的变换每个空间都有一个父(parent)坐标空间，对坐标空间的变换实际上就是在父空间和子空间对点和矢量进行转换。 已头晕@@@，之后再补!!!! 2. 模型空间模型空间(model spacce)，有时也称对象空间，或者局部空间，每个模型都有自己独立的坐标空间。Unity在模型空间中使用左手坐标系，在此模型空间中，+x轴、+y轴、+z轴分别对应模型的右、上和前向。 3. 世界空间世界空间(word space)是一个特殊的坐标系，它创建了我们所关心的最大的空间。这里的最大指的是我们所关心的最外层的坐标空间。 4. 观察空间观察空间(view space),也被称为摄像机空间(camera space)。观察空间可以认为是模型空间的一个特例。 Unity中观察空间的坐标轴选择：+x轴指向右方，+y轴指向上方，+z轴指向的是摄像机的后方。 Unity中观察空间使用的是右手坐标系，在这样的空间中，摄像机的正前方指向的是-z轴的方向。 注意：观察空间和屏幕空间不同，观察空间是三维空间，屏幕空间是二维空间。之间的转换需要进行投影。 顶点变换的第二步，是将顶点坐标从世界空间变换到观察空间中，这个变换叫观察变换。 5. 裁剪空间裁剪空间(clip space, 也称为齐次裁剪空间)，用于变换的矩阵叫裁剪矩阵，也称投影矩阵。裁剪空间的目标是能够方便地对渲染图元进行裁剪： 完全在这空间内部的图元完全保留。 完全在这空间外部的图元完全剔除。 与这块空间相交的图元就会被裁剪。 判断一个顶点是否位于视锥体内部，可以通过投影矩阵把顶点转换到一个裁剪空间中。 以上指的空间由视锥体来决定。视锥体指空间中一块区域，这块区域来决定摄像机所能看到的空间。视锥体由六个平面包围而成，这些平面称为裁剪平面。如下所示： 投影类型： 正交投影，完全保留物体的距离和角度 透视投影，模拟人眼看世界的方式，近大远小 6.屏幕空间使用投影矩阵变换后，我们进行了裁剪操作，接下来就需要进行真正的投影。即把视锥体投影到屏幕空间(screen space)。经过这一步，就得到真正的像素位置，而不是虚拟的三维坐标。屏幕空间是二维的空间，故而我们要把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标： 1.首先进行标准的齐次除法，也称为透视除法，操作很简单，只需要用齐次坐标系中的w分量去除以x,y,z分量。 OpenGL中，这一步得到的坐标称为归一化设备坐标(Normalized Device Coordinates,NDC)。 经过投影变换后的裁剪空间，再经过齐次除法后会变换到一个立方体内。 按OpenGL传统，这个立方体的x,y,z分量的范围都是[-1,1]。Unity选择OpenGL这样的齐次裁剪空间。 在DirectX这样的API中，z分量的范围会是[0,1]。对于正交投影来说，它的裁剪空间实际已经是一个立方体了，而且经过正交投影矩阵变换后的顶底的w分量是1，因此经过齐次除法不会对x,y,z坐标产生影响。如图所示： 2.经过齐次除法后，透视投影和正交投影的视锥体都变换到一个相同的立方体内，接下来就可以根据变换后的x和y坐标来映射输出窗口的对应像素坐标。","categories":[],"tags":[{"name":"Unity Shader","slug":"Unity-Shader","permalink":"http://yoursite.com/tags/Unity-Shader/"}],"keywords":[]},{"title":"Shader学习3——Unity Shader","slug":"Shader学习2_Unity Shader","date":"2020-03-13T14:22:14.000Z","updated":"2020-03-27T07:53:14.565Z","comments":true,"path":"2020/03/13/Shader学习2_Unity Shader/","link":"","permalink":"http://yoursite.com/2020/03/13/Shader%E5%AD%A6%E4%B9%A02_Unity%20Shader/","excerpt":"","text":"Unity Shader1. Unity 中的shaderShader模板Unity为我们提供4种unity Shader 模板 Standard Surface Shader 产生一个包含了标准光照模型的表面着色器模板。 Unlit Shader 产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器。 Image Effect Shader 为我们实现各种屏幕后处理效果提供一个基本模板。 Compute Shader 产生一种特殊的Shader文件，这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算。 2. ShaderLabUnity中，Unity Shader都是使用ShaderLab来编写，ShaderLab是Unity提供的编写Unity Shader的说明性语言。 2.1 ShaderLab基础结构123456789101112Shader &quot;ShaderName&quot;&#123; properties&#123; &#x2F;&#x2F;属性 &#125; SubShader&#123; &#x2F;&#x2F;显卡A使用的子着色器 &#125; SubShader&#123; &#x2F;&#x2F;显卡B使用的子着色器 &#125; Fallback &quot;VertexLit&quot;&#125; Unity在背后会根据使用的平台来把这些结构编译成真正的代码和Shader文件，开发者只需要和Unity Shader打交道。 2.2 ShaderLab结构详解2.2.1 Shader名字ShaderLab 文件第一行，指定Shader的名字，通过斜杆(“/”)，可控制Unity Shader在材质面板中的位置，如： 1Shader &quot;Custon&#x2F;MyShader&quot; 则Shader所在位置： 2.2.2 PropertiesProperties语义块包含一些列属性，这些属性会出现在材质面板上。 12345Properties&#123; Name1(&quot;display name1&quot;, PropertyType1) &#x3D; DefaultValue1 Name2(&quot;display name2&quot;, PropertyType2) &#x3D; DefaultValue2 ...&#125; 属性名通常以下划线”_”开头，定义了这些属性后，即可在材质面板调节各种材质属性。使用每个属性的名字(Name) 可在Shader中访问它们。 每种属性都需要指定类型（PropertyType），以及赋予默认值，常用属性如下： 属性类型 默认值定义语法 例子 Int number _Int(“Int”, Int) = 2 Float number _Float(“Int”, Float) = 2 Range(min, max) number _Range(“Range”, Range(0.0, 10.0)) = 1.5 Color (number,number,number,number,) _Color(“Color”, Color) = (255,255,255,255) Vector (number,number,number,number,) _Vector(“Vector”, Vector) = (1, 1, 1 ,1) 2D “defaulttexture”{} _2D(‘2D’, 2D) = “”{} Cube “defaulttexture”{} _Cube(‘Cube’, Cube= “white”{} 3D “defaulttexture”{} _3D(‘3D’, 3D) = “black”{} 2.2.3 SubShader每个Unity Shader文件可包含至少一个SubShader。当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择一个能够在目标平台运行 的SubShader。假如没有一个SubShader支持的话，Unity会使用Fallback语义指定的Unity Shader。 原因：不同显卡能力性能不同，比较老的显卡可能支持的操作指令数量较少，高级的显卡可支持的指令数较多，故而我们希望程序能在旧的显卡上运行，又能在高级的显卡上有更好的体验。 SubShader语义块通常如下： 123456789101112SubShader&#123; &#x2F;&#x2F;可选 [Tags] &#x2F;&#x2F;可选 [RenderSetup] Pass&#123; &#125; Pass&#123; &#125; ...&#125; SubShader中定义了一系列Pass以及可选的转态([RendetSetup])和标签([Tags])。每个Pass定义了一次完整的渲染流程，我们应尽量使用小数目Pass，太多Pass会使渲染性能下降。 状态设置 ShaderLab提供了一系列渲染状态的设置指令，从而设置显卡的各种状态，常用渲染状态如下： 状态名称 设置指令 解释 Cull Cull Back\\ Front\\ Off 设置剔除模式：剔除背面/正面/关闭剔除 ZTest ZTest Less Greater\\ LEqual\\ GEqual\\ Equal\\ NotEqual\\ Always 设置深度测试时使用的函数 ZWrite ZWrite On\\ Off 开启/关闭深度写入 Blend Blend SrcFactor DstFactor 开启并设置混合模式 在SubShader块中设置上述渲染状态时，将会应用到所有的Pass，假如不希望这样，只想作用于特定Pass，可以再Pass语义块中单独进行设置。 SubShader的标签 SubShader的标签(Tags)是一个键值对(Key/Value Pair)，它的键和值都是字符串类型。这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：SubShader希望如何、以及何时渲染这个对象。 标签结构如下： 1Tags&#123; &quot;TagName1&quot; &#x3D; &quot;Value1&quot; &quot;TagName2&quot; &#x3D; &quot;Value2&quot;&#125; SubShader的标签块支持的标签类型如下： 注意：上述标签只能在SubShader中声明，不能在Pass块中声明。 Pass语义块 Pass语义块的语义如下： 12345Pass&#123; [Name] [Tags] [RenderSetup]&#125; 定义Pass名字 1Name &quot;MyPassName&quot; 通过这个名字，可以在其他Unity Shader中使用该Pass： 1UsePass &quot;MyShader&#x2F;MYPASSNAME&quot; 这样就提高了代码的发用性，我们可以发现调用的过程中使用了大写的形式，这并不是写错，而是因为Unity内部会把所有的Pass的名称都转成大写，故而我们在使用UsePass时，必须使用大写的形式。 Pass标签Pass同样可以设置标签，它的标签不同于SubShader的标签，这些标签也是用于告诉渲染引擎如何来渲染该物体。以下是Pass中使用的标签类型： | 标签类型 | 说明 | 例子 || ——————— | —————————————————————————————— | ————————————————————- || LightMode | 定义该Pass在Unity的渲染流水线中的角色 | Tags{“LightMode” = “ForwardBase”} || RequireOptions | 用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串。目前Unity支持的选项有：SoftVegetation | Tags{“RequireOptions” = “SoftVegetation”} | 除了上面普通的Pass定义外，Unity Shader还支持一些特殊的Pass，以便进行代码复用或者实现更复杂的效果。 UsePass : 可以使用该命令来复用其他Unity Shader中的Pass。 GrabPass：该Pass负责抓取屏幕并将结果存储在一张纹理中，用于后续的Pass处理。 2.2.4 Fallback在ShaderLab语义块的最后，是一个Fallback指令，它告诉Unity如果上面的所有SubShader在这块显卡都不能运行，就使用这个最低级的Shader！！ 123Fallback &quot;name&quot; &#x2F;&#x2F;告诉显卡使用哪个Unity Shader&#x2F;&#x2F;或者Fallback Off 3. Unity Shader的形式3.1 表面着色器表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。它的代码量很少，但渲染代价比较大。当给Unity提供一个表面着色器的时候，Unity需要在背后做很多工作，把它转换成顶点/片元着色器。 好处：Unity对顶点/片元着色器更高一层的的抽象，为我们处理很多光照细节，我们不需要操心这些事。 简单的表面着色器如下： 123456789101112131415Shader &quot;Custom&#x2F;Simple Surface Shader&quot;&#123; SubShader&#123; Tags&#123;&quot;RenderType&quot; &#x3D; &quot;Opaque&quot;&#125; CGPROGRAM #pragma surface surf Lambert struct Input&#123; float4 color : COLOR; &#125;; void surf(Input IN, input SurfaceOutput 0)&#123; o.Albedo &#x3D; 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 上面的程序中，表面着色器被定义在SubShader语义块中的CGPROGRAM和ENDCG中(而不是Pass中)，因为表面着色器不需要开发者关心使用多少个Pass以及每个Pass如何渲染，这些事情都交给Unity去完成就好了。CGPROGRAM和ENDCG之间的代码是使用CG/HLSL编写的，我们需要把CG/HLSL语言嵌套在ShaderLab语言中注意：此处的CG/HLSL是Unity封装过的，与标准的CG/HLSL几乎一样，只有细微差别，一些原生的函数可能Unity并没有提供。 3.2 顶点/片元着色器在Unity中，我们可以使用CG/HLSL语言来编写顶点/片元着色器（Vertex/Fragment Shader）。它更加复杂，但也更加灵活了。 12345678910111213141516Shader &quot;Custom&#x2F;Simple VertexFragement Shader&quot;&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v:POSITION):SV_POSITION&#123; return mul(UNITY_MATRIX_MVP, v); &#125; float4 frag():AV_Target&#123; return fixed4(1.0, 0.0, 0.0, 1.0) &#125; ENDCG &#125; &#125;&#125; 代码同样写在CGPROGRAM和ENDCG之间，但顶点/片元着色器是写在Pass语义块内的，而不是Subshader内，因为我们需要自己定义每个Pass。因此我们需要编写更多的代码，但也因如此变得灵活性更高，可以控制渲染的实现细节。 3.3 固定函数着色器对于一些比较老旧的设备，它们不支持可编程管线着色器，此时需要使用固定函数着色器（Fixed Function Shader），这样的着色器往往只能完成一些简单的效果。 12345678910111213Shader &quot;Tutorial&#x2F;Basic&quot;&#123; Properties&#123; _Color (&quot;Main Color&quot;, Color) &#x3D; (1, 0.5, 0.5, 1) &#125; SubShader&#123; Pass&#123; Material&#123; Diffuse [_Color] &#125; Lighting On &#125; &#125;&#125; 对于固定函数着色器来说，我们需要完全使用ShaderLab的语法(即使用ShaderLab的渲染设置命令)来编写，而不是CG/HLSL。","categories":[],"tags":[{"name":"Unity Shader","slug":"Unity-Shader","permalink":"http://yoursite.com/tags/Unity-Shader/"}],"keywords":[]},{"title":"lua","slug":"lua使用记录","date":"2020-01-09T13:51:43.000Z","updated":"2020-03-17T14:54:06.293Z","comments":true,"path":"2020/01/09/lua使用记录/","link":"","permalink":"http://yoursite.com/2020/01/09/lua%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"记录使用lua过程中遇到的问题","text":"记录使用lua过程中遇到的问题 字符串操作截去字符串首尾空格1string.gsub(str, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;) --截掉前后空格","categories":[],"tags":[],"keywords":[]},{"title":"npm","slug":"npm","date":"2020-01-03T13:51:43.000Z","updated":"2020-03-17T14:54:06.294Z","comments":true,"path":"2020/01/03/npm/","link":"","permalink":"http://yoursite.com/2020/01/03/npm/","excerpt":"记录使用npm过程中遇到的问题，免得再遇到时还到处搜索","text":"记录使用npm过程中遇到的问题，免得再遇到时还到处搜索 配置npm转到淘宝镜像安装npm后，默认是使用国外镜像的，所以不翻墙速度简直龟速，使用淘宝镜像就比较快了，切换方法如下： 1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; 且回原来是： 1npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F; 查看当前npm使用哪个源，则用这个命令 1npm config get registry","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}],"keywords":[]},{"title":"hexo笔记","slug":"hexo笔记","date":"2020-01-03T10:51:43.000Z","updated":"2020-03-17T14:54:06.293Z","comments":true,"path":"2020/01/03/hexo笔记/","link":"","permalink":"http://yoursite.com/2020/01/03/hexo%E7%AC%94%E8%AE%B0/","excerpt":"玩hexo过程中遇到的坑","text":"玩hexo过程中遇到的坑 本文主要参考自 https://chaooo.github.io/article/20161229.html，主要用来记录hexo搭建的整个过程，方便后面查看。 1.hexo安装在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.1.hexo 初始化安装 hexo 1npm install -g hexo-cli 在你想要存放该博客项目的目录下，执行以下命令，这两步都比较耗时，因为要下载许多文件 12hexo initnpm install 先预览一下效果 12hexo generatehexo server 上面命令可简化成如下： 12hexo ghexo s 运行成功后，即可在浏览器输入localhost:4000即可看到效果。 1.2.部署到远端我们这里以gitee码云作为远端进行部署，在根目录下找到_config.yml，添加以下代码 12345678# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: &#39;git&#39; repository: #github: git@github.com:lingengxiong&#x2F;lingengxiong.github.io.git gitee: git@gitee.com:lingengxiong&#x2F;lingengxiong.git branch: master 假如需要部署到多个远端，只需要在repository中配置多个地址即可。 配置完成后，安装deployer插件，该插件用来将生产的静态文件部署到远端仓库 1npm install hexo-deployer-git --save 安装完成即可生产静态文件，继而推送到远端 12hexo generatehexo deploy 温馨提示：第一次使用git时会弹出输入框，此时输入git仓库的用户名和密码即可。 2.hexo 主题安装尝试了很多种主题，最后决定用BlueLake，一方面是因为布局功能都很符合自己的需求，另一方面则是挺好看的 2.1.安装安装主题和渲染: 1$ git clone https:&#x2F;&#x2F;github.com&#x2F;chaooo&#x2F;hexo-theme-BlueLake.git themes&#x2F;BlueLake Blue是基于jade和stylus写的，所有需要安装hexo-renderer-jade和hexo-renderer-stylus 12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 切到themes/BlueLake，下载主题所需要的库 12$ cd themes&#x2F;BlueLake$ npm install 2.2.启用主题要使用刚下载好的主题，只需要修改根目录下_config.yml配置文件，找到theme字段，修改为BlueLake 1theme: BuleLake 依次执行以下命令，然后打开localhost:4000就可以看效果了 123hexo cleanhexo ghexo s 2.3 配置目前的整个工程都还是比较原始的状态，我们的工作就是添加我们自己的东西进去了。 2.3.1 配置网站头部显示文字打开_config.yml，找到： 12345678# Sitetitle: Hexosubtitle: &#39;&#39;description: &#39;&#39;keywords:author: John Doelanguage: entimezone: &#39;&#39; title和subtitle分别是网站主标题和副标题，会显示在网站头部； description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO； author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.3.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下： 1language: zh-CN 2.3.3 添加about页about页是一个介绍自己的页面，可以在上面写一些自己的联系方式或者其他平台博客链接之类 在根目录下运行命令： 1hexo new page &#39;about&#39; 打开主题_config.yml，补充详细信息： 1234567891011121314# About pageabout: photo_url: ## Your photo e.g. http:&#x2F;&#x2F;cdn.chaooo.top&#x2F;blog&#x2F;themeauthor.jpg items: - label: email url: ## Your email with mailto: e.g. mailto:zhenggchaoo@gmail.com title: ## Your email e.g. zhenggchaoo@gmail.com - label: github url: ## Your github&#39;url e.g. https:&#x2F;&#x2F;github.com&#x2F;chaooo title: ## Your github&#39;name e.g. chaooo - label: weibo url: ## Your weibo&#39;s url e.g. http:&#x2F;&#x2F;weibo.com&#x2F;zhengchaooo title: ## Your weibo&#39;s name e.g. 秋过冬漫长 2.3.4 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录打开命令行，运行以下命令： 123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置： 1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.3.5 更换主题背景该主题目前有两种背景，深色和浅色，需要设置为深色只需要修改主题_config.yml 12# Theme tonedark: false #true&#x2F;false 2.3.6 添加文章版权信息修改主题_config.yml 12345# Theme tone#Copyrightcopyright: enable: true #true&#x2F;false describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件： 1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置： 1local_search: true 2.5 首页添加文章置顶在根目录下打开命令行窗口安装： 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 假如文章需要添加置顶，只需要在Front-matter中加上top: true即可 123456---title: BlueLake博客主题的详细配置tags: [hexo,BlueLake]categories: Hexo博客折腾top: true--- 2.6 修改站点图标 站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 3. 笔记仓库与博客项目分离我们可以看到目前文章放在source/_posts目录下，我们不可能每次写笔记都跑到这里写，这里我采用git子模块的形式，我们平常笔记在自己的笔记仓库里写，写完推到远端仓库，更新博客只需要先拉一下笔记仓库里的文件，再更新到线上博客。这样做博客项目只负责发布，不负责编辑笔记。我的博客笔记放在https://gitee.com/lingengxiong/blog-note.git 3.1添加子模块的方法1git submodule add 仓库名 路径 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone） 3.2删除子模块方法submodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。 故先把source/_post文件夹删除，然后执行 1git submodule add https:&#x2F;&#x2F;gitee.com&#x2F;lingengxiong&#x2F;blog-note.git source&#x2F;_posts&#x2F; 这样我们已经成功把笔记仓库引入博客项目内，以后只需要定时拉取最新内容进行发布即可 3.3 README.md等文件不生成博客内容我们引入的博客仓库中包含有该仓库的README.md文件，这些文件不需要生成文章，可以修改根目录_config.yml文件进行屏蔽： 1skip_render: [&#39;_posts&#x2F;**&#x2F;README.md&#39;,&#39;_posts&#x2F;**&#x2F;README.en.md&#39;] 4.hexo备份与恢复3.1.备份在公司好不容易把工程搭建起来，却到了下班的时候，回家想继续搞岂不是蛋疼得再配置一遍？这可不行，而且要是电脑坏了怎么办，前面的时间岂不是白费，所以肯定得做好备份~ 最开始想到的是用传统的git 进行备份，但在网上搜了一下，发现前辈们早已想出更懒的办法，并做成插件—-hexo-git-backup，依旧是备份到github，但用起来更加便捷。 首先安装该插件 1npm install hexo-git-backup --save 然后到你的博客根目录的_config.yml配置文件中添加如下配置： 12345678#备份博客backup: type: git theme: hexo-theme-yilia-master message: Back up my blog repository: github: git@github.com:lingengxiong&#x2F;lingengxiong.github.io.git，backup gitee: git@gitee.com:lingengxiong&#x2F;lingengxiong.git,backup 参数解释： theme：你要备份的主题名称 message：自定义提交信息 repository：仓库名，注意仓库地址后面要添加一个分支名，比如我就创建了一个 backup 分支 我这里备份了两份，一份到github，另一份备份到码云，不需要的只配置一个即可，实际上我们是在放博客静态文件的仓库上拉了一个backup分支，如果你不放心，也可新建一个仓库用来存放整个博客工程 实际上，并不是整个工程都需要备份的，只需要备份关键几个文件夹即可，其余到时再次生成即可 1.生成.gitignore文件 1touch .gitignore 2.输入要忽略的文件及文件夹 1234567.DS_StoreThumbs.dbdb.json.lognode_modules&#x2F;public&#x2F;.deploy&#x2F; 3.最后用以下命令备份博客： 1hexo backup 或者简写： 1hexo b 2.恢复已经备份好的hexo，到新发电脑只需要使用以下步骤即可恢复，无需从头开始配置，这里以我的仓库地址为例，实际情况改成自己的地址即可 1.先安装hexo npm install -g hexo-cli 2.把存在远端的备份git clone下来 git clone https://gitee.com/lingengxiong/lingengxiong.git 这里备份在backup分支，可以直接下载对应分支 git clone -b backup https://gitee.com/lingengxiong/lingengxiong.git 3.下载所需要的库文件 npm install 4.下载推送工具deployer npm install hexo-deployer-git 5.接下来就可以用熟悉的命令生成博客站点了 123hexo cleanhexo ghexo s 正常情况下以上步骤完成后即可在浏览器用localhost:4000打开你的博客 继而发布到远端 hexo d 5.添加评论系统gitalk5.1申请第三方评论系统很多，如 多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论、基于Github Issue的GITALK 但国内的有写时不时就没法用了，所以这里还是使用gitalk 1.申请GitHub Application Application name： 应用名称，随便起 Homepage URL： 网站URL，对应自己博客地址 Application description ：描述，随意 Authorization callback URL：# 网站URL，博客地址就好 点击注册，页面会出现其中Client ID和Client Secret在后面的配置中需要用到 5.2 配置在主题_config.yml配置： 123456789101112131415161718comment: gitalk: enable: true ## If you want to use Gitment comment system please set the value to true. owner: lingengxiong ## Your GitHub ID, e.g. username repo: blogtalk ## The repository to store your comments, make sure you&#39;re the repo&#39;s owner, e.g. gitalk.github.io client_id: ## GitHub client ID, e.g. 75752dafe7907a897619 client_secret: ## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50 admin: lingengxiong ## Github repo owner and collaborators, only these guys can initialize github issues. language: zh-CN ## Language pagerDirection: last # Comment sorting direction, available values are last and first. 注意: 1.repo ,存放评论的仓库，这里我们新建一个名为blogtalk的仓库，这里只需要填入blogtalk即可，而不是完整地址 5.3 踩坑5.3.1 Error:Not Found 发现是gittalk中的信息填写错了，name随便写；Homepage URL是你的仓库的名字，Authorization callback URL如果你指向了新 的域名就填新的，比如说我指向了域名http://blog.lgx123.cn/；否则也写仓库的名字就可以。 5.3.2未找到相关Issues进行评论 1.理想状态登录一下github账号即可，假如点击后返回首页，那应该是配置有问题，检测gitalk各项参数 2.配置完成未发布到线上，使用localhost:4000访问，也会出现这种情况，点击登录会跳到线上工程地址，此时只需要试试发布到线上","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[]},{"title":"Android笔记","slug":"android笔记","date":"2019-12-28T09:00:00.000Z","updated":"2020-03-17T14:54:06.227Z","comments":true,"path":"2019/12/28/android笔记/","link":"","permalink":"http://yoursite.com/2019/12/28/android%E7%AC%94%E8%AE%B0/","excerpt":"记录一下Android学习过程","text":"记录一下Android学习过程 Intent一般可用于启动 活动、启动服务、发送广播等场景 四大组件 —— Activity活动的启动模式活动有4种启动模式，分别是standard ,singleTop, singleTask, singleInstance 可以在AndroidMainfest.xml中通过标签指定android:launchMode属性来选择启动模式。 1.standard默认的启动模式，此模式下系统不在乎返回栈中是否存在，每次启动都创新的活动实例 2.singleTop此模式下，在启动活动时发现返回栈的栈顶已经是该活动，则直接使用，不再创建新的活动实例。但如果该活动不位于栈顶位置，则再次启动该活动时，还是会创建新的实例 3.singleTask使用此模式，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没发现该活动实例，就会创建一个新的活动实例。 4.singleInstance此模式不同于以上3种模式，指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果 singleTask 模式指定了不同的 taskAffinity，也会启 动一个新的返回栈）。 应用场景：假设我们的程序中有一个 活动是允许其他程序调用的 ，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，就需要用此模式， 在这种模式下会有一个单独的返回栈来管理这个活 动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实 例的问题 四种布局1.LinearLayouta.线性布局，将它包含的控件在线性方向上一次排列 b.排列方向：可水平方向（vertical)，垂直方向排列(horizontal)，修改方法： 如果LinearLayout的排列方向是horizontal，内部控件宽度不能使用math_parent，会占满整个水平方向，同理vertical时内部控件高度不可使用match_parent。 2.RelativeLayout相对布局，与LinearLayout相比，更加随意一些，它能通过相对定位的方式让控件出现在布局的任何位置，可相对于整个容器，也可相对于某个控件 3.FrameLayout这种布局没有任何定位方式，所有控件都会摆放在布局的左上角（应用场景不多） 4.TableLayout使用表格方式来排列控件（不常用） 单位和尺寸px 像素，屏幕中可以显示的最小元素单位 pt 磅数的意思，1磅等于1/72英尺，一般用作字体的单位 dp 密度无关像素，也称dip，和px相比，它再不同密度的屏幕中的显示比例保持一致 sp 可伸缩像素，采用与dp同样的设计理念，解决字体大小适配问题 密度 Android中密度就是屏幕每英寸所包含的像素数，以dip为单位。 比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果 它的分辨率是 320x480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640*960， 那这个屏幕的密度就是 320dpi，因此密度值越高的屏幕显示的效果就越精细。 Android 规定，在160dpi的屏幕上，1dp等于1px，而在320dpi的屏幕上，1dp等于2px. 因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的 显示比例保持一致。 ​ 四大组件 ——- Broadcast ReceiveAndroid中的广播分为两种类型，即 标准广播 和 有序广播 1.标准广播标准广播是一直完全异步执行的广播，广播发出后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此他们之间没有任何的先后顺序可言。这种广播效率比较高，也意味着它无法被截断 2.有序广播有序广播是一种同步执行的广播，在广播发出后，同一时刻只会有一个广播接收器能接收到这条消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。 此时广播接收器是有先后顺序的，优先级高的广播接收器可以优先收到广播消息，也可截断正则传递的广播，使后面的广播接收器无法接收广播消息 3.注册广播分两种方式：在代码中注册（动态注册）、在AndroidMainifest.xml中注册（静态注册） 持久化计算Android系统主要提供三种数据持久化功能——-文件存储、SharedPreference存储以及数据库存储 1.文件存储不对存储的内容进行任何的格式化出来，所有数据原封不动存在文件中（适合存储一些简单的文本数据或者二进制数据），文件默认存储到/data/data//file/目录下 2.SharedPreferences存储使用键值对的方式来存储数据，较文件存储方便得多，而且支持多种不同数据类型的存储，即如果存入的数据类型是整型，读取出来的数据也是整形的 存储前，先获得SharedPreferences对象，Android中主要提供三种方法得到SharedPreferences对象 2.1. getSharedPreferences​ Context类中的getSharedPreferences(fileName，操作模式)方法 ​ 第一个参数用于指定文件名称，指定文件不存在则会创建一个，SharedPreferences文件存放在/data/data//shared_prefs/目录下 ​ 第二个参数用于指定操作模式，主要有两种模式可以选 择，MODE_PRIVATE 和 MODE_MULTI_PROCESS。MODE_PRIVATE 仍然是默认的操 作模式，和直接传入 0 效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences文件进行读写。MODE_MULTI_PROCESS 则一般是用于会有多个进程中 对同一个 SharedPreferences 文件进行读写的情况。类似地，MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE 这两种模式已在 Android 4.2 版本中被废弃 2.2.getSharedPreferences​ Activity类中的getSharedPreferences()方法 ​ 只接受一个操作模式参数，因为使用此方法时会自动将当前的类名作为SharedPreferences的文件名 2.3.getDefaultSharedPreferences​ PreferencesManager类中的getDefaultSharedPreferences()方法 ​ 这是一个静态方法，接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences对象 a.向SharedPreferences文件中存储数据分三步实现 1.调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象 2.向SharedPreferences对象中添加数据，比如添加布尔类型的数据就是用putBoolean方法 3.调用commit()方法，将添加的数据提交，从而完成数据存储操作 b.从SharedPreferences文件中读取数据使用SharedPreferences的get方法来对存储数据进行读取，每种get方法对应SharedPreferences.Editor中的一种put方法，例如读取布尔值，就使用getBoolean()方法 get方法接受两个参数，第一个是“键”，第二个是 默认值（即传入键找不到对应的值是，返回什么样的默认值） 3.SQLite数据库存储SQLite是一筐轻量级的关系型数据库，运算速度快，占用资源少，通常只需要几百k的内存就够了 Android提供了SQLiteOpenHelper帮助类，这是一个抽象类，有两个抽象方法—-onCreate() 和onUpgrade()， 使用时我们需要创建一个帮助类继承SQLiteOpenHelper，并在自己的帮助类中重写两个抽象方法，然后在这两个方法中区实现创建、升级数据库的逻辑 SQLiteOpenHelper中有两个构造方法可以重写，一般使用参数较少的的方法，此方法接收四个参数； 1.Context 2.数据库名 3.允许我们在查询数据的时候返回一个自定义的Cursor，一般传入null 4.当前数据库的版本号 3.1创建数据库：构建出SQLiteOpenHelper实例后，再调用getReadableDatabase()或getWritableDatabase()就能创建出数据库了，数据库文件存放在/data/data//database/目录下 3.2升级数据库只需要在构建SQLiteOpenHelper时传入的高于之前的版本号，就会调用onUpgrade() 3.3SQLite数据类型integer 整型 real 浮点型 text 文本型 blob 二进制型 四大组件 —— Content Provider主要用于在不同应用程序之间实现数据共享的功能，它的完整机制允许程序访问另一个程序中的数据，同时又保证被访问数据的安全性。 使用内容提供器是Android实现程序共享数据的标准方式 1.访问其他程序中的数据​ 每个应用程序想要访问内容提供器中的共享数据，要借助ContentResolve类，可以通过Context中的getContentResolver()方法获得该类的实例 ContentResolver提供了对数据进行CRUD的操作方法，即 insert()添加数据 update()更新数据 delete()删除数据 query()查询数据 这几个方法都只需要传入Uri参数，即内容URI，内容URI给内容提供器中的数据建立了唯一的标识，由两部分组成，即权限（authority）和路径（path） ​ a.权限用于对不同的应用程序做区分的，为了避免冲突，都会采用程序包名的方式来进行命名，如com.example.app，则该程序对应的权限命名为com.example.app.provider ​ b.路径用于对同一应用程序中不同的表做区分，通常加到权限后面，比如某个程序的数据库中有两张表，table1和table2，此时路径分别命名为/table1和/table2，与权限结合起来，内容URI就变成 com.example.app.provider/table1 和 com.example.app.provider/table2 ​ 在字符串头部加上协议声明，得到最标准的URI的格式写法如下： content://com.example.app.provider/table1 content://com.example.app.provider/table2 ​ 得到URI字符串后，将其解析成Uri对象才可作为参数传入增删改查方法中 ​ Uri uri = Uri.pase(“content://com.example.app.provider/table1”) 异步消息处理机制Android中的异步消息处理主要由四个部分组成，Message、Handler、MessageQueue、和Looper。 1.MessgaeMessage是线程之间传递的消息，可在内部携带少量的信息，用于不同线程之间交换数据。 例如what字段，除此之外arg1和arg2字段可携带一些整型数据，obj字段携带一个Object对象 2.Handler顾名思义就是处理者的意思，主要用你发送和处理消息。 发送消息一般是使用Handler的sendMessage()方法，发出的消息经过一系列辗转后，最终传递到Handler的handlerMessage()方法中。 3.MessageQueue消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象 4.LooperLooper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop()方法后，就会 进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取 出，并传递到 Handler 的 handleMessage()方法中。每个线程中也只会有一个 Looper 对象。 AsyncTaskAsyncTask 基于异步消息处理机制，Android帮我们做了很好的封装 AsyncTask是一个抽象类，使用它得用一个子类去继承它，继承时可以为AsyncTask类指定一个泛型参数。 1.Params​ 在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 2.Progress​ 后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为 进度单位。 3.Result​ 当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值 类型。 因此，一个最简单的自定义 AsyncTask 就可以写成如下方式： 1234class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;……&#125; 需要重写AsyncTask中的几个方法才能完成对任务的定制。 3.1.onPreExecute()​ 在后台任务开始之前调用，用于进行一些界面上的初始化，比如显示一个进度条对话框等 3.2.doInBackground(Params)​ 这个方法中的所有代码都会在子线程中运行，我们在这里处理所有耗时任务。任务完成后通过return语句来返回任务执行结果。如果AsyncTask的第三个泛型参数为void，就不返回执行结果。 ​ 注意：此方法中不可进行UI操作，如需更新UI元素，比如反馈当前任务进度，可以调用publishProgress(Progress …)方法来完成 3.3.onProgressUpdate(Progress…)​ 在后台任务中调用publishProgress(Progress…)方法后，会很快调用此方法，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值对界面元素进行相应的更新。 3.4.onPostExecute(Result)​ 当后台任务执行完毕并通过return语句进行返回时，这个方法就会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如提醒任务执行结果，以及关闭进度条对话框。 因此，一个比较完整的自定义 AsyncTask 就可以写成如下方式： 1234567891011121314151617181920212223242526272829303132333435363738class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; protected void onPreExecute() &#123; progressDialog.show(); &#x2F;&#x2F; 显示进度对话框 &#125; @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true) &#123; int downloadPercent &#x3D; doDownload(); &#x2F;&#x2F; 这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent &gt;&#x3D; 100) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; &#x2F;&#x2F; 在这里更新下载进度 progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;); &#125; @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); &#x2F;&#x2F; 关闭进度对话框 &#x2F;&#x2F; 在这里提示下载结果 if (result) &#123; Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot; Download failed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 四大组件 —— Service1. 定义一个服务基本的Service这样定义，onBind 是service中唯一一个抽象方法，所以必须在子类中进行实现 123456public class MyService extends Service&#123; @Override public IBinder onBind(Intent intent)&#123; return null; &#125;&#125; 让服务去处理一些事情，逻辑应该写在哪里呢？ 我们又重写onCreate()，onStartCommand()和onDestroy(）方法 123456789101112131415161718public class MyService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 以上三个新加的方法是每个服务中最常用的方法 oncreate() 在服务创建的时候调用 onStartCommand() 会在每次服务启动的时候调用 onDestroy() 会在服务销毁的时候调用 所以一旦服务启动就需要执行的动作，逻辑写在onStartCommand()方法中，在onDestroy中回收那些不需要的资源。 注意：每个服务都需要在AndroidManifest.xml中注册才能生效，这似乎是四大组件的共同特点。 123456789101112131415&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;com.example.servicetest&quot; android:versionCode&#x3D;&quot;1&quot; android:versionName&#x3D;&quot;1.0&quot; &gt; …… &lt;application android:allowBackup&#x3D;&quot;true&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_launcher&quot; android:label&#x3D;&quot;@string&#x2F;app_name&quot; android:theme&#x3D;&quot;@style&#x2F;AppTheme&quot; &gt; …… &lt;service android:name&#x3D;&quot;.MyService&quot; &gt; &lt;&#x2F;service&gt; &lt;&#x2F;application&gt;&lt;&#x2F;manifest&gt; 2. 启动和停止服务启动和停止服务主要借助Intent来实现 启动服务： 12Intent starIntent &#x3D; new Intent(this, MyService.class);startService(starIntent); 停止服务 12Intent stopIntent &#x3D; new Intent(this, MyService.class);stopService(stopIntent); 服务除了由活动来决定何时停止外，它也能自己让自己停下来，只需要服务自己调用stopSelf()方法即可 3.活动与服务进行通信​ 上面使用的方法在活动中启动和停止服务，但是服务启动后活动和服务基本没有关系了，无法得知服务的状态，如何才能让活动和服务联系更加紧密呢，让活动能随时指挥服务去执行某些任务？这就需要用到刚才那个我们必须要重写的onBind()方法了。 1234567891011121314151617public class MyService extends Service &#123; private DownloadBinder mBinder &#x3D; new DownloadBinder(); class DownloadBinder extends Binder &#123; public void startDownload() &#123; Log.d(&quot;MyService&quot;, &quot;startDownload executed&quot;); &#125; public int getProgress() &#123; Log.d(&quot;MyService&quot;, &quot;getProgress executed&quot;); return 0; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; ……&#125; ​ 这里我们在刚才建的MyService类中新建一个DownloadBinder类，并继承自Binder，这个类里提供方法供外部使用，我们这里提供了开始下载方法和获取下载进度的方法。然后在MyService中创建了DownloadBinder实例，并在onBind()方法中返回该实例。 ​ 如何在活动中调用服务里的方法呢？实际上当一个活动与服务绑定了之后，就可以调用Binder提供的方法了。 ​ 在活动中，我们首先创建ServiceConnection 匿名类，在里面重写onServiceConnected()方法和 onServiceDisconnected()方法，这两个方法分别在活动与服务成功绑定和解除绑定时调用。在onServiceConnecter()方法中，我们又向下转型得到的DownloadBinder实例，有了实例，我们就可以在活动中调用DownloadBinder中的任何public方法了。 12345678910111213private MyService.DownloadBinder downloadBinder;private ServiceConnection connection &#x3D; new ServiceConnection()&#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder &#x3D; (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125;&#125; ​ 别高兴太早，我们还没实现绑定呢。绑定方法如下: 12Intent bindIntent &#x3D; new Intent(this, Myservice.class);bindService(bindIntent, connection, BIND_AUTO_CREATE); ​ bindService()接收三个参数，第一个就是刚构建出来的Intent对象，第二个参数是前面创角出来的ServiceConnection实例，第三个参数是标志位，BIND_AUTO_CREATE表示在活动和服务进行绑定后自动创建服务，此时MyService中的onCreate()方法会执行，但onStartCommand()方法不会执行。 ​ 解绑方法比较简单： 1unbindService(connetion); ​ 注意：任何一个服务在整个应用程序范围内都是通用的，即任何一个活动都可与之绑定，而且绑定后他们都可以获取到相同的DownloadBinder实例。 4.服务的生命周期onCreate() ,onStartCommand(),onBind(),onDestroy()等方法都是在服务生命周期里可能回调的方法。 1.项目中任意位置调用Context的startService()方法，相应的服务就会启动，并回调onStartCommand()方法，假如服务没创建过，onCreat()方法会先于onStartCommand()方法执行。 2.服务启动后一直保持运行，直到stopService()或stopSelf()被调用 每次调用startService()方法，onStartCommand()方法就会调用一次，但每个服务只会有一个实例，无论调用多少次startService()，只需要调用一次stopService()或stopSelf()即可停止该服务 3.调用Context的bindService()方法，获取一个服务的持久连接，这是就会回调服务的onBind()方法，如果服务没创建过，onCreate()会先于onBind()方法执行。调用方可以获取onBind()方法里返回的IBinder对象的实例，这样即可与服务自由的通信了。调用方与服务之间的连接没有断开，服务就会一直保持运行状态。 4.调用startService()方法后，又调用stopService()方法，onDestroy()方法就会执行，此时服务已经销毁。类似的，调用bindService()方法后又调用unbindService()方法，onDestroy()方法也会执行。 5.Android系统机制规定，一个服务被启动或者被绑定后，就会一直处于运行状态，必须同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。 5.前台服务服务的系统优先级比较低，内存不足时，可能被回收，而前台服务就不会因为内存不足而被回收。 与普通服务最大区别：会有一个正在运行的图标在系统状态栏显示。下拉状态栏可以看到详细信息，类似通知的效果。 创建方法类似创建通知方法： 1234567891011121314151617public class MyService extends Service &#123; …… @Override public void onCreate() &#123; super.onCreate(); Notification notification &#x3D; new Notification(R.drawable.ic_launcher, &quot;Notification comes&quot;, System. currentTimeMillis()); Intent notificationIntent &#x3D; new Intent(this, MainActivity.class); PendingIntent pendingIntent &#x3D; PendingIntent.getActivity(this, 0, notificationIntent, 0); notification.setLatestEventInfo(this, &quot;This is title&quot;, &quot;This is content&quot;, pendingIntent); startForeground(1, notification); Log.d(&quot;MyService&quot;, &quot;onCreate executed&quot;); &#125; ……&#125; 网络1.使用HTTP协议访问网络​ Android 上发送HTTP请求有两种，1.HttpURLConnection和 2. HttpClient 1.1 HttpURLConnection先获取HttpURLConnection实例，new出一个URL对象，传入目标的网络地址，然后调一下openConnection()方法即可： 12URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);HttpURLConnection connection &#x3D; (HttpURLConnection)url.openConnection(); 得到HttpURLConnection的实例后，设置HTTP请求所使用的方法。常用方法：GET 和 POST ​ GET：表示希望从服务器获取数据 ​ POST :表示希望提交数据到服务器 1.1.1 GET写法如下： 1connection.setRequestMethod(&quot;GET&quot;); 设置连接超时、读取超时的毫秒，以及服务器希望得到的一些消息头等。根据自己实际情况进行编写： 12connection.setConnectTimeout(8000);connection.setReadTimeout(8000); 之后调取getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取 1InputStream in &#x3D; connection.getInputStream(); 最后调用disconnect()方法关闭HTTP连接： 1connection.disconnect(); 1.1.2 POST需要向服务器提交数据，采用POST的方式，数据之间用&amp; 123connection.setRequestMethod(&quot;POST&quot;);DataOutputStream out &#x3D; new DataOutputStream(connection.getOutputStream());out.writeBytes(&quot;username&#x3D;admin&amp;password&#x3D;123456&quot;); 1.2. 使用HttpClientHttpClient是Apache提供的HTTP网络访问接口，一开始就被引入Android API中，几乎可以完成与HttpURLConnection同样的效果，只是用法有较大的差别。 HttpClient是一个接口，无法创建它的实例，通常会创建一个DefaultHttpClient的实例： 1HttpClient httpClient &#x3D; new DefaultHttpClient(); 1.2.1 GET想发起一条GET请求，可以创建一个HttpGet对象，传入目标网络地址，然后调用HttpGet的execute()方法： 12HttpGet httpGet &#x3D; new HttpGet(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);httpClient.excute(httpGet); 1.2.2 POST使用POST请求比GET复杂一点，需创建HttpPost对象，并传入目标地址： 1HttpPost httpPost &#x3D; new HttpPost(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;); 1.然后通过一个NameValuePair集合来存放待提交的参数， 2.并将这个参数集合传入一个UrlEncodedFormEntity中， 3.然后调用HttpPost的setEntity()方法将构建好的UrlEncodedFormEntity传入 12345List&lt;NameValuePair&gt; params &#x3D; new ArrayList&lt;NameValuePair&gt;();params.add(new BasicNameValuePair(&quot;username&quot;,&quot;admin&quot;));params.add(new BasicNameValuePair(&quot;password&quot;,&quot;123456&quot;));UrlEncodedFormEntity entity &#x3D; new UrlEncodedFormEntity(params, &quot;utf-8&quot;);httpPost.setEntity(entity); 4.接下来就和HttpGet一样，调用HttpClient的execute()方法，并将HttpPost对象传入 1httpClient.execute(httpPost); 1.2.3 处理返回结果执行完上面的操作，会返回一个HttpResponse对象，包含服务器返回的所有信息。通常我们会先取出服务器返回的状态码，等于200说明请求和响应都成功了 123if (httpResponse.getStatusLine().getStatusCode() &#x3D;&#x3D; 200)&#123; &#x2F;&#x2F;请求、响应都成功&#125; 假如得到状态码200，则可调用getEntity()方法获取到一个HttpEntity实例，然后调用EntityUtils.toString()这个静态方法将HttpEntity转换成字符串即可： 12HttpEntity entity &#x3D; httpResponse.getEntity();String response &#x3D; EntityUtils.toString(entity); 假如返回数据中包含中文，EntityUtils.toString()方法会出现乱码，需要将字符集指定为utf-8： 1String response &#x3D; EntityUtils.toString(entity, &quot;utf-8&quot;); 基于位置的服务简称LBS，利用无线电通信网络或者GPS等定位方式，确定出移动设备所在的位置。安卓中使用LocationManager类就能实现。 1.LocationManager基本用法获取LocationManager实例，可以调用Context的getSystemService() 1LocationManager locationManager &#x3D;(LocationManager)getSystemService(Context.LOCATION_SERVICE); 接着需要选择一个位置提供器来确定设备当前的位置。Android中一般有三种位置提供器供选择，GPS_PROVIDER、NETWORK_PROVIDER 和 PASSIVE_PROVIDER 1.1 获取位置将选择好的内容提供器传入到getLastKnownLocation()方法中，就可以得到一个Location对象： 12String provider &#x3D; LocationManager.NETWORK_PROVIDER;Location location &#x3D; LocationManager.getLastKnownLocation(provider); Location对象中包含经度，纬度，海拔等一系列位置信息，我们从中取出想要的数据即可。 想要经度较高的数据，需要用GPS定位功能，使用之前需要先确定定位功能是否启用。 1List&lt;String&gt; providerList &#x3D; locationManager.getProviders(true); getProviders()方法传入true表示只有启用位置提供器才会被返回，之后再从providerList中判断是否包含GPS定位功能就行。 1.2 监听位置变化getLastKnownLocation() 方法可以获取设备当前位置信息，想要知道设备位置变化，可以使用LocationManager的requestLocationUpdates()方法，只需要传入一个LocatiionListener，配置几个参数即可: 1234567891011121314locationManager.requestLocationUpadtes(LocationManager.GPS_PROVIDER, 5000, 10, new LocationListener()&#123; @Override public void onStatusChanged(String provider, int status, Bundle extras) &#123; &#125; @Override public void onProviderEnabled(String provider) &#123; &#125; @Override public void onProviderDisabled(String provider) &#123; &#125; @Override public void onLocationChanged(Location location) &#123; &#125;&#125;) 参数一：位置提供器类型 参数二 : 监听位置变化的时间间隔，单位：毫秒 参数三：监听位置变化的距离间隔，以米为单位 参数四：LocationListener监听器 所以上面例子的效果是：监听GPS位置变化，每5秒检测一下，距离超过10米时，调用LocationListener的onLocationChanged()方法，把新的位置信息作为参数传入。 2. Geocoding API用法（反向地理编码）","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"webpack笔记","slug":"webpack笔记","date":"2019-02-27T10:00:43.000Z","updated":"2020-03-17T14:54:06.389Z","comments":true,"path":"2019/02/27/webpack笔记/","link":"","permalink":"http://yoursite.com/2019/02/27/webpack%E7%AC%94%E8%AE%B0/","excerpt":"今天想了解一下webpack，但找了网上的一系列教程，都会或多或少出现一些不明报错，实在恼火，经过几番简化，终于用最简单的方法使用了webpack，在此记录一下","text":"今天想了解一下webpack，但找了网上的一系列教程，都会或多或少出现一些不明报错，实在恼火，经过几番简化，终于用最简单的方法使用了webpack，在此记录一下一.环境配置1.首先，安装Node.js，这里不赘述，未接触nmp的童鞋可以参考Node.js安装配置 2.在cmd中输入 1npm install webpack -g 3.在自己测试的位置创建一个新的文件夹，命名webpack_demo 4.进入刚刚所创建的文件夹webpack_demo，按住shift键同时点击鼠标右键(即打开cmd并进入webpack_demo文件夹) 5.在打开的命令窗口键入：npm init，根据提示填写信息，name表示项目名，version表示版本等等，不一一赘述了，也可使用默认值，一路回车即可，最后出现“is this ok?”时，敲击回车键，webpack_demo文件夹便生成了package.json文件夹 二.构建webpack项目1.在webpack_demo文件夹下创建webpack.config.js文件，此文件为webpack的配置文件。具体内容如下： 123456789&#x2F;&#x2F;webpack.config.jsmodule.exports&#x3D;&#123; entry:&#39;.&#x2F;src&#x2F;js&#x2F;entry.js&#39;, &#x2F;&#x2F;页面入口文件 &#x2F;&#x2F;输出文件 output:&#123; filename:&#39;index.js&#39;, &#x2F;&#x2F;输出文件名 path:__dirname+&#39;&#x2F;out&#39;, &#x2F;&#x2F;输出文件路径 &#125;&#125; 参数简单说明： entry： 是 页面入口文件配置 （html文件引入唯一的js 文件） output：对应输出项配置 ​ path ：入口文件最终要输出到哪里， ​ filename：输出文件的名称 ​ publicPath：公共资源路径 2.接着，我们在创建一些基本的文件保存路径，我们这里创建网页中最基本的一些文件夹 3.接下来我们在index.html，和entry.js中填充点内容 123456789101112&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt;hello world&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;out&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12&#x2F;&#x2F; entry.jsdocument.write(&#39;呵呵到天亮&#39;); 4.完成以上操作，我们可以来试试效果了，在刚才所打开的cmd窗口中输入webpack （假如已经关闭，按上面第4步操作即可） 下面WARNING in configuration原因及解决办法可点击链接：https://blog.csdn.net/lgx1134569285/article/details/87986317 5.看到上面 的一幕，恭喜你，已经成功了，我们再进一步验证一下， 目录下多了一个out文件夹，out文件生成了我们所命名的index.js 打开内容如下 打开index.html文件，结果不仅打印出html文件中的”hello world”，js中的打印123也生效了 (ps：这里打印中文时假如出现乱码，记得在html文件的标签添加编码)","categories":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}]}]}