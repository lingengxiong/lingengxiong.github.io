{"meta":{"title":"呵呵到天亮","subtitle":"","description":"","author":"lingengxiong","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2020-01-06T08:16:40.000Z","updated":"2020-01-17T02:01:54.714Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Unity_Shader入门精要学习笔记3","slug":"图形学/Unity_Shader入门精要3-数学基础","date":"2020-09-14T02:53:45.000Z","updated":"2020-09-14T03:01:41.816Z","comments":false,"path":"2020/09/14/图形学/Unity_Shader入门精要3-数学基础/","link":"","permalink":"http://yoursite.com/2020/09/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%813-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"第四章","categories":[{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/categories/Shader/"}],"tags":[],"keywords":[{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/categories/Shader/"}]},{"title":"Unity Shader入门精要学习笔记2","slug":"图形学/Unity_Shader入门精要2-Unity Shader基础","date":"2020-08-27T02:41:40.000Z","updated":"2020-09-14T03:01:41.814Z","comments":false,"path":"2020/08/27/图形学/Unity_Shader入门精要2-Unity Shader基础/","link":"","permalink":"http://yoursite.com/2020/08/27/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%812-Unity%20Shader%E5%9F%BA%E7%A1%80/","excerpt":"","text":"第3章 Unity Shader基础3.1 Unity Shader概述3.1.1 材质和Unity Shader在Unity中，我们使用材质（Material）和Unity Shader才能达到想要的效果。流程如下： 创建一个材质 创建一个Unity Shader，并赋给上一步中创建的材质； 把材质赋给渲染对象； 在材质面板中调整Unity Shader的属性，以得到满意的效果。 3.1.2 Unity中的材质Unity中材质需要结合一个GameObject的Mesh或者Particle Systems组件来工作。 创建材质： Assets -&gt; Create -&gt; Material 3.1.3 Unity中的ShaderUnity中，共提供了4种Shader模板供我们选择： Standard Surface Shader：产生一个包含了标准光照模型的表面着色器模型 Unlit Shader：产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器 Image Effect Shader：为我们实现各种屏幕后处理效果提供一个基本模板 Compute Shader：产生一种特殊的Shader文件，这类Shader利用GPU的并行性来进行一些与常规渲染流水线无关的计算 3.2 Unity Shader的基础：ShaderLabUnity Shader是Unity为开发者提供的高层级的渲染抽象层，用这种方式让开发者更加轻松地控制渲染。 没有使用Unity Shader，开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果。 在Unity Shader帮助下，开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有工作。 什么是ShaderLab？ ShaderLab是Unity 提供的编写Unity Shader的说明性语言。它使用一些嵌套在花括号内部的语义来描述Unity Shader文件的结构。这些结构包含了许多渲染所需要的的数据。 一个Unity Shader的基础结构如下： 123456789101112Shader \"ShaderName\"&#123; Properties&#123; //属性 &#125; SubShader&#123; //显卡A使用的子着色器 &#125; SubShader&#123; //显卡B使用的子着色器 &#125; Fallback \"VertexLit\"&#125; 3.3 Unity Shader的结构3.3.1 Shader的名字ShaderLab 文件第一行，指定Shader的名字，通过斜杆(“/”)，可控制Unity Shader在材质面板中的位置，如： 1Shader &quot;Custon&#x2F;MyShader&quot; 则Shader所在位置： 3.3.2 材质和Unity Shader的桥梁：PropertiesProperties语义块包含了一系列属性，这些属性会出现在材质面板中 12345Properties&#123; Name1(&quot;display name1&quot;, PropertyType1) &#x3D; DefaultValue1 Name2(&quot;display name2&quot;, PropertyType2) &#x3D; DefaultValue2 ...&#125; 属性名通常以下划线”_”开头，定义了这些属性后，即可在材质面板调节各种材质属性。使用每个属性的名字(Name) 可在Shader中访问它们。 每种属性都需要指定类型（PropertyType），以及赋予默认值，常用属性如下： 属性类型 默认值定义语法 例子 Int number _Int(“Int”, Int) = 2 Float number _Float(“Int”, Float) = 2 Range(min, max) number _Range(“Range”, Range(0.0, 10.0)) = 1.5 Color (number,number,number,number,) _Color(“Color”, Color) = (255,255,255,255) Vector (number,number,number,number,) _Vector(“Vector”, Vector) = (1, 1, 1 ,1) 2D “defaulttexture”{} _2D(‘2D’, 2D) = “”{} Cube “defaulttexture”{} _Cube(‘Cube’, Cube= “white”{} 3D “defaulttexture”{} _3D(‘3D’, 3D) = “black”{} 3.3.3 SubShader每个Unity Shader文件可包含至少一个SubShader。当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择一个能够在目标平台运行 的SubShader。假如没有一个SubShader支持的话，Unity会使用Fallback语义指定的Unity Shader。 原因：不同显卡能力性能不同，比较老的显卡可能支持的操作指令数量较少，高级的显卡可支持的指令数较多，故而我们希望程序能在旧的显卡上运行，又能在高级的显卡上有更好的体验。 SubShader语义块通常如下： 123456789101112SubShader&#123; &#x2F;&#x2F;可选 标签 [Tags] &#x2F;&#x2F;可选 状态 [RenderSetup] Pass&#123; &#125; Pass&#123; &#125; ...&#125; Pass：每个Pass定义了一次完整的渲染流程，Pass过多会造成渲染性能下降 状态设置：ShaderLab提供了一系列渲染状态的指令，这些指令可以设置显卡的各种状态，例如：是否开启混合，或者是否开启深度测试。 常用渲染状态设置选项如下： 状态名称 设置指令 解释 Cull Cull Back\\ Front\\ Off 设置剔除模式：剔除背面/正面/关闭剔除 ZTest ZTest Less Greater\\ LEqual\\ GEqual\\ Equal\\ NotEqual\\ Always 设置深度测试时使用的函数 ZWrite ZWrite On\\ Off 开启/关闭深度写入 Blend Blend SrcFactor DstFactor 开启并设置混合模式 在SubShader块中设置上述渲染状态时，将会应用到所有的Pass，假如不希望这样，只想作用于特定Pass，可以再Pass语义块中单独进行设置。 SubShader的标签 SubShader的标签(Tags)是一个键值对(Key/Value Pair)，它的键和值都是字符串类型。这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：SubShader希望如何、以及何时渲染这个对象。 标签结构如下： 1Tags&#123; &quot;TagName1&quot; &#x3D; &quot;Value1&quot; &quot;TagName2&quot; &#x3D; &quot;Value2&quot;&#125; SubShader的标签块支持的标签类型如下： 注意：上述标签只能在SubShader中声明，不能在Pass块中声明。 Pass语义块 Pass语义块的语义如下： 12345Pass&#123; [Name] [Tags] [RenderSetup]&#125; 定义Pass名字 1Name &quot;MyPassName&quot; 通过这个名字，可以在其他Unity Shader中使用该Pass： 1UsePass &quot;MyShader&#x2F;MYPASSNAME&quot; 这样就提高了代码的复用性，我们可以发现调用的过程中使用了大写的形式，这并不是写错，而是因为Unity内部会把所有的Pass的名称都转成大写，故而我们在使用UsePass时，必须使用大写的形式。 Pass标签Pass同样可以设置标签，它的标签不同于SubShader的标签，这些标签也是用于告诉渲染引擎如何来渲染该物体。以下是Pass中使用的标签类型： 标签类型 说明 例子 LightMode 定义该Pass在Unity的渲染流水线中的角色 Tags{“LightMode” = “ForwardBase”} RequireOptions 用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串。目前Unity支持的选项有：SoftVegetation Tags{“RequireOptions” = “SoftVegetation”} 除了上面普通的Pass定义外，Unity Shader还支持一些特殊的Pass，以便进行代码复用或者实现更复杂的效果。 UsePass : 可以使用该命令来复用其他Unity Shader中的Pass。 GrabPass：该Pass负责抓取屏幕并将结果存储在一张纹理中，用于后续的Pass处理。 3.3.4 Fallback在ShaderLab语义块的最后，是一个Fallback指令，它告诉Unity如果上面的所有SubShader在这块显卡都不能运行，就使用这个最低级的Shader！！ 123Fallback &quot;name&quot; &#x2F;&#x2F;告诉显卡使用哪个Unity Shader&#x2F;&#x2F;或者Fallback Off 3.4 Unity Shader的形式3.4.1 表面着色器表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。它的代码量很少，但渲染代价比较大。当给Unity提供一个表面着色器的时候，Unity需要在背后做很多工作，把它转换成顶点/片元着色器。 好处：Unity对顶点/片元着色器更高一层的的抽象，为我们处理很多光照细节，我们不需要操心这些事。 简单的表面着色器如下： 123456789101112131415Shader &quot;Custom&#x2F;Simple Surface Shader&quot;&#123; SubShader&#123; Tags&#123;&quot;RenderType&quot; &#x3D; &quot;Opaque&quot;&#125; CGPROGRAM #pragma surface surf Lambert struct Input&#123; float4 color : COLOR; &#125;; void surf(Input IN, input SurfaceOutput 0)&#123; o.Albedo &#x3D; 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 上面的程序中，表面着色器被定义在SubShader语义块中的CGPROGRAM和ENDCG中(而不是Pass中)，因为表面着色器不需要开发者关心使用多少个Pass以及每个Pass如何渲染，这些事情都交给Unity去完成就好了。 CGPROGRAM和ENDCG之间的代码是使用CG/HLSL编写的，我们需要把CG/HLSL语言嵌套在ShaderLab语言中 注意：此处的CG/HLSL是Unity封装过的，与标准的CG/HLSL几乎一样，只有细微差别，一些原生的函数可能Unity并没有提供。 3.4.2 顶点/片元着色器在Unity中，我们可以使用CG/HLSL语言来编写顶点/片元着色器（Vertex/Fragment Shader）。它更加复杂，但也更加灵活了。 12345678910111213141516Shader &quot;Custom&#x2F;Simple VertexFragement Shader&quot;&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v:POSITION):SV_POSITION&#123; return mul(UNITY_MATRIX_MVP, v); &#125; float4 frag():AV_Target&#123; return fixed4(1.0, 0.0, 0.0, 1.0) &#125; ENDCG &#125; &#125;&#125; 代码同样写在CGPROGRAM和ENDCG之间，但顶点/片元着色器是写在Pass语义块内的，而不是Subshader内，因为我们需要自己定义每个Pass。因此我们需要编写更多的代码，但也因如此变得灵活性更高，可以控制渲染的实现细节。 3.4.3 固定函数着色器对于一些比较老旧的设备，它们不支持可编程管线着色器，此时需要使用固定函数着色器（Fixed Function Shader），这样的着色器往往只能完成一些简单的效果。 12345678910111213Shader &quot;Tutorial&#x2F;Basic&quot;&#123; Properties&#123; _Color (&quot;Main Color&quot;, Color) &#x3D; (1, 0.5, 0.5, 1) &#125; SubShader&#123; Pass&#123; Material&#123; Diffuse [_Color] &#125; Lighting On &#125; &#125;&#125; 对于固定函数着色器来说，我们需要完全使用ShaderLab的语法(即使用ShaderLab的渲染设置命令)来编写，而不是CG/HLSL。","categories":[{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/categories/Shader/"}],"tags":[],"keywords":[{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/categories/Shader/"}]},{"title":"Win10修改文件默认打开方式","slug":"CMD/Win10修改文件默认打开方式","date":"2020-08-25T07:23:16.000Z","updated":"2020-09-14T03:01:41.795Z","comments":false,"path":"2020/08/25/CMD/Win10修改文件默认打开方式/","link":"","permalink":"http://yoursite.com/2020/08/25/CMD/Win10%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/","excerpt":"","text":"问题：更新win10的一些版本之后，会出现无法设置默认打开方式的情况，例如我想默认用NotePad++来打开.json文件都没办法，只有已经列出的和”在Microsoft Store中查找” 解决办法：网上很多都是通过手动修改注册表的方式，但那堆注册表，翻起来有点麻烦。直接用命令修改更快一些。 以管理员打开cmd 查看当前打开方式，这里以.json为例 运行： 1assoc .json 结果： 12C:\\WINDOWS\\system32&gt;assoc .json.json=VisualStudio.json.14.0 可以看到目前默认用的是VisualStudio 设置默认打开方式 命令： 1assoc .json=json_auto_file 结果： 12C:\\WINDOWS\\system32&gt;assoc .json=json_auto_file .json=json_auto_file 命令： 1ftype json_auto_file=\"C:\\Program Files (x86)\\Notepad++\\notepad++.exe\" \"%1\" 结果： 12C:\\WINDOWS\\system32&gt;ftype json_auto_file=\"C:\\Program Files (x86)\\Notepad++\\notepad++.exe\" \"%1\"json_auto_file=\"C:\\Program Files (x86)\\Notepad++\\notepad++.exe\" \"%1\" 路径以指定软件实际安装目录为准","categories":[],"tags":[],"keywords":[]},{"title":"Tomcat安装配置","slug":"tomcat/Tomcat安装配置","date":"2020-08-18T03:07:28.000Z","updated":"2020-09-14T03:01:41.796Z","comments":false,"path":"2020/08/18/tomcat/Tomcat安装配置/","link":"","permalink":"http://yoursite.com/2020/08/18/tomcat/Tomcat%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一. 下载下载地址：https://tomcat.apache.org/ 左侧选择下载版本，我这里下载Tomcat9 下载跟电脑系统匹配的版本： 注意：要根据自己的JDK版本选择Tomcat的版本。 二. 配置环境变量变量值根据自己的安装包放置位置配置。 系统环境变量Path，添加%CATALINA_HOME%\\bin； 三. 验证配置是否成功cmd 输入catalina version，出现如下结果表明安装成功。 1234567891011121314λ catalina versionUsing CATALINA_BASE: \"D:\\Program Files\\apache-tomcat-9.0.37\"Using CATALINA_HOME: \"D:\\Program Files\\apache-tomcat-9.0.37\"Using CATALINA_TMPDIR: \"D:\\Program Files\\apache-tomcat-9.0.37\\temp\"Using JRE_HOME: \"C:\\Program Files\\Java\\jdk1.8.0_144\"Using CLASSPATH: \"D:\\Program Files\\apache-tomcat-9.0.37\\bin\\bootstrap.jar;D:\\Program Files\\apache-tomcat-9.0.37\\bin\\tomcat-juli.jar\"Server version: Apache Tomcat/9.0.37Server built: Jun 30 2020 20:09:49 UTCServer number: 9.0.37.0OS Name: Windows 10OS Version: 10.0Architecture: amd64JVM Version: 1.8.0_144-b01JVM Vendor: Oracle Corporation 四. 启动Tomcat命令行直接执行startup.bat，打开浏览器，输入http://localhost:8080/ 五. 配置http文件下载服务器本次配置变量如下，实际配置已自己情况灵活变动。 文件放置目录：E:\\CDN tomcat安装目录：D:\\Program Files\\apache-tomcat-9.0.37 设置tomcat虚拟目录 在D:\\Program Files\\apache-tomcat-9.0.37\\conf\\Catalina\\localhost 新建XML文件，名字随意，这里起名download，内容如下： 123&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Context path=\"/download2\" reloadable=\"true\" docBase=\"E:\\CDN\" crossContext=\"true\"&gt;&lt;/Context&gt; 上面download2名字可以随意，最终目录以文件名为准，所以就算这里是download2，最终还是以download为准。 允许tongcat列举文件 修改D:\\Program Files\\apache-tomcat-9.0.37\\conf\\web.xml文件 1234&lt;init-param&gt;&lt;param-name&gt;listings&lt;/param-name&gt;&lt;param-value&gt;true&lt;/param-value&gt;&lt;/init-param&gt; 验证 重启tomcat程序，即可在浏览器中访问http://localhost:8080/download/","categories":[],"tags":[],"keywords":[]},{"title":"Unity Shader入门精要学习笔记1","slug":"图形学/Unity_Shader入门精要1-渲染流水线","date":"2020-08-16T14:11:33.000Z","updated":"2020-09-14T03:01:41.813Z","comments":false,"path":"2020/08/16/图形学/Unity_Shader入门精要1-渲染流水线/","link":"","permalink":"http://yoursite.com/2020/08/16/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%811-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/","excerpt":"","text":"第2章 渲染流水线2.1 什么是渲染流水线渲染流水线中3个概念阶段：应用阶段，几何阶段，光栅化阶段 应用阶段 由CPU负责，此阶段我们需要设置好每个模型的渲染状态，渲染状态包括但不限于它的材质，纹理以及使用的Shader等。此阶段最重要的输出是渲染所需的几何信息——渲染图元(rendering primitives)。 渲染图元可以是点、线、三角面等。渲染图元将被传递到下一阶段——几何阶段。 几何阶段 这一阶段通常在GPU上进行，决定需要绘制的图元是什么，如何绘制它们，在哪绘制它们。 这阶段负责和应用阶段传过来的每个 渲染图元 打交道，进行逐顶点、逐多边形的操作，可细分为更小的流水线阶段。 几何阶段的重要任务就是把顶点坐标转换到屏幕空间中，交给光栅器进行处理。此阶段对渲染图元进行处理后，会输出屏幕空间的二维顶点坐标，每个顶点对应的深度值，着色等相关信息，并传到下一阶段——光栅化阶段 光栅化阶段 此阶段也是在GPU上进行，使用上阶段传递过来的数据来产生屏幕像素，并渲染出最终的图像。 主要任务是决定每个渲染图元中的哪些像素应该绘制到屏幕上。需要对上一阶段得到的逐顶点数据（如纹理坐标，顶点颜色等）进行插值，然后进行逐像素处理。 2.2 CPU和GPU之间的通信​ 渲染流水线的起点是CPU，即应用阶段，应用阶段大概分为3个阶段： 把数据加载到显存。 设置渲染状态 调用Draw Call 2.2.1 把数据加载到显存​ 渲染数据先从硬盘加载到内存中，然后网格和纹理等数据又被加载到显存中。 ​ 数据加载到显存后，内存中的数据就能移除了，但有些数据我们可能还需要访问它（例如，我们可能需要CPU访问网格数据来进行碰撞检测），此时数据就暂时不需要移除出内存。 2.2.2 设置渲染状态​ 渲染状态定义了场景中网格如何被渲染，例如使用哪个顶点着色器，哪个片元着色器，使用什么材质等。假如不更改渲染状态，所有网格将使用同一种渲染状态，所以看起来不同网格外观像是使用了同一种材质。 2.2.3 调用Draw Call​ Draw Call是一个命令，由CPU发起，由GPU接收。 ​ 当给定一个Draw Call时，GPU会根据 渲染状态 和 所有顶点数据 来进行计算，最终输出到屏幕显示出像素。 2.3 GPU流水线2.3.1 概述​ 概念阶段中，几何阶段和光栅化阶段，开发者的控制权限有限。这两个阶段又可分为更小的流水线阶段，由GPU来实现这些流水阶段，每个阶段GPU提供了不同的 可配置性 或 可编程性。 几何阶段： 输入：顶点数据，由应用阶段加载到显存中，再由Draw Call指定。 顶点着色器（Vertex Shader)：完全可编程，常用于顶点空间变换，顶点着色。 曲面细分着色器（Tessellation Shader）：可选着色器，用于细分图元。 几何着色器（Geometry Shader）：可选着色器，用于执行逐图元着色操作，或产生更多图元。 裁剪（Clipping）：可配置，将不再摄像机视野内的顶点裁剪掉，剔除某些三角图元的面片。 屏幕映射（Screen Mapping）：不可配置不可编程，负责将图元的坐标转换到屏幕坐标系中。 光栅化阶段： 三角形设置（Triangle Setup）：固定函数阶段 三角形遍历（Triangle Traversal）：固定函数阶段 片元着色器（Fragment Shader）：完全可编程，用于实现逐片元的着色操作。 逐片元操作（Per-Fragment Operations）：不可编程，但有很高可配性，可以执行很多重要操作，如：修改颜色，深度缓冲，进行混合等。 2.3.2 顶点着色器​ 处理单位：顶点着色器是流水线的第一阶段，输入来自CUP。处理单位是顶点，输入的每个顶点都会调用一次顶点着色器。 ​ 速度快：顶点着色器本身不会创建或销毁任何顶点，也无法知道顶点与顶点之间的关系（也就是说我们无法知道两个顶点是否属于同一个三角网格）。也正因为这种相互独立性，GPU可以利用本身的特性并行化处理每个顶点，这样这一阶段处理速度会很快。 ​ 主要工作：坐标变换、逐顶底光照 坐标变换：对顶点的坐标进行某种变换。顶点着色器可在这一步改变顶点的位置，这样可以实现一些我们需要的效果，如模拟水面，布料等。 顶点着色器必须完成的工作：把顶点坐标从模拟空间转换到齐次裁剪空间。 2.3.3 裁剪​ 我们的场景可能非常大，但是摄像机视野是有限的，场景中不在我们视野中的物体完全没必要渲染，裁剪就是为了这个目的被提出来的。 ​ 一个图元跟摄像机视野的关系： 完全在视野内：图元继续传到下一阶段 部分在视野内：进行裁剪，保留在视野内部分，裁剪掉视野外部分。 完全在视野外：不会继续向下传递，因为不需要被渲染 这个阶段不可编程，无法通过程序来控制裁剪的过程，而是硬件固定操作。但我们可以自定义应该裁剪操作来对这一步进行配置。 2.3.4 屏幕映射​ 这一阶段的输入坐标仍然是三维坐标。 ​ 任务：把每个图元的x和y坐标转换到屏幕坐标系下，屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。 ​ 屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远。 ​ 注意：屏幕坐标系在OpenGL和DirectX之间存在差异 OpenGL把屏幕左下角作为坐标原点(0, 0) DirectX把屏幕左上角作为坐标原点(0, 0) 2.3.5 三角形设置​ 从这开始，进入光栅化阶段。上阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的额外信息（如：深度值，法线方向，视角方向等） ​ 光栅化重要目标： 计算每个图元覆盖了哪些像素 为这些像素计算它们的颜色 ​ 三角形设置 是光栅化流水线的一个个阶段。这一阶段会计算光栅化一个三角网格所需的信息。 ​ 上一阶段输出的都是三角网格的顶点，我们得到的是三角网格每条边的两个端点。想要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。 ​ 为了计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式，这样一个计算三角网格表示数据的过程就叫三角形设置。 2.3.6 三角形遍历​ 此阶段会检查每个像素是否被一个三角网格覆盖，如果被覆盖，会生成一个片元。 ​ 找哪些像素被三角网格覆盖的过程就是 三角形遍历 ，也称为 扫描变换。 ​ 三角形遍历阶段会根据上一阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。 ​ 此阶段输出的是一个片元序列，需要注意的是，一个片云不是真正意义上的像素，而是包含了多种状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括但不限于屏幕坐标，深度信息等，以及其他几何阶段输出的顶点信息，如法线、纹理坐标等。 2.3.7 片元着色器​ 片元着色器是非常重要的可编程着色器阶段。 ​ 前面的光栅化阶段实际不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎么覆盖每个像素的。每个片元就负责存储这样一系列数据。真正对像素产生影响的阶段是——逐片元操作。 ​ 输入：上阶段对顶点信息插值得到的结果 ​ 输出： 一个或多个颜色值 ​ 这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是 纹理采样 ，为了在片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值，就可以得到其覆盖的片元纹理坐标了。 ​ 局限性：仅可以影响单个片元，执行片元着色器时，它不可以将自己的任何结果发送给它的邻居。 2.3.8 逐片元操作此阶段高度可配置性，我们可以设置每一步的操作细节。 渲染流水线最后阶段，在OpenGL中和DirectX中有不同叫法： OpenGL中：逐片元操作 DirectX中：输出合并阶段 主要任务： 决定每个片元的可见性，涉及很多测试工作，如深度测试，模板测试等。 如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说混合。 下面是逐片元操作所做的操作： 下面是模板测试和深度测试的简化流程图： 模板测试 如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取到的参考值进行比较，比较函数可以由开发者指定。如果一个片元没有通过测试，该片元将会被舍弃。不管一个片元有没有通过模板测试，我们都可以根据模板测试和深度测试结果来修改模板缓冲区。 深度测试 通过了模板检测的片元，会进行下一个测试——深度测试。 如果开启了深度测试，GPU会把该片元的深度和已经存在于深度缓冲区中的深度进行比较。这个比较函数也可以由开发者设置。 和模板测试测试不同，一个片元如果没有通过深度测试，它没有权利更改深度缓冲区中的值。 混合 对于不透明物体，开发者可以关闭混合操作，这样片元着色器计算得到的颜色就会直接覆盖颜色缓冲区中的像素值 对于半透明物体，我们就需要使用混合操作来让这个物体看起来是透明的。 ​ 当模型的图元经过上面层层计算和测试后，就会显示到我们的屏幕上，我们的屏幕显示的是颜色缓冲区中的颜色值。但是为了避免我们看到那些正在进行光栅化的图元，GUP会使用双重缓冲（Double Buffering）的策略。这意味着，对场景的渲染是在幕后发生的，即在后置缓冲区中。一旦场景已经被渲染到后置缓冲中，GUP会交换后置缓冲区和前置缓冲区中的内容，而前置缓冲区是之前显示在屏幕上的图像，由此保证我们看到的画面是连续的。 2.4 容易困惑的地方2.4.1 什么是OpenGL/DirextXOpenGL/DirextX是图像应用编程接口，这些接口用于渲染二维或三维图形。可以说这些接口架起了上层应用程序和底层GPU的沟通桥梁。一个应用程序向这些接口发送渲染命令，而这些接口会依次向显卡驱动发送渲染命令，【显卡驱动】是真正知道如何跟GPU通信的角色，它们负责将OpenGL/DirextX的函数翻译成GPU能听懂的语言，同时它们也负责把纹理等数据转换成GPU所支持的格式。 2.4.2 什么是HLSL、GLSL、CG都是着色语言（Shading Language） HLSL：(Hight Level Shading Language)，DirectX GLSL：(OpenGL Shading Language)，OpenGL CG：(C for Graphic)， NVIDIA 2.4.3 什么是Draw Call​ Draw Call就是CPU调用图像编程接口， 以命令GPU进行渲染的操作。 ​ Draw Call造成性能问题的元凶是CPU而非GPU。 问题一：GPU 和CPU如何并行工作 ​ 为了提高效率，CPU和GPU需要并行工作，实现方式：使用命令缓冲区（Command Buffer） ​ 命令缓冲区包含一个命令队列，由CPU向其中添加命令，GPU负责读取命令，添加跟读取过程都是相互独立的，这样就实现了并行工作。 ​ 命令缓冲区的命令很多种，Draw Call是其中一种，其他命令还有改变渲染状态等（例如改变使用的着色器，使用不同纹理等）。 往往改变渲染状态命令更加耗时。 ​ 问题二. 为什么Draw Call多了会影响帧率 ​ 每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据，状态和命令等。这一阶段CPU需要完成很多工作，例如检查渲染状态等。一旦CPU完成了这些准备工作，CPU就可以开始本次的渲染。 ​ GPU渲染能力很强，速度往往快于CPU提交命令的速度，如果Draw Call数量太多，CPU就会把大量时间花费在提交Draw Clall上，造成CPU过载。 ​ 问题三. 如何减少Draw Call ​ 可以使用批处理（bathching）方法，把小的DrawCall合并成一个大的DrawCall ​ 游戏开发过程中，为减少Draw Call的开销，需注意： 避免使用大量的很小的网格，当不可避免地使用很小的网格结构时，考虑是否可以合并它们。 避免使用过多的材质。尽量在不同网格之间共用同一个材质。","categories":[{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/categories/Shader/"}],"tags":[],"keywords":[{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/categories/Shader/"}]},{"title":"vscode插件开发","slug":"vscode插件/vscode插件开发","date":"2020-08-14T08:19:45.000Z","updated":"2020-09-14T03:01:41.799Z","comments":false,"path":"2020/08/14/vscode插件/vscode插件开发/","link":"","permalink":"http://yoursite.com/2020/08/14/vscode%E6%8F%92%E4%BB%B6/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","excerpt":"","text":"项目创建1. 安装脚手架1npm install -g yo generator-code cd 到项目目录，运行 1yo code 2. 运行看效果构建完成后，直接用vscode打开项目，按F5运行项目，此时会弹出一个新的vscode窗口（类似我们写html后，会运行浏览器来看效果，新打开的vscode窗口就起到浏览器相同的作用）。 同时按下ctrl+shift+p，在输入框中输入Hello Word，即可在右下角看到插件运行的消息 3. 项目结构主要配置文件：extension.ts 和 package.json package.json关键内容如下： 1234567891011121314151617181920212223\"name\": \"vscode-plugin-bear\",\"displayName\": \"vscode-plugin-bear\",\"description\": \"My VSCode plugin\",\"version\": \"0.0.1\",\"publisher\": \"bear\",\"engines\": &#123; \"vscode\": \"^1.27.0\"&#125;,\"categories\": [ \"Other\"],\"activationEvents\": [ \"onCommand:extension.helloWorld\"],\"main\": \"./out/extension.js\",\"contributes\": &#123; \"commands\": [ &#123; \"command\": \"extension.helloWorld\", \"title\": \"Hello World\" &#125; ]&#125; 关键说明： name 和 publisher：VS Code使用\\.\\作为插件的唯一ID，例如我这里会以bear.vscode-plugin-bear作为唯一ID。 displayName：插件展示名称 description：插件自我描述 version：版本号 engines：使用此插件的VS Code最低版本要求 categories：插件分类，可选值[Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs] activationEvents：拓展可被激活的事件数组 main：入口文件 activationEvents 貌似有博主描述的更全面，这里拿来用用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195&#123; // 插件的名字，应全部小写，不能有空格 \"name\": \"vscode-plugin-demo\", // 插件的友好显示名称，用于显示在应用市场，支持中文 \"displayName\": \"VSCode插件demo\", // 描述 \"description\": \"VSCode插件demo集锦\", // 关键字，用于应用市场搜索 \"keywords\": [\"vscode\", \"plugin\", \"demo\"], // 版本号 \"version\": \"1.0.0\", // 发布者，如果要发布到应用市场的话，这个名字必须与发布者一致 \"publisher\": \"sxei\", // 表示插件最低支持的vscode版本 \"engines\": &#123; \"vscode\": \"^1.27.0\" &#125;, // 插件应用市场分类，可选值： [Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs] \"categories\": [ \"Other\" ], // 插件图标，至少128x128像素 \"icon\": \"images/icon.png\", // 扩展的激活事件数组，可以被哪些事件激活扩展，后文有详细介绍 \"activationEvents\": [ \"onCommand:extension.sayHello\" ], // 插件的主入口 \"main\": \"./src/extension\", // 贡献点，整个插件最重要最多的配置项 \"contributes\": &#123; // 插件配置项 \"configuration\": &#123; \"type\": \"object\", // 配置项标题，会显示在vscode的设置页 \"title\": \"vscode-plugin-demo\", \"properties\": &#123; // 这里我随便写了2个设置，配置你的昵称 \"vscodePluginDemo.yourName\": &#123; \"type\": \"string\", \"default\": \"guest\", \"description\": \"你的名字\" &#125;, // 是否在启动时显示提示 \"vscodePluginDemo.showTip\": &#123; \"type\": \"boolean\", \"default\": true, \"description\": \"是否在每次启动时显示欢迎提示！\" &#125; &#125; &#125;, // 命令 \"commands\": [ &#123; \"command\": \"extension.sayHello\", \"title\": \"Hello World\" &#125; ], // 快捷键绑定 \"keybindings\": [ &#123; \"command\": \"extension.sayHello\", \"key\": \"ctrl+f10\", \"mac\": \"cmd+f10\", \"when\": \"editorTextFocus\" &#125; ], // 菜单 \"menus\": &#123; // 编辑器右键菜单 \"editor/context\": [ &#123; // 表示只有编辑器具有焦点时才会在菜单中出现 \"when\": \"editorFocus\", \"command\": \"extension.sayHello\", // navigation是一个永远置顶的分组，后面的@6是人工进行组内排序 \"group\": \"navigation@6\" &#125;, &#123; \"when\": \"editorFocus\", \"command\": \"extension.demo.getCurrentFilePath\", \"group\": \"navigation@5\" &#125;, &#123; // 只有编辑器具有焦点，并且打开的是JS文件才会出现 \"when\": \"editorFocus &amp;&amp; resourceLangId == javascript\", \"command\": \"extension.demo.testMenuShow\", \"group\": \"z_commands\" &#125;, &#123; \"command\": \"extension.demo.openWebview\", \"group\": \"navigation\" &#125; ], // 编辑器右上角图标，不配置图片就显示文字 \"editor/title\": [ &#123; \"when\": \"editorFocus &amp;&amp; resourceLangId == javascript\", \"command\": \"extension.demo.testMenuShow\", \"group\": \"navigation\" &#125; ], // 编辑器标题右键菜单 \"editor/title/context\": [ &#123; \"when\": \"resourceLangId == javascript\", \"command\": \"extension.demo.testMenuShow\", \"group\": \"navigation\" &#125; ], // 资源管理器右键菜单 \"explorer/context\": [ &#123; \"command\": \"extension.demo.getCurrentFilePath\", \"group\": \"navigation\" &#125;, &#123; \"command\": \"extension.demo.openWebview\", \"group\": \"navigation\" &#125; ] &#125;, // 代码片段 \"snippets\": [ &#123; \"language\": \"javascript\", \"path\": \"./snippets/javascript.json\" &#125;, &#123; \"language\": \"html\", \"path\": \"./snippets/html.json\" &#125; ], // 自定义新的activitybar图标，也就是左侧侧边栏大的图标 \"viewsContainers\": &#123; \"activitybar\": [ &#123; \"id\": \"beautifulGirl\", \"title\": \"美女\", \"icon\": \"images/beautifulGirl.svg\" &#125; ] &#125;, // 自定义侧边栏内view的实现 \"views\": &#123; // 和 viewsContainers 的id对应 \"beautifulGirl\": [ &#123; \"id\": \"beautifulGirl1\", \"name\": \"国内美女\" &#125;, &#123; \"id\": \"beautifulGirl2\", \"name\": \"国外美女\" &#125;, &#123; \"id\": \"beautifulGirl3\", \"name\": \"人妖\" &#125; ] &#125;, // 图标主题 \"iconThemes\": [ &#123; \"id\": \"testIconTheme\", \"label\": \"测试图标主题\", \"path\": \"./theme/icon-theme.json\" &#125; ] &#125;, // 同 npm scripts \"scripts\": &#123; \"postinstall\": \"node ./node_modules/vscode/bin/install\", \"test\": \"node ./node_modules/vscode/bin/test\" &#125;, // 开发依赖 \"devDependencies\": &#123; \"typescript\": \"^2.6.1\", \"vscode\": \"^1.1.6\", \"eslint\": \"^4.11.0\", \"@types/node\": \"^7.0.43\", \"@types/mocha\": \"^2.2.42\" &#125;, // 后面这几个应该不用介绍了 \"license\": \"SEE LICENSE IN LICENSE.txt\", \"bugs\": &#123; \"url\": \"https://github.com/sxei/vscode-plugin-demo/issues\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/sxei/vscode-plugin-demo\" &#125;, // 主页 \"homepage\": \"https://github.com/sxei/vscode-plugin-demo/blob/master/README.md\"&#125; 命令前面项目构建完成后运行看效果实际上完成了三件事： 注册onCommand的激活事件：onCommand:extension.helloWorld，所以插件会在运行Hello World命令的时候被激活。 在contributes.commands配置 Hello World命令，并绑定到extension.helloWorld上 使用VSCode API commands.registerCommand绑定方法到已经注册的命令IDextension.helloWorld上 创建命令在extension.ts中，添加以下代码： 123context.subscriptions.push(vscode.commands.registerCommand('extension.sayHello', () =&gt; &#123; vscode.window.showInformationMessage('您执行了extension.sayHello命令！');&#125;)); 然后在package.json清单位置，添加声明 123456\"commands\": [ &#123; \"command\": \"extension.sayHello\", \"title\": \"Hello World\" &#125;,] 说明：vscode.commands.registerCommand是注册命令的API，返回Disposable，最后将结果放到context.subscriptions中 回调函数参数 注册命令回调函数可接受uri参数 注册资源管理器右键命令时，会把选中的资源路径uri传到回调函数中； 在编辑器打开文件中右键，则会将当前文件路径回调回去； 使用ctrl+shift+p执行命令时，则uir为空； 在extension.ts中添加： 123context.subscriptions.push(vscode.commands.registerCommand('extension.showMyPath', (uri)=&gt;&#123; vscode.window.showInformationMessage(`当前文件路径：$&#123;uri ? uri.path : 'kk'&#125;`); &#125;)); package.json添加： 123456789101112131415\"menus\": &#123; \"editor/context\": [ &#123; \"when\": \"editorFocus\", \"command\": \"extension.showMyPath\", \"group\": \"navigation\" &#125; ], \"explorer/context\": [ &#123; \"command\": \"extension.showMyPath\", \"group\": \"navigation\" &#125; ]&#125; 创建菜单一个菜单项创建如下： 12345678910\"contributes\": &#123; \"menus\": &#123; \"editor/title\": [&#123; \"when\": \"resourceLangId == markdown\", \"command\": \"markdown.showPreview\", \"alt\": \"markdown.showPreviewToSide\", \"group\": \"navigation\" &#125;] &#125;&#125; editor/title是key值，定义这个菜单出现在哪里； when控制菜单合适出现； command定义菜单被点击后要执行什么操作； alt定义备用命令，按住alt键打开菜单时将执行对应命令； group定义菜单分组； 插件位置选择 资源管理器上下文菜单 - explorer/context 编辑器上下文菜单 - editor/context 编辑标题菜单栏 - editor/title 编辑器标题上下文菜单 - editor/title/context 调试callstack视图上下文菜单 - debug/callstack/context SCM标题菜单 -scm/title SCM资源组菜单 -scm/resourceGroup/context SCM资源菜单 -scm/resource/context SCM更改标题菜单 -scm/change/title 左侧视图标题菜单 -view/title 视图项菜单 -view/item/context 控制命令是否显示在命令选项板中 - commandPalette 图标在commands里面配置，light和dark分别对应浅色和深色主题，如果不配置图标则直接显示文字： 12345678910\"commands\": [ &#123; \"command\": \"extension.demo.testMenuShow\", \"title\": \"这个菜单仅在JS文件中出现\", \"icon\": &#123; \"light\": \"./images/tool-light.svg\", \"dark\": \"./images/tool-light.svg\" &#125; &#125;] 时机when通过可选的when语句，VS Code可以很好地控制什么时候显示菜单项，当然，when语句语法不仅仅适用于菜单项的控制。 when语句语法有很多，这里列举几个常用的： resourceLangId == javascript：当编辑的文件是js文件时； resourceFilename == test.js：当当前打开文件名是test.js时； isLinux、isMac、isWindows：判断当前操作系统； editorFocus：编辑器具有焦点时； editorHasSelection：编辑器中有文本被选中时； view == someViewId：当当前视图ID等于someViewId时； 等等等 多个条件可以通过与或非进行组合，例如：editorFocus &amp;&amp; isWindows &amp;&amp; resourceLangId == javascript。 有关when语句的更多完整语法请参考官方文档：https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts altalt很好理解，表示没有按下alt键时，点击右键菜单执行的是command对应的命令，而按下了alt键后执行的是alt对应的命令。这里不做过多解释。 group组间排序控制菜单的分组和排序。不同的菜单拥有不同的默认分组 editor/context中有这些默认组： navigation- 放在这个组的永远排在最前面； 1_modification - 更改组； 9_cutcopypaste - 编辑组 z_commands - 最后一个默认组，其中包含用于打开命令选项板的条目。 除了navigation是强制放在最前面之外，其它分组都是按照0-9、a-z的顺序排列的，所以如果你想在1_modification和9_cutcopypaste插入一个新的组别的话，你可以定义一个诸如6_test： explorer/context有这些默认组： navigation - 放在这个组的永远排在最前面； 2_workspace - 与工作空间操作相关的命令。 3_compare - 与差异编辑器中的文件比较相关的命令。 4_search - 与在搜索视图中搜索相关的命令。 5_cutcopypaste - 与剪切，复制和粘贴文件相关的命令。 7_modification - 与修改文件相关的命令。 在编辑器选项卡上下文菜单有这些默认组： 1_close - 与关闭编辑器相关的命令。 3_preview - 与固定编辑器相关的命令。 在editor/title有这些默认组： 1_diff - 与使用差异编辑器相关的命令。 3_open - 与打开编辑器相关的命令。 5_close - 与关闭编辑器相关的命令。 组内排序默认同一个组的顺序取决于菜单名称，如果想自定义排序的话可以再组后面通过@&lt;number&gt;的方式来自定义顺序，例如： 1234567891011121314\"editor/context\": [ &#123; \"when\": \"editorFocus\", \"command\": \"extension.sayHello\", // 强制放在navigation组的第2个 \"group\": \"navigation@2\" &#125;, &#123; \"when\": \"editorFocus\", \"command\": \"extension.demo.getCurrentFilePath\", // 强制放在navigation组的第1个 \"group\": \"navigation@1\" &#125;] 快捷键123456789101112\"contributes\": &#123; \"keybindings\": [&#123; // 指定快捷键执行的操作 \"command\": \"extension.sayHello\", // windows下快捷键 \"key\": \"ctrl+f10\", // mac下快捷键 \"mac\": \"cmd+f10\", // 快捷键何时生效 \"when\": \"editorTextFocus\" &#125;]&#125; 如果您想了解更多有关快捷键绑定的详细细节可以继续阅读官方文档：https://code.visualstudio.com/docs/getstarted/keybindings 打包发布本地打包打包需要借助vsce工具，先安装： 1npm i vsce -g cd到项目根目录，运行打包命令： 1vsce package 生成的vsix，可在vscode插件窗口，右上角选择Install from VSIX安装 发布到应用市场 注册Miscrosoft账户，已经有账户的直接进入下一步 注册地址：https://login.live.com/ 访问https://aka.ms/SignupAzureDevOps，没使用过会出现如下提示框，直接点继续 创建令牌 进入组织主页后，点击右上角，选择Personal access tokens 选择New Token，会出现下面界面，Organization要选择all accessible organizations，Scopes要选择Full access，否则后面发布会失败。 随后就会生成一个令牌，此时必须拷贝保存起来，要是忘了就找不回来了。 创建发布账户 获得令牌后，接下来创建发布者 1vsce create-publisher your-publisher-name 此处your-publisher-name需要以字母数字下划线组成，然后依次输入昵称，邮箱，和刚才生成的令牌。 123456E:\\Projects\\vscode_extension\\plugin-bear (master) (bear@0.0.1)λ vsce create-publisher lgx123Publisher human-friendly name: (lgx123) 呵呵到天亮E-mail: 1134569285@qq.comPersonal Access Token: **************************************************** DONE Created publisher 'lgx123'. 创建成功后，默认会登陆这个账户，假如已经创建过账户了，可以直接登陆： 1vsce login your-publisher-name 也可以用网页版来创建发布账户：https://marketplace.visualstudio.com/manage 发布 上面登陆好发布者账户后，直接可以运行发布命令： 1vsce publish 成功结果： 123456789101112131415vsce publishExecuting prepublish script 'npm run vscode:prepublish'...&gt; bear@0.0.1 vscode:prepublish E:\\Projects\\vscode_extension\\plugin-bear&gt; npm run compile&gt; bear@0.0.1 compile E:\\Projects\\vscode_extension\\plugin-bear&gt; tsc -p ./Personal Access Token for publisher 'lgx': ****************************************************Publishing lgx.bear@0.0.1... DONE Published lgx.bear@0.0.1Your extension will live at https://marketplace.visualstudio.com/items?itemName=lgx.bear (might take a few minutes for it to show up). 发布成功稍等几分钟即可在应用市场搜到，也可在vscode网页应用市场搜到 https://marketplace.visualstudio.com/items?itemName=lgx.bear 发布注意事项 README.md文件默认会显示在插件主页； README.md中的资源必须全部是HTTPS的，如果是HTTP会发布失败； CHANGELOG.md会显示在变更选项卡； 如果代码是放在git仓库并且设置了repository字段，发布前必须先提交git，否则会提示Git working directory not clean； 增量发布 版本号：major.minor.patch 如果想让发布之后版本号的patch自增，例如：1.0.2 -&gt; 1.0.3，可以这样： 1vsce publish patch 结果： 1234567891011121314vsce publish patchv0.0.2Executing prepublish script 'npm run vscode:prepublish'...&gt; bear@0.0.2 vscode:prepublish E:\\Projects\\vscode_extension\\plugin-bear&gt; npm run compile&gt; bear@0.0.2 compile E:\\Projects\\vscode_extension\\plugin-bear&gt; tsc -p ./Publishing lgx.bear@0.0.2... DONE Published lgx.bear@0.0.2Your extension will live at https://marketplace.visualstudio.com/items?itemName=lgx.bear (might take a few minutes for it to show up). 执行这个命令后会自动修改package.json里面的版本号。同理，vsce publish minor也是可以的。 取消发布 1vsce unpublish (publisher name).(extension name) 更新 如果修改了插件代码想要重新发布，只需要修改版本号然后重新执行vsce publish即可 vsce 其他命令 12345678910111213141516171819202122 # vsce --help Usage: vsce [options] [command] Options: -V, --version output the version number -h, --help output usage information Commands: ls [options] 列出实际会发布的文件列表 package [options] 打包成一个插件 publish [options] [&lt;version&gt;] 发布插件 unpublish [options] [&lt;extensionid&gt;] 插件下架 list &lt;publisher&gt; 列出某个发布者下所有发布的,需要配置好token 额,不然会提示输入 ls-publishers 列出所有已知的发布者 create-publisher &lt;publisher&gt; 创建一个新的发布者 delete-publisher &lt;publisher&gt; 删除一个发布者 login &lt;publisher&gt; 登录一个发布者到发布者列表中 logout &lt;publisher&gt; 反之,退出发布者 本文大部分内容出自http://blog.haoji.me/?tag=vscode","categories":[],"tags":[],"keywords":[]},{"title":"Unity 3D使用protobuf 导excel表格数据","slug":"unity/Unity3D使用protobuf导excel表格数据","date":"2020-08-08T08:38:22.000Z","updated":"2020-09-14T03:01:41.797Z","comments":false,"path":"2020/08/08/unity/Unity3D使用protobuf导excel表格数据/","link":"","permalink":"http://yoursite.com/2020/08/08/unity/Unity3D%E4%BD%BF%E7%94%A8protobuf%E5%AF%BCexcel%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1.资源下载protobuf-2.5.0.zip protoc-2.5.0-win32.zip","categories":[{"name":"Unity 3D","slug":"Unity-3D","permalink":"http://yoursite.com/categories/Unity-3D/"}],"tags":[],"keywords":[{"name":"Unity 3D","slug":"Unity-3D","permalink":"http://yoursite.com/categories/Unity-3D/"}]},{"title":"Unity接入tolua框架","slug":"unity/Unity接入tolua框架","date":"2020-08-03T10:49:10.000Z","updated":"2020-09-14T03:01:41.798Z","comments":false,"path":"2020/08/03/unity/Unity接入tolua框架/","link":"","permalink":"http://yoursite.com/2020/08/03/unity/Unity%E6%8E%A5%E5%85%A5tolua%E6%A1%86%E6%9E%B6/","excerpt":"","text":"这里我们不使用tolua框架本身的项目，而是在我们已有的工程项目中接入tolua热更框架。 引入tolua 下载tolua资源 在引入tolua到我们的项目之前，需要下载tolua的资源包：tolua资源包 资源引入项目中 上面下载完tolua资源后，我们得到 tolua-master.zip 一个，解压后即可看到这样的内容： 12345678910├─Assets│ ├─Editor│ ├─Lua│ ├─Plugins│ ├─Source│ └─ToLua├─Luajit├─Luajit64├─ProjectSettings└─Unity5.x 我们需要的只是Assets中的文件，将Assets文件夹中所有文件都复制到我们项目的Assets目录中。 生成常用类型注册文件 将上面文件复制到我们项目对应目录后，在Uinty窗口会弹出这样一个窗口，点确定即可： 起点在刚引入到项目中的Tolua\\Msic中，有一个LuaClient.cs文件，这是tolua为我们封装好的启动接口，可以继承这个类来编写我们自己的tolua管理器，这里我们建立一个LuaMgr.cs，继承自LuaClient，并重写两个接口：InitLoader和LoadLuaFiles 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using LuaInterface;using UnityEngine;public class LuaMgr : LuaClient&#123; protected override LuaFileUtils InitLoader() &#123; return new LuaResLoader(); &#125; protected override void LoadLuaFiles() &#123;#if UNITY_EDITOR // 添加编辑器环境下获取 lua 脚本的路径（Assets/lua） luaState.AddSearchPath(Application.dataPath + \"/lua\");#endif OnLoadFinished(); &#125;&#125; 在游戏控制中心脚本GameMgr的Awake方法中，启动lua管理器 12345678910111213141516171819202122232425262728293031323334353637using System.Collections;using System.Collections.Generic;using UnityEngine;public class GameMgr : MonoBehaviour&#123; private static GameMgr _instance; private LuaMgr _luaMgr = null; public static GameMgr Instance&#123; get&#123; return _instance; &#125; &#125; void Awake()&#123; _instance = this; transform.name = \"GameMgr\"; GameObject.DontDestroyOnLoad(gameObject); StartCoroutine(Init()); &#125; IEnumerator Init()&#123; Screen.sleepTimeout = SleepTimeout.NeverSleep; //阻止息屏 Debug.Log(\"-- GameMgr Start\"); _luaMgr = gameObject.AddComponent&lt;LuaMgr&gt;(); yield return 0 ; &#125; void Start() &#123; &#125; void Update() &#123; &#125;&#125; 启动我们的游戏，此时可以看到打印出这样的信息： 1217:32:10.921-0: LuaState startUnityEngine.Debug:Log(Object) 这是在lua中打印出来的日志，具体位置：Assets/Lua/Main.lua 12345678910111213--主入口函数。从这里开始lua逻辑function Main() print(\"logic start\") end--场景切换通知function OnLevelWasLoaded(level) collectgarbage(\"collect\") Time.timeSinceLevelLoad = 0endfunction OnApplicationQuit()end 至此，tolua框架算是引入成功了。 目录结构整理导入tolua资源后，Assets目录结构不一定符合我们的要求，需要根据需要进行调整，tolua框架也支持我们这么做。 修改Generate目录 Assets/Source/Generate目录用来保存tolua生成的可供lua调用的C#类的绑定类，我们项目希望将其放在Assets/Code/Module/Lua目录下，修改只需要打开Assets/Editor/Custom/CustomSettings.cs 1public static string saveDir = Application.dataPath + \"/Source/Generate/\"; 修改为： 1public static string saveDir = Application.dataPath + \"/Code/Module/Lua/Generate/\"; 然后将Assets/Source/LuaConst.cs移动到Assets/Code/Module/Lua中，并在此目录中创一个Generate目录，然后将鼠标焦点移到Unity编辑器，又会弹出之前的“点击确定自动生成常用类型注册文件，也可通过菜单逐步完成此功能”窗口，依旧点确定即可 然后就可以在Assets/Code/Module/Lua/Generate/目录中看到一堆*wrap.cs文件，还能在unity编辑器中看到一堆报错~~~，这是因为我们自己生成了一份wrap.cs文件，跟原来的那堆文件重名了，只需要把Source目录删除即可，这样就成功修改了存放wrap.cs文件的目录。 修改Tolua目录 Assets/Tolua目录是tolua框架的核心库存放的地方，但是我们习惯将第三方插件存放在项目的Assets/ThirdParty目录下，这里我们直接将Tolua目录挪到Assets/ThirdParty目录下，然后修改以下配置： LuaConst.cs 中的 toluaDir ： 1public static string toluaDir = Application.dataPath + \"/ThirdParty/ToLua/Lua\"; //tolua lua文件目录 CustomSettings.cs 中的 toluaBaseType ： 1public static string toluaBaseType = Application.dataPath + \"/ThirdParty/ToLua/BaseType/\"; 修改入口文件main.lua的位置 我们希望将lua的入口文件放置到Assets/Code/Lua目录下，只需要将Assets/Lua整个目录移动到Assets/Code下，然后修改LuaConst.cs文件： 1public static string luaDir = Application.dataPath + \"/Code/Lua\"; //lua逻辑代码目录 Done","categories":[],"tags":[{"name":"Unity 3D","slug":"Unity-3D","permalink":"http://yoursite.com/tags/Unity-3D/"}],"keywords":[]},{"title":"C语言","slug":"C/C语言","date":"2020-08-02T03:19:40.000Z","updated":"2020-09-14T03:01:41.793Z","comments":false,"path":"2020/08/02/C/C语言/","link":"","permalink":"http://yoursite.com/2020/08/02/C/C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"一. 第一段C123456#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\"); return 0;&#125; 解析： include : 引入头文件 所有程序从main函数开始执行。 printf：格式化输出到屏幕，依赖stdio.h头文件。 stdio.h ：标准输入输出头文件，使用printf()函数时，没提前引入此头文件会编译出错 return 0：退出程序。 二. 数据类型 基本类型：算术类型，包括 整数类型 浮点类型 枚举类型 也是算术类型，用来定义在程序中只能赋予一定的离散整数值的变量 void类型 类型说明符void说明没有可用的值。 派生类型 指针类型 数组类型 结构类型：数组类型和结构类型统称为聚合类型 共用体类型 函数类型：指的是函数返回值的类型 1. 整数类型标准整数类型的的存储大小和值范围 类型 存储大小(字节) 值范围 char 1 -128到127或0到255 unsigned char 1 0到255 signed char 1 -128到127 int 2或4 -32768到32767或-2147483648到2147483647 unsigned int 2或4 0到65535或0到4294967295 short 2 -32768到32767 unsigned 2 0到65535 long 4 -2147483648到2147483647 unsigned 4 0到4294967295 各种数据类型存储大小和系统位数有关，需要得到该类型在当前系统上的大小，可以使用sizeof运算符 12345#include &lt;stdio.h&gt;int main()&#123; printf(\"int 的大小：%lu \\n\", sizeof(int)); return 0;&#125; 结果： 1int 存储大小 : 4 2. 浮点型标准浮点型的存储大小，值范围，精度： 类型 存储大小（字节） 值范围 精度 float 4 1.2E-38 到 3.4E+38 6 位小数 double 8 2.3E-308 到 1.7E+308 15位小数 long double 16 3.4E-4932 到 1.1E+4932 19 位小数 在程序中可以这样获得以上这些值： 123456789#include &lt;stdio.h&gt;#include &lt;float.h&gt;int main()&#123; printf(\"float 存储大小：%lu \\n\", sizeof(float)); printf(\"float 最小值：%E \\n\", FLT_MIN); printf(\"float 最大值：%E \\n\", FLT_MAX); printf(\"float 精度：%d\\n\", FLT_DIG); return 0;&#125; ps：%E是以指数形式输出单，双精度实数 三. 变量变量其实只是程序可操作的存储区的名称。C语言中，每个变量都有类型，类型决定变量存储的大小。 变量命名必须以字母或下划线开头，后面可以跟着数字，字母和下划线，并且字母区分大小写。 1. 变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。定义的时候需指定变量的数据类型，并包含一个或多个变量列表。 以下为变量的声明： 1234int a, b, c;char d;float e, f;double g; 写多个变量名表示同事创建多个变量。 变量的初始化： 123int a = 1;int a = 1, b = 2;char b = 'a'; 2. 变量的声明变量的声明向编译器保证变量以指定的类型和名称存在，变量的声明有两种情况： 需要建立存储空间。 例如：int a在声明的时候就建立了存储空间。 不需要建立存储空间。 通过extern关键字声明的变量名而不定义他，如：extern int a，a变量可以不在这定义，而是在其他文件进行定义 除有extern关键字的，都是变量的定义。 12extern int a; //变量的声明int a; //变量的声明，也是变量的定义 3. 左值(Lvalues)和右值(Rvalues)C中有两种类型的表达式： 左值 指向内存位置的表达式称为左值表达式，左值表达式可出现在“=”左边或右边。 右值 右值指的是存储在内存中某些地址的数值。右值不能进行赋值，也就是说右值不能出现在“=”左边，只能存在右边。 12int a = 1; //a为左值，指向数字1在内存中所在的地址，故a可在等号左边和右边int b = a； 11 = 2; // 数值型为右值型，只能在等号右边，所以这样写会报错。 四. 常量常量是固定值，在程序执行过程不会改变，这些固定的值也叫字面量。常量的值在定义后不能进行修改。 常量可以是任何基本数据类型，如字符常量，整数常量等。 1. 整数常量 带前缀整数常量可以是： 十进制：不带前缀 八进制：0为前缀 十六进制：0x或0X为前缀 带后缀整数常量(后缀可大写可小写)： 后缀 U (或u)：无符号整数(unsigned) 后缀 L (或l)：长整数(long) UL或LU：无符号长整型 实例： 12345678 //十进制0123 //八进制0x4b //十六进制3 //整数3u //无符号整数3l //长整数3ul //无符号长整数 2. 浮点常量浮点数由整数部分、小数点、小数部分、指数部分组成。浮点常量表现形式： 小数形式：必须包含整数部分、小数部分，或两者都有 指数形式：必须包含小数点、指数，或两者都有 3. 字符常量字符常量是在单引号中，可以是以下类型： 普通字符：例如’x’ 转义序列：例如:’\\t’ 通用字符：例如’\\u02C0’ 4. 字符串常量跟字符常量类似，但字符串常量括在双引号中”” 5. 定义常量在C中，有两种方式定义常用： 使用#define预处理器 1#define LENGTH 10 使用const关键字 1const int LENGTH = 10; 注意：通常把常量定义为大写字母形式 五. 存储类C程序中，存储类定义程序中变量、函数的范围（可见性）和生命周期，这些说明符房子啊他们所修饰的类型之前。下面是C程序中可用的存储类： auto register static extern 1. autoauto存储类是所有局部变量默认的存储类，auto只能用在函数类，也就是说auto只能修饰局部变量。 12345&#123; /* 下面定义的变量其实带有相同的存储类 */ int a; auto int a;&#125; 2. registerregister存储类用于定义存储在寄存器的局部变量，而不是RAM中的局部变量，这意味着变量的最大尺寸等于寄存器的大小，而且不能用’&amp;’运算符对它进行运算(因为它没有内存位置) 123&#123; register int length;&#125; 3. staticstatic存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在进入和离开作用域时进行创建和销毁。所以，使用static修饰的局部变量可以在函数之间调用保持局部变量的值。 使用static修饰全局变量时，会使变量的作用域限制在声明它的文件内。只要方法跟变量在同个文件内，都可调用该变量。 4. externextern存储类用于提供一个全局变量的引用，全局变量对所有程序文件都是可见的。 当使用extern时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当有多个文件，且定义一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern来得到已定义的变量或函数。extern就是用来在另一个文件中声明一个全局变量或函数。 文件一：main.c 12345678910#include &lt;stdio.h&gt;int count;extern void print_count(void); //声明printcount.c中定义的函数int main()&#123; count = 10; print_count(); return 0;&#125; 文件二：printcount.c 123456#include &lt;stdio.h&gt;extern int count; //声明在main.c中定义的countvoid print_count(void)&#123; printf(\"count is %d\\n\", count);&#125; 结果： 1count is 10 六. 运算符位运算符位运算符作用于位，并逐位执行操作，真值表如下： p q p&amp;q(与) p\\ q(或) p^q(异或) 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 1 1 1 &lt;&lt;二进制左移运行：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）. >&gt; 二进制右移运算：将一个数的二进制位全部右移若干位，正数左补0；负数左bu1，右边丢弃。 杂项运算符 sizeof()：返回变量的大小 &amp;：返回变量的地址 *：指向一个变量 七. 判断C语言中“非零即为真”，就是说非零和非空认定为true，零或null认定为false 八. 循环for无限循环由于构成for循环的三个表达式中任何一个都不是必须的，所以三个条件都为空就构成一个无限循环。 123for( ; ; )&#123; //无限循环执行下去&#125; 九. 函数函数是一组一起执行的任务语句。 函数的声明告诉编译器函数的名称、返回类型和参数； 函数的定义提供函数的实际主体。 函数的参数形参：如果函数要使用参数，则必须声明接受参数的变量，这些变量就称为函数的形参。形参在进入函数时被创建，退出函数时被销毁。 函数调用时的两种传递参数方式： 传值调用 该方法把参数的实际值复制给函数的形参，此时修改函数的形参并不会影响实参 引用调用 通过指针传递，形参为指向实参地址的指针，当操作形参时，相当于同时在操作实参。 默认情况下，C语言使用传值调用。 十. 枚举第一个枚举成员的默认值为整型0，后续枚举成员的值在前一个成员加1。 枚举变量的定义，有三种方式： 先定义枚举类型，再定义枚举变量 12345678910enum DAY&#123; MON = 1, TUE, WED, THU, FRI, SAT, SUN&#125;;enum DAY day; 定义枚举类型的同时定义枚举变量 123456789enum DAY&#123; MON = 1, TUE, WED, THU, FRI, SAT, SUN&#125;day; 省略枚举名称，直接定义枚举变量 123456789enum&#123; MON = 1, TUE, WED, THU, FRI, SAT, SUN&#125;day; 十一. 指针内存地址： 每个变量都有一个内存位置，每个内存位置都定义了可使用连字号(&amp;)运算符访问的地址，它表示在内存中的一个地址。 什么是指针? 指针是一个变量，其值是另一个变量的地址，即，内存位置的直接地址。 实际数据类型，不管是整形，浮点型或者字符型等，对应的指针的值类型都是一样的，都是一个代表内存地址的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 使用指针： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int var = 20; int *ip; ip = &amp;var; printf(\"var 的地址：%p\\n\", &amp;var); printf(\"指针变量的值：%p\\n\", ip); printf(\"指针所指的值：%d\\n\", *ip); return 0;&#125; C中的Null指针 声明变量时，如果没有确定可以赋值的地址，通常给指针变量赋NULL值，此时的指针称为空指针。 NULL指针是定义在标准库中值为零的常量， 十二. 函数指针通常指针变量是指向例如整形，字符型等变量，而函数指针是指向函数的指针变量。 函数指针可用于调用函数，传递参数。 回调函数 函数指针作为某个函数的参数： 函数指针可以作为某个函数的参数来使用，回调函数就是一个通过函数指针调用的函数，也就是说回调函数是由别人的函数执行时调用你实现的函数。 十三. 结构体C数组允许存储相同类型的数据，结构是C语言中可由用户自定义的数据类型，它允许存储不同类型的数据项。 定义结构 使用struct语句定义一个包含多个成员的新数据类型： 12345struct tag&#123; member1; member2; ...&#125;variable-list; tag：结构体标签 member：标准的变量定义，比如int a。 variable-list：结构变量，定义在结构的末尾，可以指定一个或多个结构变量。 例子： 12345struct Books&#123; int id; char title[50]; char author[50];&#125;book; 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，从而实现一些更高级的数据结构，比如树结构或者链表等。 结构体变量的初始化 结构体变量可以在定义时指定初始值： 12345struct Books&#123; int id; char title[50]; char author[50];&#125;book = &#123;123456, \"C 语言\", \"hehe\"&#125;; 访问结构成员 可以使用成员访问运算符(.)来访问结构成员。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Books&#123; int id; char tilte[50]; char author[50];&#125;;int main()&#123; struct Books Book1; strcpy(Book1.tilte, \"C Programming\"); strcpy(Book1.author, \"hehe\"); Book1.id = 123; printf(\"Book1 title: %s\\n\", Book1.tilte); printf(\"Book1 author: %s\\n\", Book1.author); printf(\"Book1 id: %d\\n\", Book1.id); return 0;&#125; 结果： 123Book1 title: C ProgrammingBook1 author: heheBook1 id: 123 指向结构的指针 定义指向结构的指针方式跟定义指向其他类型变量的指针类似： 1struct Books *struct_pointer; 给结构指针变量赋值： 1strcut_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构成员，需使用-&gt;运算符： 1struct_pointer-&gt;title; 上面例子使用结构的指针来访问成员变量来实现： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Books&#123; int id; char tilte[50]; char author[50];&#125;;int main()&#123; struct Books Book1; struct Books *struct_pointer; struct_pointer = &amp;Book1; strcpy(Book1.tilte, \"C Programming\"); strcpy(Book1.author, \"hehe\"); Book1.id = 123; printf(\"Book1 title: %s\\n\", struct_pointer-&gt;tilte); printf(\"Book1 author: %s\\n\", struct_pointer-&gt;author); printf(\"Book1 id: %d\\n\", struct_pointer-&gt;id); return 0;&#125; 十四. 共用体共用体是一种特殊的数据类型，允许在相同的内存中存储不同的数据类型。共用体可以定义多个成员变量，但任何时候只能有一个成员变量带有值。共用体提供一种使用相同内存位置的有效方式。 定义共用体 定义共用体，需使用union语句，方式跟结构体相似。 12345union Data&#123; int i; float f; char str[10];&#125;data; 共用体占用的内存为成员变量中最大的那个，例如上面例子中，Data占用10个字节。 访问共用体成员 访问共用体成员，可以使用成员访问符(.)。共用体变量的定义可以使用union，例如定义一个共用体类型的变量： 1unit Data data; 注意：同一时间只能使用一个变量。 十五. typedefC语言中typedef关键字，可以用来为已有类型或者自定义的数据类型取一个新的名字。例如 1typedef unsigned char BYTE; 这样重命名后，以后就可以用BYTE来定义unsigned char了，这好比给自己起了一个昵称之后，以后朋友可以用你原来的名字叫你，也可用昵称来叫你了。 typedef 与#define的比较： typedef仅限为类型定义符号名称，#define不仅为类型定义别名，也能为数值定义别名，例如我们能将数字1定义为ONE typedef是由编译器执行解释的，#define语句是预编译器进行处理的","categories":[],"tags":[],"keywords":[]},{"title":"CMD命令","slug":"CMD/CMD命令","date":"2020-07-31T07:41:35.000Z","updated":"2020-09-14T03:01:41.794Z","comments":false,"path":"2020/07/31/CMD/CMD命令/","link":"","permalink":"http://yoursite.com/2020/07/31/CMD/CMD%E5%91%BD%E4%BB%A4/","excerpt":"","text":"tree ——显示磁盘目录结构1．功能：显示指定驱动器上所有目录路径和这些目录下的所有文件名。2．类型：外部命令3．格式：TREE[盘符：][/F][》PRN]4．使用说明：（1）使用/F参数时显示所有目录及目录下的所有文件，省略时，只显示目录，不显示目录下的文件；（2）选用＞PRN参数时，则把所列目录及目录中的文件名打印输出。 导出当前目录的文件夹/文件的目录树到tree.txt文件中。 1tree /f &gt;tree.txt Tip: 假如","categories":[],"tags":[],"keywords":[]},{"title":"数据结构/链表 Linked List","slug":"数据结构/链表 Linked List","date":"2020-07-31T02:30:06.354Z","updated":"2020-07-31T02:30:06.355Z","comments":true,"path":"2020/07/31/数据结构/链表 Linked List/","link":"","permalink":"http://yoursite.com/2020/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%20Linked%20List/","excerpt":"","text":"链表 Linked List 什么是链表 线性表：也称线性存储结构，线性表中的数据元素之间的关系是一对一的关系，除了第一个和最后要给数据元素，其他的数据元素都是首尾相连的。 链表：线性表中使用链式存储的就是链表。 线性表存储结构 顺序存储结构：将数据依次存储在连续的整块的物理空间中，称为顺序存储结构，简称顺序表。 随机取读，访问一个元素的时间复杂度为O(1) 链式存储结构：数据分散存储在物理空间中，每一个元素都有一个指针域，指针域存储着下个元素的指针，这种存储结构称为链式存储结构，也称链表。 优点：定点插入和定点删除时间复杂度为O(1)，不浪费内存，添加元素才申请内存，删除元素释放内存。 缺点：访问的时间复杂度最坏为O(n)。 链表分类 根据指针域的不同分为： 单向链表 双向链表 循环链表","categories":[],"tags":[],"keywords":[]},{"title":"unity/unity备忘","slug":"unity/unity备忘","date":"2020-07-31T02:30:06.330Z","updated":"2020-07-31T02:30:06.330Z","comments":true,"path":"2020/07/31/unity/unity备忘/","link":"","permalink":"http://yoursite.com/2020/07/31/unity/unity%E5%A4%87%E5%BF%98/","excerpt":"","text":"设置变量在界面中显示 将变量设置为public 假如不想设置为public，可在前面加[SerializeField] 12[SerializeField]private float speed;","categories":[],"tags":[],"keywords":[]},{"title":"unity/UnityEditor异常处理","slug":"unity/UnityEditor异常处理","date":"2020-07-31T02:30:06.329Z","updated":"2020-09-14T03:01:32.622Z","comments":true,"path":"2020/07/31/unity/UnityEditor异常处理/","link":"","permalink":"http://yoursite.com/2020/07/31/unity/UnityEditor%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"一. UnityEditor.AsyncHTTPClient:Done(State, Int32)异常处理 二. 使用Chinemachine Confiner无Confine Screen Edges 此时想要使用此插件限制跟随相机的范围不生效，依旧能看到背景之外的东西。 后来才发现要使用这个插件，主摄像机需要使用orthographic，而不是 perspective 之后即可看到Confine Screen Edges选项 此时摄像机也被限制在规定范围内。","categories":[],"tags":[],"keywords":[]},{"title":"python/python笔记","slug":"python/python笔记","date":"2020-07-31T02:30:06.326Z","updated":"2020-07-31T02:30:06.326Z","comments":true,"path":"2020/07/31/python/python笔记/","link":"","permalink":"http://yoursite.com/2020/07/31/python/python%E7%AC%94%E8%AE%B0/","excerpt":"","text":"列表拼接的三种方式方式一：使用”+” 使用此方法拼接，列表依旧不是原来的列表了，列表名此时已经指向内存空间中一个新的地址了 方式二：切片赋值 这种方式拼接后依旧是原来的列表，要实在说有什么缺点，只能说可读性不高，比较难记 方式三：列表自带extend方法 三种方法中，这种相对比较好一些，不需要开辟新的存储空间，而且比较好理解 获取文件拓展名方法一：最后一个点的位置直到末尾就是文件拓展名 12fileName = \"abc.txt\"end = fileName[fileName.rfind('.')+1:] 方法二： 12list = fileName.split('.')end = list[len(list)-1] 方法三：此方法获取到的会带”.”，例如“.txt” 12import osend = os.path.splitext(fileName[-1])","categories":[],"tags":[],"keywords":[]},{"title":"python/python读写Excel表格","slug":"python/python读写Excel表格","date":"2020-07-31T02:30:06.326Z","updated":"2020-07-31T02:30:06.328Z","comments":true,"path":"2020/07/31/python/python读写Excel表格/","link":"","permalink":"http://yoursite.com/2020/07/31/python/python%E8%AF%BB%E5%86%99Excel%E8%A1%A8%E6%A0%BC/","excerpt":"","text":"python读写Excel表格python读写Excel表格其实就依赖两个库： python读excel——xlrd python写excel——xlwt 一. python读excel1.先安装读表所需要的库 1pip install xlrd 2.导入库，打开表格 123improt xlrd#打开文件table = xlrd.open_workbook(\"角色表.xlsx\",'rb') 3.找到指定工作簿 ​ python获取工作簿方式： 123456#方法一：通过索引sheet = table.sheets()[0]#方法二：通过索引获取表格sheet = table.sheet_by_index(0)#方法三：通过名字获取表格sheet = table.sheet_by_name('sheetname') 4.获取工作簿行数、列数 1234# 行数row_num = sheet.nrows# 列数col_num = sheet.ncols 5.获取某行某列的值，i代表行数或者列数的索引(从0开始) 1234# 获取某行的值row_values = sheet.row_values(i)# 获取某列的值col_values = sheet.col_values(i) 6.读取某个单元格数据 1value = sheet.cell(i,j).value 7.单元格内容类型 excel单元格内容返回类型有5种ctype： 0 : empty 1 : string 2 : number 3 : date 4 ：boolean 5 ：error 假如单元格类型为3(即date)，输出为一串数字，需要进一步处理才能显示为日期格式，转换步骤如下： 1234cell = sheet.cell(i,j)if cell.ctype == 3: date = xlrd.xldate_as_datetime(cell.value, 0) cell = date.strftime('%Y%m%d') 或 12345from datetime import datetimeif cell.ctype == 3: sCell = skin.cell_value(i,j) date = datetime(*xldate_as_tuple(sCell, 0)) cell = date.strftime('%Y%m%d') 二. python写excel1.安装xlwt 1pip install xlwt 2.导入xlwt，创建工作簿 123import xlwtworkbook &#x3D; xlwt.Workbook()worksheet &#x3D; workbook.add_sheet(&#39;test&#39;) 3.写入数据 1worksheet.write(0,0,'hehe') 4.存入到excel文件中 1workbook.save('test.xls') 5.打开test.xls文件即可看到里面已经插入了test工作表，而且A1的内容为hehe。","categories":[],"tags":[],"keywords":[]},{"title":"python/python打包成exe","slug":"python/python打包成exe","date":"2020-07-31T02:30:06.325Z","updated":"2020-07-31T02:30:06.325Z","comments":true,"path":"2020/07/31/python/python打包成exe/","link":"","permalink":"http://yoursite.com/2020/07/31/python/python%E6%89%93%E5%8C%85%E6%88%90exe/","excerpt":"","text":"python打包成exe步骤 安装pyinstaller 1pip install pyinstaller 将目录切到python文件所在目录，或者在对应目录按shift+右键，打开命令行。 执行打包命令 1pyinstall -F test.py 之后即可在目录下看的新增dist文件夹，exe就存放在这里 异常处理有时候python直接运行没有问题，打包后却无法正常运行，出现 1Could not find a suitable TLS CA certificate bundle, invalid path: C:\\\\Users\\\\...cacert.pem 那是因为找不到cacert.pem文件了，项目中引入了其他的库很可能就会出现这样的问题 解决办法：手动将所需库/文件添加到程序的引用中 1.例如使用requests库打包就会出现这种问题，此时需要到python安装目录下，找到\\Lib\\site-packages\\requests\\cacert.pem复制到包含您的exe的dist目录 2.在代码中添加 123import osimport sysos.environ['REQUESTS_CA_BUNDLE'] = os.path.join(os.path.dirname(sys.argv[0]), 'cacer') 3.重新进行打包","categories":[],"tags":[],"keywords":[]},{"title":"python/openpyxl修改excel(不修改原格式)","slug":"python/openpyxl修改excel(不修改原格式)","date":"2020-07-31T02:30:06.324Z","updated":"2020-07-31T02:30:06.325Z","comments":true,"path":"2020/07/31/python/openpyxl修改excel(不修改原格式)/","link":"","permalink":"http://yoursite.com/2020/07/31/python/openpyxl%E4%BF%AE%E6%94%B9excel(%E4%B8%8D%E4%BF%AE%E6%94%B9%E5%8E%9F%E6%A0%BC%E5%BC%8F)/","excerpt":"","text":"python修改excel(不修改原格式)使用xlwt虽然可以编辑excel中的数据，但假如原本的表格中一些单元格是带格式的，例如加粗，颜色不一样等，编辑后这些格式都会丢失。 因为编辑过程是先把整个表格先复制一遍，然后在复制的数据上进行修改，最终再把编辑好的数据保存到原本的表格中进行覆盖，xlwt复制是不会复制表格文本的格式的，所以修改后的数据覆盖原本的数据就把格式给弄丢了。 使用openpyxl模块来编辑表格就没这样的问题，用它来修改表格，原来的格式依旧存在，使用方法如下： 下载openpyxl 1pip install openpyxl 打开已存在表格 12from openpyxl import load_workbookwb = load_workbook('表格.xlsx') 获取工作表 1sheet = wb.get_sheet_by_name('Sheet1') 获取单元格 1234#方式一cell = sheet['A1']#方式二cell = sheet.cell(row=1, column=1) 设置单元格数据 1cell.value = 'hello' 保存到表格内 1wb.save('表格.xlsx') 使用汇总 安装 1pip install openpyxl 打开文件 2.1 创建、保存 1234pythonfrom openpyxl import Workbookwb = Workbook()wb.save('hehe.xlsx') 2.2 打开已存在文件 12form openpyxl import load_workbookwb = load_workbook('hehe.xlsx') 工作簿操作 123456789101112131415161718wb = load_workbook('hehe.xlsx')#获取工作簿中的列表print(wb.sheetnames)#查看是否只读print(wb.read_only)#文档编码print(wb.encoding)#创建表sheet1 = wb.create_sheet('sheet1')sheet2 = wb.create_sheet('sheet2', 0) #插到开始位置#选择表格sheet = wb.get_sheet_by_name('sheetname'))sheet = wb['sheetname']sheet = wb.active #获取当前活跃的woksheet 工作表(sheet)操作 123456789sheet = wb['sheetname']#获取最大行数/列数rows_num = sheet.max_rowcol_num = sheet.column#获取所有的行/列rows = sheet.rowscolumns = sheet.columns 单元格(cell)操作(单个单元格) 12345678910#访问单元格cell = sheet['A1']cell = sheet.cell(row=4, column=1)#获取单元格数据value = cell.value#修改单元格内容cell.value = 'hehe' #方式一sheet.cell(1, 2, 10) #方式二 多单元格操作 123456789101112#选择整行row = sheet[10]#选择多行rows = sheet[1:10]#选择整列col = sheet['C']#选择多列cols = sheet['C:D']#获取多个单元格cell_range = sheet['A1':'C2'] 7.","categories":[],"tags":[],"keywords":[]},{"title":"linux/linux常用命令","slug":"linux/linux常用命令","date":"2020-07-31T02:30:06.320Z","updated":"2020-07-31T02:30:06.320Z","comments":true,"path":"2020/07/31/linux/linux常用命令/","link":"","permalink":"http://yoursite.com/2020/07/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"目录管理linux目录结构为树状结构，顶级目录为根目录/。 绝对路径与相对路径 绝对路径 由根路径 / 写起，如：/usr/local/share 相对路径 不是由 / 写起，例如从/usr/local/share到/usr/local/src中去，可以这样写：cd ../src，这样的写法就是相对路径的写法。 常用目录命令 ls：列出目录 cd：切换目录 mkdir：创建新目录 rmdir：删除空目录 cp：复制文件或目录 rm：移除文件或目录 mv：移动文件与目录，或者重命名文件或目录","categories":[],"tags":[],"keywords":[]},{"title":"markdown数学公式","slug":"markdown使用/markdown数学公式","date":"2020-03-28T13:34:18.000Z","updated":"2020-07-31T02:30:06.323Z","comments":false,"path":"2020/03/28/markdown使用/markdown数学公式/","link":"","permalink":"http://yoursite.com/2020/03/28/markdown%E4%BD%BF%E7%94%A8/markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","excerpt":"","text":"行内插入数学公式：$公式$ 插入公式块：$$公式内容$$ 1.上下标分别用^和_，例如x_i^2就是$ x_i^2 $ 2.常用运算符 运算符 说明 运算符案例 实现 + 加 x+y $x+y$ - 减 x-y $x-y$ \\times 乘 $x \\times y$ $x \\times y$ \\cdot 点积 $x \\cdot y$ $x \\cdot y$ \\ast 乘 $x \\ast y$ $x \\ast y $ \\div 除 $ x \\div y$ $ x\\div y $ \\frac 分数 $\\frac {x}{y} $ \\frac {x}{y} \\ neq 不等于 $\\neq$ $\\neq$ \\sqrt 根号 $\\sqrt x$ $\\sqrt x$ \\sum 累加 $\\sum_{k=1}^n$ $\\sum_{k=1}^n$ 3.大括号左括号：\\left (，右括号：\\right)，则\\left( \\frac x2 \\right)表示$\\left( \\frac x2 \\right)$ 5. 根号\\sqrt{x}用来表示$\\sqrt{x}$ 6. 戴帽符号 符号 写法 $\\hat{x}$ \\hat{x} $\\widehat{xyz}$ \\widehat{xyz} $\\check{x}$ \\check{x} $\\breve{y}$ \\breve{y} $\\tilde{x}$ \\tilde{x} $\\widetilde{xyz}$ \\widetilde{xyz} $\\grave{x}$ \\grave{x} 7. 矩阵(1) 普通矩阵 12345678$$ \\begin&#123;matrix&#125; a &amp; b &amp; c &amp; d &amp; e\\\\ f &amp; g &amp; h &amp; i &amp; j \\\\ k &amp; l &amp; m &amp; n &amp; o \\\\ p &amp; q &amp; r &amp; s &amp; t \\end&#123;matrix&#125; $$ 效果： \\begin{matrix} a & b & c & d & e\\\\ f & g & h & i & j \\\\ k & l & m & n & o \\\\ p & q & r & s & t \\end{matrix}(2) 带中括号 12345678\\left[ \\begin&#123;matrix&#125; a &amp; b &amp; c &amp; d &amp; e\\\\ f &amp; g &amp; h &amp; i &amp; j \\\\ k &amp; l &amp; m &amp; n &amp; o \\\\ p &amp; q &amp; r &amp; s &amp; t \\end&#123;matrix&#125; \\right] \\left[ \\begin{matrix} a & b & c & d & e\\\\ f & g & h & i & j \\\\ k & l & m & n & o \\\\ p & q & r & s & t \\end{matrix} \\right]8.希腊字母 字母 写法 $\\alpha$ \\alpha $\\beta$ \\beta $\\gamma$ \\gamma $\\theta$ \\theta 9.三角运算符 符号 写法 $\\sin$ \\sin $\\cos$ \\cos $\\tan$ \\tan $\\cot$ \\cot $\\sec$ \\sec $\\csc$ \\csc","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}]},{"title":"获取url中的参数","slug":"javascripts/获取url中的参数","date":"2020-03-28T13:34:18.000Z","updated":"2020-07-31T02:30:06.319Z","comments":false,"path":"2020/03/28/javascripts/获取url中的参数/","link":"","permalink":"http://yoursite.com/2020/03/28/javascripts/%E8%8E%B7%E5%8F%96url%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/","excerpt":"","text":"获取url中的参数方法一：12345678910111213141516171819202122232425262728293031323334function getUrlParams (search) &#123; search &#x3D; search || location.search; &#x2F;&#x2F; 判断是否为字符串类型 if (typeof search !&#x3D;&#x3D; &#39;string&#39;) &#123; search &#x3D; search.toString(); &#125; var paramsSplit &#x3D; search.replace(&#x2F;^[^\\?]*\\?&#x2F;i, &#39;&#39;).split(&#x2F;&amp;&#x2F;); var params &#x3D; &#123;&#125;; &#x2F;&#x2F; 数据为空 if (paramsSplit.length &lt; 1) &#123; return params; &#125; if (Array.isArray(paramsSplit)) &#123; paramsSplit.forEach(function (item) &#123; &#x2F;&#x2F; 数据为空, 退出方法 if (!item) &#123; return false; &#125; var itemSplit &#x3D; item.split(&#x2F;&#x3D;&#x2F;); &#x2F;&#x2F; 判断字符串中是否有多个&#x3D; if (itemSplit.length &gt;&#x3D; 2) &#123; &#x2F;&#x2F; 是 var key &#x3D; itemSplit.splice(0, 1); params[key] &#x3D; itemSplit.join(&#39;&#x3D;&#39;); &#125; &#125;); &#125; return params&#125; 方法二：12345678910111213141516&#x2F;&#x2F;获取url中参数 function GetRequest() &#123; var url &#x3D; location.search; &#x2F;&#x2F;获取url中&quot;?&quot;符后的字串 var theRequest &#x3D; new Object(); if (url.indexOf(&quot;?&quot;) !&#x3D; -1) &#123; var str &#x3D; url.substr(1); strs &#x3D; str.split(&quot;&amp;&quot;); for (var i &#x3D; 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split(&quot;&#x3D;&quot;)[0]] &#x3D; unescape(strs[i].split(&quot;&#x3D;&quot;)[1]); &#125; &#125; return theRequest; &#125; 根据key,获取url中的参数12345678910111213141516function GetRequest2(key) &#123; var url &#x3D; location.search; var theRequest &#x3D; new Object(); if (url.indexOf(&quot;?&quot;) !&#x3D; -1) &#123; var str &#x3D; url.substr(1); strs &#x3D; str.split(&quot;&amp;&quot;); for (var i &#x3D; 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split(&quot;&#x3D;&quot;)[0]] &#x3D; unescape(strs[i].split(&quot;&#x3D;&quot;)[1]); &#125; &#125; var value &#x3D; theRequest[key]; return value; &#125;","categories":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"}],"tags":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/tags/javaScripts/"}],"keywords":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"}]},{"title":"Shader学习3——数学","slug":"图形学/Shader学习3_数学","date":"2020-03-14T14:22:14.000Z","updated":"2020-07-31T02:30:06.353Z","comments":true,"path":"2020/03/14/图形学/Shader学习3_数学/","link":"","permalink":"http://yoursite.com/2020/03/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shader%E5%AD%A6%E4%B9%A03_%E6%95%B0%E5%AD%A6/","excerpt":"","text":"笛卡尔坐标系1. 二维笛卡尔坐标系其实我们小学就开始接触的二维坐标系就是笛卡尔坐标系，只是我们当时并不知道这个名字而已。 x轴和y轴互相垂直，也称为该坐标系的基矢量。 在OpenGL和DirectX中使用了不同的二维笛卡尔坐标系 2. 三维笛卡尔坐标系三维笛卡尔坐标系中，需要定义三个坐标轴和一个原点，如下图： 这三个坐标轴也称为基矢量(basis vector)，通常三个坐标轴是互相垂直的，而且长度为1，这样的基矢量称为标准正交基。假如长度不为1，这样的基矢量称为正交基。 3. 左手坐标系、右手坐标系笛卡尔三维坐标系又分为左手坐标系和右手坐标系 4. Unity使用的坐标系 在模型空间和世界空间中，Unity使用的是左手坐标系 对于观察空间来说，Unity使用的是右手坐标系。 观察空间，就是摄像机为原点的坐标系，此坐标系中，摄像机前向是z轴的负方向，也就是说，z轴坐标减少，场景深度增加。 矢量1. 矢量与点点(point)是n维空间中的一个位置，没有大小与宽度。 矢量(vector，也称向量)，是指在n维空间一种包含模和方向的有向线段。 矢量的模，指的是矢量的长度，是一个任意非负数 矢量的方法，指描述了这个矢量在空间中的指向 表示方法： 二维矢量：v = (x, y) 三维矢量： v = (x, y, z) 四维矢量： v = (x, y, z, w) 2. 矢量计算 矢量与标量的乘除法 乘法：只需要把矢量的每个分量都与标量相乘。 kv = (kv_x, kv_y, kv_z)除法：等同于和这个标量的倒数相乘 \\frac vk = \\frac {(x,y,z)}k = \\frac 1k (x,y,z) = \\left( \\frac xk, \\frac yk, \\frac zk \\right), k\\neq 0 矢量加减法 两矢量进行相加减，结果为一个相同维度的新矢量。计算过程中只需要两矢量的相应分量进行相加减即可： a+b = (a_x+b_x,a_y+b_y,a_z+b_z) 注意：矢量不可以跟标量相加减，或者和不同维度的矢量进行运算。 3. 矢量的模矢量的模式一个标量，可理解为矢量在空间中的长度。三维矢量的模计算公式如下： |v| = \\sqrt{v_x^2+v_y^2+v_z^2}其他维度的模计算类似，都是对每个分量平方后相加再开根号。 4. 单位矢量单位矢量指模为1的矢量，也称为被归一化的矢量，非零矢量转为单位矢量的过程称为归一化。 矢量归一化公式： \\hat v = \\frac v{|v|}零矢量：每个分量都是0，如v = (0,0,0)，零矢量是不可以被归一化的。 5. 矢量的点积矢量的乘法有两种常用的种类： 点积，也称内积 叉积，也称外积 两矢量的点积是把矢量对应分量相乘后再取和，最终得到一个标量。 公式一： a \\cdot b = (a_x,a_y,a_z) \\cdot (b_x,b_y,b_z) = a_xb_x+a_xb_y+a_zb_z点积的几何意义：投影(projection) 点积的性质： 性质1：点积可结合标量乘法$(ka)·b = a \\cdot (kb) = k(a \\cdot b)$ 也就是说点积对一个矢量进行缩放，相当于对最后的结果进行缩放 性质2：点积可结合矢量加法和减法 a \\cdot (b+c) = a \\cdot b + a\\cdot c 性质3：一个矢量和自身进行点积的结果，是该矢量的模的平方 v\\cdot v = |v|^2 6. 矢量的叉积矢量的叉积的结果仍然是一个矢量。叉积公式如下： a \\times b = (a_x,a_y,a_z) \\times (b_x,b_y,b_z) = (a_yb_z-a_zb_y,a_zb_x-a_xb_z,a_xb_y-a_yb_x)叉积不满足交换律，即$ a \\times b \\neq b\\times a$，但是实际上 $a \\times b = - (b\\times a)$ 叉积不满足结合律，即$(a \\times b)\\times c \\neq a \\times (b \\times c)$ 几何意义：对两个矢量进行叉积的结果会得到一个同时垂直于这两个矢量的新矢量。 应用：计算一个垂直于一个平面、三角形的矢量。 矩阵1. 矩阵运算1.1 矩阵和标量的乘法 kM = Mk = k \\left[ \\begin{matrix} m_{11}&m_{12}&m_{13}\\\\ m_{21}&m_{22}&m_{23}\\\\ m_{31}&m_{32}&m_{33}\\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} km_{11}&km_{12}&km_{13}\\\\ km_{21}&km_{22}&km_{23}\\\\ km_{31}&km_{32}&km_{33}\\\\ \\end{matrix} \\right]1.2 矩阵和矩阵的乘法两矩阵的乘法结果是一个新的矩阵，维度跟两个矩阵维度相关。 矩阵A为r x n的矩阵，矩阵B为n x c的矩阵。AB将是r x c大小的矩阵。 注意：第一个矩阵的列数必须等于第二个矩阵的行数，结果为第一个矩阵的行数，第二个矩阵的列数 矩阵A跟矩阵B相乘，结果得到矩阵C，C中的每个元素$c_{ij}$,由A中的第i行和B中的第j列，相乘后相加，即： c_{ij} = a_{i1}b_{1j}+a_{i2}b_{2j}+ ... + a_{in}b_{nj} = \\sum_{k=1}^n a_{ik}b_{kj}例如： A= \\left[ \\begin{matrix} a_{11}&a_{12}\\\\ a_{21}&a_{22}\\\\ a_{31}&a_{32}\\\\ \\end{matrix} \\right] B = \\left[ \\begin{matrix} b_{11}&b_{12}&b_{13}&b_{14}\\\\ b_{21}&b_{22}&b_{23}&b_{24}\\\\ \\end{matrix} \\right]相乘结果C： C = \\left[ \\begin{matrix} c_{11}&c_{12}&c_{13}&c_{14}\\\\ c_{21}&c_{22}&c_{23}&c_{24}\\\\ c_{31}&c_{32}&c_{33}&c_{34}\\\\ \\end{matrix} \\right]则$c_{23} = a_{21}b_{13}+a_{22}b_{23}$ 矩阵乘法性质： 性质一：不满足交换律，即$AB \\neq BA$ 性质二：满足结合律，即$(AB)C = A(BC)$ 2. 特殊矩阵在Shader中经常见到的特殊矩阵，这些矩阵往往具有一些重要的性质。 2.1 方块矩阵简称方阵，指行数和列数相等的矩阵。三维渲染中最常见的就是$3 \\times 3$和$4 \\times 4$的方阵。 角元素：行号跟列号相等的元素，如$m_{11}$,$m_{22}$等。因为这些元素排在正方形的对角线上，故而称为角元素。 对角矩阵：除了角元素外的所有元素都是0，这样的矩阵称为对角矩阵。如： \\left[ \\begin{matrix} 1&0&0&0\\\\ 0&2&0&0\\\\ 0&0&3&0\\\\ 0&0&0&4\\\\ \\end{matrix} \\right]2.2 单位矩阵对角元素都为1的对角矩阵，称为单位矩阵(identity matrix)，用$I_n$来表示，如： \\left[ \\begin{matrix} 1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&1&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right]与单位矩阵相乘的矩阵，结果还是原来的矩阵，这就是单位矩阵名字的由来。即： MI = IM = M2.3 转置矩阵转置矩阵其实是对原矩阵的一种运算，即转置运算。例如$r \\times c$的矩阵M，它的转置矩阵为$M^T$,$M^T$为一个$c \\times r$的矩阵。 M_{ij}^T = M_{ji}例如： \\left[ \\begin{matrix} 1&2&3&4\\\\ 5&6&7&8\\\\ \\end{matrix} \\right]^T = \\left[ \\begin{matrix} 1&5\\\\ 2&6\\\\ 3&7\\\\ 4&8\\\\ \\end{matrix} \\right]转置矩阵性质： 性质一：矩阵转置的转置等于原矩阵，即 (M^T)^T = M 矩阵串接的转置，等于反向串接各个矩阵的转置。 (AB)^T = B^TA^T 2.4 逆矩阵逆矩阵是一种特俗的方阵，它的特殊之处在于原矩阵和其逆矩阵相乘，结果为一个单位矩阵，例如矩阵M，其逆矩阵未$M^{-1}$ MM^{-1} = M^{-1}M = I不是所有方阵都有对应的逆矩阵，例如元素都为0的矩阵就不存在逆矩阵(因为相乘都为0)。 矩阵有对应逆矩阵，我们称该矩阵是可逆的，或者非奇异的，没有逆矩阵的则称为不可逆的，或者奇异的。 逆矩阵性质： 性质一：逆矩阵的逆矩阵还是原来的矩阵本身 (M^{-1})^{-1} = M 性质二：单位矩阵的逆矩阵是它本身。 I^{-1} = I 性质三：转置矩阵的逆矩阵是逆矩阵的转置 (M^T)^{-1} = (M^{-1})^T 性质四：矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵。 (AB)^{-1} = B^{-1}A^{-1} 2.5 正交矩阵正交是矩阵的一种属性，如果一个方阵M和它的转置矩阵的成绩是单位矩阵的话，则称这个矩阵是正交的，即 MM^T = M^TM = I这个式子跟逆矩阵公式：$MM^{-1} = M^{-1}M = I$ 很相似，两个公式结合就能得到一个重要的性质，即如果一个矩阵是正交的，那么他的转置矩阵和逆矩阵是一样的。也就是说 M^T = M^{-1}矩阵的几何意义:变换1. 变换变换(transform)，指把数据通过某种方式进行转换的过程，这些数据可以是点、方向甚至颜色等。 线性变换：那些可以保留矢量加和标量乘的变换。 f(x)+f(y) = f(x+y) kf(x) = f(kx)常见的线性变换：缩放(scale)、旋转(rotation)、错切(shear)、镜像(morroring，也称reflection)、正交投影(orthographic projection) 2. 齐次坐标齐次坐标就是把n维向量，用n+1维向量表示。齐次坐标只是为了方便计算的一种表示方式而已。 例如：3*3矩阵不能表示平移操作，拓展到4*4就能实现。 如何将三维矢量变成四维矢量？ 对于一个点，只需要把其w分量设为1； 对于方向矢量来说，需要把其w分量设为0； 这样操作后，用4*4的矩阵对一个点进行变换时，平移、旋转、缩放都会施加于该点 对一个方向矢量进行变换时，将不起作用。 3. 分解基础变换矩阵4*4的矩阵能表示平移、旋转和缩放。我们把表示纯平移、纯旋转和纯缩放的变换叫做基础变换矩阵。基础变换矩阵分解如下： \\left[ \\begin{matrix} M_{3\\times3}&t_{3\\times1}\\\\ 0_{1\\times3}&1 \\end{matrix} \\right] $M_{3\\times 3}$用于表示旋转和缩放 $t_{3*3}$用于表示平移 $0_{1*3} = \\left[ \\begin{matrix} 0&amp;0&amp;0\\\\ \\end{matrix}\\right] $ 右下角是标量1 4. 平移矩阵 我们可以用矩阵乘法来对一个点（x,y,z）进行平移变换： 该点齐次坐标为(x,y,z,1) \\left[ \\begin{matrix} 1&0&0&t_x\\\\ 0&1&0&t_y\\\\ 0&0&1&t_z\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} x+t_x\\\\ y+t_y\\\\ z+t_z\\\\ 1\\\\ \\end{matrix} \\right]​ 从几何上看，就是把点$(x,y,z)$在空间中移动了$(t_x,t_y,t_z)$个单位。 对一个方向矢量（x,y,z）进行平移变换，结果如下： 该矢量的齐次坐标为（x,y,z,0） \\left[ \\begin{matrix} 1&0&0&t_x\\\\ 0&1&0&t_y\\\\ 0&0&1&t_z\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 0\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 0\\\\ \\end{matrix} \\right]​ 可以发现，平移变换不会对方向矢量产生任何影响。 构建平移矩阵： 基础变换矩阵中的$t_{3\\times 1}$矢量对应了平移矢量，左上角的矩阵$M_{3\\times 3}$为单位矩阵$I_3$。 平移矩阵的逆矩阵就是方向平移得到的矩阵，即 \\left[ \\begin{matrix} 1&0&0&-t_x\\\\ 0&1&0&-t_y\\\\ 0&0&1&-t_z\\\\ 0&0&0&1\\\\ \\end{matrix} \\right]可以看出，平移矩阵并不是一个正交矩阵。 5. 缩放矩阵我们可以对一个模型沿空间的x轴、y轴、z轴进行缩放。矩阵乘法表示如下： \\left[ \\begin{matrix} k_x&0&0&0\\\\ 0&k_y&0&0\\\\ 0&0&k_z&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} k_xx\\\\ k_yy\\\\ k_zz\\\\ 1\\\\ \\end{matrix} \\right]对反向矢量进行同样的矩阵进行缩放： \\left[ \\begin{matrix} k_x&0&0&0\\\\ 0&k_y&0&0\\\\ 0&0&k_z&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x\\\\ y\\\\ z\\\\ 0\\\\ \\end{matrix} \\right]= \\left[ \\begin{matrix} k_xx\\\\ k_yy\\\\ k_zz\\\\ 0\\\\ \\end{matrix} \\right]统一缩放：缩放系数$k_x = k_y = k_z$,其余都是非统一缩放。缩放矩阵的逆矩阵是使用原缩放系数的倒数来对点或方向矢量进行缩放，即 \\left[ \\begin{matrix} \\frac{1}{k_x}&0&0&0\\\\ 0&\\frac{1}{k_y}&0&0\\\\ 0&0&\\frac{1}{k_z}&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right]缩放矩阵一般不是正交矩阵。 6. 旋转矩阵 把点绕x轴旋转$\\theta$度，可以使用下面矩阵： R_x(\\theta)=\\left[ \\begin{matrix} 1&0&0&0\\\\ 0&\\cos\\theta&-\\sin\\theta&0\\\\ 0&\\sin\\theta&\\cos\\theta&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] 绕y轴： R_y(\\theta)=\\left[ \\begin{matrix} \\cos\\theta&0&\\sin\\theta&0\\\\ 0&1&0&0\\\\ -\\sin\\theta&0&\\cos\\theta&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] 绕z轴 R_z(\\theta)=\\left[ \\begin{matrix} \\cos\\theta&-\\sin\\theta&0&0\\\\ \\sin\\theta&\\cos\\theta&0&0\\\\ 0&0&1&0\\\\ 0&0&0&1\\\\ \\end{matrix} \\right] 旋转矩阵的逆矩阵是旋转相反角度得到的变换矩阵。旋转矩阵是正交矩阵，多个旋转矩阵之间的串联同样是正交的。 7. 复合变换可以将平移、旋转和缩放进行组合，形成一个复杂的变换过程。例如，可以对模型先缩放(2,2,2),再绕y轴旋转$30^。$，最后向z轴平移4个单位。符合变换可以通过矩阵串联来实现： P_{new} = M_{translation}M_{rotation}M_{scale}P_{old}(阅读顺序从右往左)变换的结果依赖于变换的顺序，矩阵乘法不满足交换律，因此不同的乘法顺序得到的结果不相同。 约定顺序：先缩放，再旋转，最后平移 坐标空间1. 坐标空间的变换每个空间都有一个父(parent)坐标空间，对坐标空间的变换实际上就是在父空间和子空间对点和矢量进行转换。 已头晕@@@，之后再补!!!! 2. 模型空间模型空间(model spacce)，有时也称对象空间，或者局部空间，每个模型都有自己独立的坐标空间。Unity在模型空间中使用左手坐标系，在此模型空间中，+x轴、+y轴、+z轴分别对应模型的右、上和前向。 3. 世界空间世界空间(word space)是一个特殊的坐标系，它创建了我们所关心的最大的空间。这里的最大指的是我们所关心的最外层的坐标空间。 4. 观察空间观察空间(view space),也被称为摄像机空间(camera space)。观察空间可以认为是模型空间的一个特例。 Unity中观察空间的坐标轴选择：+x轴指向右方，+y轴指向上方，+z轴指向的是摄像机的后方。 Unity中观察空间使用的是右手坐标系，在这样的空间中，摄像机的正前方指向的是-z轴的方向。 注意：观察空间和屏幕空间不同，观察空间是三维空间，屏幕空间是二维空间。之间的转换需要进行投影。 顶点变换的第二步，是将顶点坐标从世界空间变换到观察空间中，这个变换叫观察变换。 5. 裁剪空间裁剪空间(clip space, 也称为齐次裁剪空间)，用于变换的矩阵叫裁剪矩阵，也称投影矩阵。裁剪空间的目标是能够方便地对渲染图元进行裁剪： 完全在这空间内部的图元完全保留。 完全在这空间外部的图元完全剔除。 与这块空间相交的图元就会被裁剪。 判断一个顶点是否位于视锥体内部，可以通过投影矩阵把顶点转换到一个裁剪空间中。 以上指的空间由视锥体来决定。视锥体指空间中一块区域，这块区域来决定摄像机所能看到的空间。视锥体由六个平面包围而成，这些平面称为裁剪平面。如下所示： 投影类型： 正交投影，完全保留物体的距离和角度 透视投影，模拟人眼看世界的方式，近大远小 6.屏幕空间使用投影矩阵变换后，我们进行了裁剪操作，接下来就需要进行真正的投影。即把视锥体投影到屏幕空间(screen space)。经过这一步，就得到真正的像素位置，而不是虚拟的三维坐标。屏幕空间是二维的空间，故而我们要把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标： 1.首先进行标准的齐次除法，也称为透视除法，操作很简单，只需要用齐次坐标系中的w分量去除以x,y,z分量。 OpenGL中，这一步得到的坐标称为归一化设备坐标(Normalized Device Coordinates,NDC)。 经过投影变换后的裁剪空间，再经过齐次除法后会变换到一个立方体内。 按OpenGL传统，这个立方体的x,y,z分量的范围都是[-1,1]。Unity选择OpenGL这样的齐次裁剪空间。 在DirectX这样的API中，z分量的范围会是[0,1]。对于正交投影来说，它的裁剪空间实际已经是一个立方体了，而且经过正交投影矩阵变换后的顶底的w分量是1，因此经过齐次除法不会对x,y,z坐标产生影响。如图所示： 2.经过齐次除法后，透视投影和正交投影的视锥体都变换到一个相同的立方体内，接下来就可以根据变换后的x和y坐标来映射输出窗口的对应像素坐标。","categories":[],"tags":[{"name":"Unity Shader","slug":"Unity-Shader","permalink":"http://yoursite.com/tags/Unity-Shader/"}],"keywords":[]},{"title":"Shader学习3——数学","slug":"图形学/Shader学习1_初识计算机图形学","date":"2020-03-14T14:22:14.000Z","updated":"2020-07-31T02:30:06.338Z","comments":true,"path":"2020/03/14/图形学/Shader学习1_初识计算机图形学/","link":"","permalink":"http://yoursite.com/2020/03/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shader%E5%AD%A6%E4%B9%A01_%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","excerpt":"","text":"一. 初识计算机图形学图形与图形 图像纯指计算机内以位图（Bitmap)形式存在的灰度信息 图形含有几何属性，更强调场景的几何表示，是场景几何模型和景物的物理属性共同组成的 图形主要分成两类： 基于线条信息表示 明暗图（Shading） GPU 流水线1. 渲染管线顶点着色器 —&gt; 光栅化 —&gt; 片段着色器 —&gt; alpha测试 —&gt; 模板测试 —&gt; 深度测试 —&gt; Blend —&gt; Gbuffer —&gt; frontBuffer —&gt; frame buffer —&gt;显示器 1.1 顶点着色器 流水线的第一个阶段，输入来自CPU 处理单位为顶点，即输入的每个顶点都会调用一次顶点着色器 顶点着色器本身无法创建或者销毁任何顶点，也无法得到顶点之间的关系，例如无法知道两个顶点是否属于同一个三角网格 所以GPU可以并行处理每一个顶点，故此阶段处理速度很快 主要工作：坐标转换和逐顶点光照 1.2 光栅化​ 将顶点转成像素 1.3 片段着色器 纹理采样，从纹理像素 赋给顶点生成的像素 像素跟灯光计算 1.4 Alpha 测试​ 挑选合格的alpha 像素显示 1.5 模板测试​ 像素可携带模板信息，达到模板条件的显示出来 1.6 深度测试​ 符合条件的像素通过，否则丢弃 1.7 Blend​ 将当前要渲染的像素和已经渲染出来的像素混合运算 1.8 GBuffer​ RGBA、 模板值 、深度值等 2.屏幕坐标系屏幕坐标系在OpenGL和DirectX之间存在差异： OpenGL把屏幕左下角当成最小的窗口坐标 DirectX则把屏幕左上角当成最小的窗口坐标 GPU编程语言GLSLOpenGL Shading Language 优点：有较好的跨平台性，可在Windows、Linux、Mac甚至移动平台等多种平台上工作 原因：跨平台性是由于OpenGL没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作，也就是说只要显卡驱动支持GLSL的编译，就能运行它，它依赖硬件，而非系统层级 缺点：因为编译结果取决于供应商，供应商编译实现不尽相同，所以存在编译结果不一致的情况。 HLSLHigh Level Shading Language，DirectX 由微软控制着色器的编译，即使不同的硬件，同一着色器的编译结果相同，故而支持HLSL的平台相对有限，几乎都是微软自己的产品，其他平台没有可以编译HLSL的编译器。 CGC for Graphic 真正意义上的跨平台，会根据平台的不同，编译成相同的中间语言，因为它和微软合作，导致CG语言的语法和HLSL非常相似。CG语言可以无缝移植成HLSL代码。 固定管线渲染固定函数的流水线(Fixed-Function Pipeline)，也称固定管线，指在较旧的GPU上实现的渲染流水线，这种流水线只给开发者提供一些配置操作，开发者没有对流水线阶段的完全控制权。 固定管线通常只提供一系列接口，接口包含一个函数入口点，这些函数入口点匹配GPU上的特定逻辑功能，开发者通过这些接口来控制渲染流水线。 标注：已逐渐弃用，不建议继续使用 名词解释NDC：归一化设备坐标(Normalized Device Coordinates)","categories":[],"tags":[{"name":"Unity Shader","slug":"Unity-Shader","permalink":"http://yoursite.com/tags/Unity-Shader/"}],"keywords":[]},{"title":"Shader学习3——Unity Shader","slug":"图形学/Shader学习2_Unity_Shader","date":"2020-03-13T14:22:14.000Z","updated":"2020-09-14T03:01:41.812Z","comments":true,"path":"2020/03/13/图形学/Shader学习2_Unity_Shader/","link":"","permalink":"http://yoursite.com/2020/03/13/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shader%E5%AD%A6%E4%B9%A02_Unity_Shader/","excerpt":"","text":"Unity Shader1. Unity 中的shaderShader模板Unity为我们提供4种unity Shader 模板 Standard Surface Shader 产生一个包含了标准光照模型的表面着色器模板。 Unlit Shader 产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器。 Image Effect Shader 为我们实现各种屏幕后处理效果提供一个基本模板。 Compute Shader 产生一种特殊的Shader文件，这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算。 2. ShaderLabUnity中，Unity Shader都是使用ShaderLab来编写，ShaderLab是Unity提供的编写Unity Shader的说明性语言。 2.1 ShaderLab基础结构123456789101112Shader &quot;ShaderName&quot;&#123; properties&#123; &#x2F;&#x2F;属性 &#125; SubShader&#123; &#x2F;&#x2F;显卡A使用的子着色器 &#125; SubShader&#123; &#x2F;&#x2F;显卡B使用的子着色器 &#125; Fallback &quot;VertexLit&quot;&#125; Unity在背后会根据使用的平台来把这些结构编译成真正的代码和Shader文件，开发者只需要和Unity Shader打交道。 2.2 ShaderLab结构详解2.2.1 Shader名字ShaderLab 文件第一行，指定Shader的名字，通过斜杆(“/”)，可控制Unity Shader在材质面板中的位置，如： 1Shader &quot;Custon&#x2F;MyShader&quot; 则Shader所在位置： 2.2.2 PropertiesProperties语义块包含一些列属性，这些属性会出现在材质面板上。 12345Properties&#123; Name1(&quot;display name1&quot;, PropertyType1) &#x3D; DefaultValue1 Name2(&quot;display name2&quot;, PropertyType2) &#x3D; DefaultValue2 ...&#125; 属性名通常以下划线”_”开头，定义了这些属性后，即可在材质面板调节各种材质属性。使用每个属性的名字(Name) 可在Shader中访问它们。 每种属性都需要指定类型（PropertyType），以及赋予默认值，常用属性如下： 属性类型 默认值定义语法 例子 Int number _Int(“Int”, Int) = 2 Float number _Float(“Int”, Float) = 2 Range(min, max) number _Range(“Range”, Range(0.0, 10.0)) = 1.5 Color (number,number,number,number,) _Color(“Color”, Color) = (255,255,255,255) Vector (number,number,number,number,) _Vector(“Vector”, Vector) = (1, 1, 1 ,1) 2D “defaulttexture”{} _2D(‘2D’, 2D) = “”{} Cube “defaulttexture”{} _Cube(‘Cube’, Cube= “white”{} 3D “defaulttexture”{} _3D(‘3D’, 3D) = “black”{} 2.2.3 SubShader每个Unity Shader文件可包含至少一个SubShader。当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择一个能够在目标平台运行 的SubShader。假如没有一个SubShader支持的话，Unity会使用Fallback语义指定的Unity Shader。 原因：不同显卡能力性能不同，比较老的显卡可能支持的操作指令数量较少，高级的显卡可支持的指令数较多，故而我们希望程序能在旧的显卡上运行，又能在高级的显卡上有更好的体验。 SubShader语义块通常如下： 123456789101112SubShader&#123; &#x2F;&#x2F;可选 [Tags] &#x2F;&#x2F;可选 [RenderSetup] Pass&#123; &#125; Pass&#123; &#125; ...&#125; SubShader中定义了一系列Pass以及可选的转态([RendetSetup])和标签([Tags])。每个Pass定义了一次完整的渲染流程，我们应尽量使用小数目Pass，太多Pass会使渲染性能下降。 状态设置 ShaderLab提供了一系列渲染状态的设置指令，从而设置显卡的各种状态，常用渲染状态如下： 状态名称 设置指令 解释 Cull Cull Back\\ Front\\ Off 设置剔除模式：剔除背面/正面/关闭剔除 ZTest ZTest Less Greater\\ LEqual\\ GEqual\\ Equal\\ NotEqual\\ Always 设置深度测试时使用的函数 ZWrite ZWrite On\\ Off 开启/关闭深度写入 Blend Blend SrcFactor DstFactor 开启并设置混合模式 在SubShader块中设置上述渲染状态时，将会应用到所有的Pass，假如不希望这样，只想作用于特定Pass，可以再Pass语义块中单独进行设置。 SubShader的标签 SubShader的标签(Tags)是一个键值对(Key/Value Pair)，它的键和值都是字符串类型。这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：SubShader希望如何、以及何时渲染这个对象。 标签结构如下： 1Tags&#123; &quot;TagName1&quot; &#x3D; &quot;Value1&quot; &quot;TagName2&quot; &#x3D; &quot;Value2&quot;&#125; SubShader的标签块支持的标签类型如下： 注意：上述标签只能在SubShader中声明，不能在Pass块中声明。 Pass语义块 Pass语义块的语义如下： 12345Pass&#123; [Name] [Tags] [RenderSetup]&#125; 定义Pass名字 1Name &quot;MyPassName&quot; 通过这个名字，可以在其他Unity Shader中使用该Pass： 1UsePass &quot;MyShader&#x2F;MYPASSNAME&quot; 这样就提高了代码的发用性，我们可以发现调用的过程中使用了大写的形式，这并不是写错，而是因为Unity内部会把所有的Pass的名称都转成大写，故而我们在使用UsePass时，必须使用大写的形式。 Pass标签Pass同样可以设置标签，它的标签不同于SubShader的标签，这些标签也是用于告诉渲染引擎如何来渲染该物体。以下是Pass中使用的标签类型： | 标签类型 | 说明 | 例子 || ——————— | —————————————————————————————— | ————————————————————- || LightMode | 定义该Pass在Unity的渲染流水线中的角色 | Tags{“LightMode” = “ForwardBase”} || RequireOptions | 用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串。目前Unity支持的选项有：SoftVegetation | Tags{“RequireOptions” = “SoftVegetation”} | 除了上面普通的Pass定义外，Unity Shader还支持一些特殊的Pass，以便进行代码复用或者实现更复杂的效果。 UsePass : 可以使用该命令来复用其他Unity Shader中的Pass。 GrabPass：该Pass负责抓取屏幕并将结果存储在一张纹理中，用于后续的Pass处理。 2.2.4 Fallback在ShaderLab语义块的最后，是一个Fallback指令，它告诉Unity如果上面的所有SubShader在这块显卡都不能运行，就使用这个最低级的Shader！！ 123Fallback &quot;name&quot; &#x2F;&#x2F;告诉显卡使用哪个Unity Shader&#x2F;&#x2F;或者Fallback Off 3. Unity Shader的形式3.1 表面着色器表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。它的代码量很少，但渲染代价比较大。当给Unity提供一个表面着色器的时候，Unity需要在背后做很多工作，把它转换成顶点/片元着色器。 好处：Unity对顶点/片元着色器更高一层的的抽象，为我们处理很多光照细节，我们不需要操心这些事。 简单的表面着色器如下： 123456789101112131415Shader &quot;Custom&#x2F;Simple Surface Shader&quot;&#123; SubShader&#123; Tags&#123;&quot;RenderType&quot; &#x3D; &quot;Opaque&quot;&#125; CGPROGRAM #pragma surface surf Lambert struct Input&#123; float4 color : COLOR; &#125;; void surf(Input IN, input SurfaceOutput 0)&#123; o.Albedo &#x3D; 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 上面的程序中，表面着色器被定义在SubShader语义块中的CGPROGRAM和ENDCG中(而不是Pass中)，因为表面着色器不需要开发者关心使用多少个Pass以及每个Pass如何渲染，这些事情都交给Unity去完成就好了。CGPROGRAM和ENDCG之间的代码是使用CG/HLSL编写的，我们需要把CG/HLSL语言嵌套在ShaderLab语言中注意：此处的CG/HLSL是Unity封装过的，与标准的CG/HLSL几乎一样，只有细微差别，一些原生的函数可能Unity并没有提供。 3.2 顶点/片元着色器在Unity中，我们可以使用CG/HLSL语言来编写顶点/片元着色器（Vertex/Fragment Shader）。它更加复杂，但也更加灵活了。 12345678910111213141516Shader &quot;Custom&#x2F;Simple VertexFragement Shader&quot;&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v:POSITION):SV_POSITION&#123; return mul(UNITY_MATRIX_MVP, v); &#125; float4 frag():AV_Target&#123; return fixed4(1.0, 0.0, 0.0, 1.0) &#125; ENDCG &#125; &#125;&#125; 代码同样写在CGPROGRAM和ENDCG之间，但顶点/片元着色器是写在Pass语义块内的，而不是Subshader内，因为我们需要自己定义每个Pass。因此我们需要编写更多的代码，但也因如此变得灵活性更高，可以控制渲染的实现细节。 3.3 固定函数着色器对于一些比较老旧的设备，它们不支持可编程管线着色器，此时需要使用固定函数着色器（Fixed Function Shader），这样的着色器往往只能完成一些简单的效果。 12345678910111213Shader &quot;Tutorial&#x2F;Basic&quot;&#123; Properties&#123; _Color (&quot;Main Color&quot;, Color) &#x3D; (1, 0.5, 0.5, 1) &#125; SubShader&#123; Pass&#123; Material&#123; Diffuse [_Color] &#125; Lighting On &#125; &#125;&#125; 对于固定函数着色器来说，我们需要完全使用ShaderLab的语法(即使用ShaderLab的渲染设置命令)来编写，而不是CG/HLSL。","categories":[],"tags":[{"name":"Unity Shader","slug":"Unity-Shader","permalink":"http://yoursite.com/tags/Unity-Shader/"}],"keywords":[]},{"title":"Gitee + PicGo实现markdown图床","slug":"markdown使用/markdown图床搭建","date":"2020-03-12T06:06:00.000Z","updated":"2020-07-31T02:30:06.322Z","comments":true,"path":"2020/03/12/markdown使用/markdown图床搭建/","link":"","permalink":"http://yoursite.com/2020/03/12/markdown%E4%BD%BF%E7%94%A8/markdown%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/","excerpt":"","text":"前言：使用markdown记录笔记，有时候会插入图片，使用本地图片的话，上传到各个博客平台每次都得一个个复制粘贴上去，基本没有移植性可言，使用图床统一存储就没有这样的烦恼了。 这里我们使用 码云(gitee)+ PicGo的方式来搭建图床。 1.安装 PicGo gitee-uploader插件 首先需要下载PicGo安装包，安装完成后打开软件主界面 拉到最下方，找到【插件设置】，搜索关键词gitee 有两个插件可供选择，功能相同，这里我们选择gtiee-uploader 1.1.2 温馨提示：安装此插件需先安装node.js环境，未安装的先安装一下。 2.创建图床仓库这里假设已经有码云账号了，没有的话可以先注册。 点击头像左侧+号，新建仓库 3.配置PicGo步骤1安装完gitee-uploader插件后，左侧菜单会出现gitee选项，点击它进行配置 repo: 用户名/仓库名，可以在刚创建的仓库里进行复制 branch :分支，这里填master token: 填码云私人令牌，下面介绍生成方法 path: 图片在仓库中的存储路径，这里我们存储在img customPath：提交消息，这一项和下一项customURL都不用填。在提交到码云后，会显示提交消息，插件默认提交的是 Upload 图片名 by picGo - 时间 获取token 点击头像，进入设置 找到【私人令牌】 点击【生成新的令牌】，勾上projects，点击提交 生成的一长串数字就是你的token,填写到刚才的配置中去，点击【确定】 4.完成 可以随便找一张图片，拖拽到上传区，或者用截图后，点击【剪贴板图片上传】，即可进行上传，上传完成后会自动添加到你剪贴板，可以根据需要选择返回的链接格式，直接在markdown中进行粘贴即可。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"git 备忘","slug":"git/git相关","date":"2020-02-10T13:34:18.000Z","updated":"2020-07-31T02:30:06.299Z","comments":false,"path":"2020/02/10/git/git相关/","link":"","permalink":"http://yoursite.com/2020/02/10/git/git%E7%9B%B8%E5%85%B3/","excerpt":"","text":"初始化仓库 创远程仓库 在项目中git init 关联远程仓库 git remote add origin 地址 git add . git commit -m “内容” 更新项目，避免与远程仓库冲突 1git pull --rebase origin master ```git push origin master 123456 ### 反斜杠错误&#39;\\\\&#39;git 2.24版本存在这样的问题，更新git项目中的子模块会报错，导致不成功，错误如下 error: filename in tree entry contains backslash: ‘\\’ 1234567891011![](http:&#x2F;&#x2F;lgx.itengshe.com&#x2F;20200210214233-1.png)**解决办法：**- 升级git版本到2.25或者降到2.23都可解决此问题- 禁用[core.protectNTFS](https:&#x2F;&#x2F;translate.googleusercontent.com&#x2F;translate_c?depth&#x3D;1&amp;hl&#x3D;zh-CN&amp;prev&#x3D;search&amp;rurl&#x3D;translate.google.com&amp;sl&#x3D;en&amp;sp&#x3D;nmt4&amp;u&#x3D;https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-config&amp;xid&#x3D;17259,15700022,15700186,15700190,15700259,15700271,15700302&amp;usg&#x3D;ALkJrhgI-ExxieOLS4BgBJejN9E-jIKJ3w#Documentation&#x2F;git-config.txt-coreprotectNTFS) ： &#96;git config --global core.protectNTFS false&#96;### 设置提交模板 git config commit.template [模板文件名] 123456### 删除分支先切到master git checkout master 12查看本地已有的和远端的所有分支 git branch -a 12#### 删除远程分支 git push origin —delete 分支名 12#### 删除本地分支 git branch -d 分支名//有可能会提示使用-D的命令git branch -D 分支名 12345678### 远端分支已经删除，本地依旧能看到1.使用git branch -a查看本地和远程分支，会发现有些已经在远程仓库删除的分支，本地依旧能看到2.查看本地分支与远程分支的关系 git remote show origin 123.删除远程仓库已经不存在的分支 git remote prune origin 12345678910111213141516### TortoiseGit设置ssh方式1.进入tortoise的设置界面--&gt;点击 &#96;Re-run First Start Wizard&#96;![](http:&#x2F;&#x2F;lgx.itengshe.com&#x2F;20200217000941-1.png)一直next(下一步)，直到 Authentication an credential store界面，设置ssh为OpenSSH方式，完成![](http:&#x2F;&#x2F;lgx.itengshe.com&#x2F;20200217001227-1.png)### 已提交的项目添加.gitignore文件1.清除本地项目缓存 git rm -r —cached . 122.新建.gitignore文件 touch .gitignore 123.再次提交所有文件 git add .git commit -m “add ignore” 124.提交到远端 git push 123456### 修改本地以及远程分支名称1. 重命名本地分支 git branch -m oldBranch newBranch 122. 删除远端分支 git push —delete origin oldBranch 123. 将本地已重命名的分支推到远端 git push origin newBranch 124. 切换到新分支 git checkout newBranch 125. 关联本地和远端的分支 git branch —set-upstrean-to=origin/newBranch 1234567891011 ### tag操作- 列出tag&#96;&#96;&#96;gitgit tag -lgit tag -l &quot;v1.1.1*&quot; &#x2F;&#x2F;筛选出v1.1.1开头的taggit ls-remote -t &#x2F;&#x2F;查看远端tags 创建tag 1234git tag -a [tagName] -m &#39;[注释]&#39;&#x2F;&#x2F;给某次提交加taggit tag -a [tagName] [commitid] 推送tag到远端 1234git push origin [tagName]&#x2F;&#x2F;推送所有本地tag到远端git push origin --tags 删除tag 删除本地tag 1git tag -d [tagName] 删除本地所有tag 1234git tag -l|xargs git tag -d&#x2F;&#x2F;拉取远端所有taggit fetch origin --prune 删除远端tag 1234&#x2F;&#x2F;方式一git push origin :refs&#x2F;tags&#x2F;[tagName]&#x2F;&#x2F;方式二git push origin --delete [tagName]","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}]},{"title":"lua","slug":"lua使用记录","date":"2020-01-09T13:51:43.000Z","updated":"2020-07-31T02:30:06.321Z","comments":true,"path":"2020/01/09/lua使用记录/","link":"","permalink":"http://yoursite.com/2020/01/09/lua%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"记录使用lua过程中遇到的问题","text":"记录使用lua过程中遇到的问题 字符串操作截去字符串首尾空格1string.gsub(str, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;) --截掉前后空格 获取指点年月有多少天12345678910111213function getDayByYearMonth(_year, _month) local _curYear &#x3D; tonumber(_year) local _curMonth &#x3D; tonumber(_month) if not _curYear or _curYear &lt;&#x3D; 0 or not _curMonth or _curMonth &lt;&#x3D; 0 then return end local _curDate &#x3D; &#123;&#125; _curDate.year &#x3D; _curYear _curDate.month &#x3D; _curMonth + 1 _curDate.day &#x3D; 0 local _maxDay &#x3D; os.date(&quot;%d&quot;,os.time(_curDate)) return _maxDayend","categories":[],"tags":[],"keywords":[]},{"title":"vue笔记","slug":"javascripts/vue","date":"2020-01-03T14:00:00.000Z","updated":"2020-07-31T02:30:06.312Z","comments":true,"path":"2020/01/03/javascripts/vue/","link":"","permalink":"http://yoursite.com/2020/01/03/javascripts/vue/","excerpt":"","text":"使用class样式1.数组1&lt;h1 :class &#x3D; &quot;[&#39;red, &#39;thin&#39;]&quot;&gt;&lt;&#x2F;h1&gt; 2.数组中使用三元表达式1&lt;h1 :class &#x3D; &quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;&lt;&#x2F;h1&gt; 3.数组中嵌套对象1&lt;h1 :class &#x3D; &quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;:isactive&#125;]&quot;&gt;&lt;&#x2F;h1&gt; 4.直接使用对象1&lt;h1 :class &#x3D; &quot;&#123;red:true, thin:true, active:true&#125;&quot;&gt;&lt;&#x2F;h1&gt; 使用内联样式1.直接在元素上通过:style的形式，书写样式对象 1&lt;h1 :style &#x3D; &quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;:&#39;40px&#39;&#125;&quot;&gt;文字&lt;&#x2F;h1&gt; 2.将样式对象定义在data中，并直接引用到:style中","categories":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}]},{"title":"npm","slug":"npm","date":"2020-01-03T13:51:43.000Z","updated":"2020-03-17T14:54:06.294Z","comments":true,"path":"2020/01/03/npm/","link":"","permalink":"http://yoursite.com/2020/01/03/npm/","excerpt":"记录使用npm过程中遇到的问题，免得再遇到时还到处搜索","text":"记录使用npm过程中遇到的问题，免得再遇到时还到处搜索 配置npm转到淘宝镜像安装npm后，默认是使用国外镜像的，所以不翻墙速度简直龟速，使用淘宝镜像就比较快了，切换方法如下： 1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; 且回原来是： 1npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F; 查看当前npm使用哪个源，则用这个命令 1npm config get registry","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}],"keywords":[]},{"title":"hexo笔记","slug":"hexo/hexo笔记","date":"2020-01-03T10:51:43.000Z","updated":"2020-07-31T02:30:06.310Z","comments":true,"path":"2020/01/03/hexo/hexo笔记/","link":"","permalink":"http://yoursite.com/2020/01/03/hexo/hexo%E7%AC%94%E8%AE%B0/","excerpt":"玩hexo过程中遇到的坑","text":"玩hexo过程中遇到的坑 本文主要参考自 https://chaooo.github.io/article/20161229.html，主要用来记录hexo搭建的整个过程，方便后面查看。 1.hexo安装在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.1.hexo 初始化安装 hexo 1npm install -g hexo-cli 在你想要存放该博客项目的目录下，执行以下命令，这两步都比较耗时，因为要下载许多文件 12hexo initnpm install 先预览一下效果 12hexo generatehexo server 上面命令可简化成如下： 12hexo ghexo s 运行成功后，即可在浏览器输入localhost:4000即可看到效果。 1.2.部署到远端我们这里以gitee码云作为远端进行部署，在根目录下找到_config.yml，添加以下代码 12345678# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: &#39;git&#39; repository: #github: git@github.com:lingengxiong&#x2F;lingengxiong.github.io.git gitee: git@gitee.com:lingengxiong&#x2F;lingengxiong.git branch: master 假如需要部署到多个远端，只需要在repository中配置多个地址即可。 配置完成后，安装deployer插件，该插件用来将生产的静态文件部署到远端仓库 1npm install hexo-deployer-git --save 安装完成即可生产静态文件，继而推送到远端 12hexo generatehexo deploy 温馨提示：第一次使用git时会弹出输入框，此时输入git仓库的用户名和密码即可。 2.hexo 主题安装尝试了很多种主题，最后决定用BlueLake，一方面是因为布局功能都很符合自己的需求，另一方面则是挺好看的 2.1.安装安装主题和渲染: 1$ git clone https:&#x2F;&#x2F;github.com&#x2F;chaooo&#x2F;hexo-theme-BlueLake.git themes&#x2F;BlueLake Blue是基于jade和stylus写的，所有需要安装hexo-renderer-jade和hexo-renderer-stylus 12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 切到themes/BlueLake，下载主题所需要的库 12$ cd themes&#x2F;BlueLake$ npm install 2.2.启用主题要使用刚下载好的主题，只需要修改根目录下_config.yml配置文件，找到theme字段，修改为BlueLake 1theme: BuleLake 依次执行以下命令，然后打开localhost:4000就可以看效果了 123hexo cleanhexo ghexo s 2.3 配置目前的整个工程都还是比较原始的状态，我们的工作就是添加我们自己的东西进去了。 2.3.1 配置网站头部显示文字打开_config.yml，找到： 12345678# Sitetitle: Hexosubtitle: &#39;&#39;description: &#39;&#39;keywords:author: John Doelanguage: entimezone: &#39;&#39; title和subtitle分别是网站主标题和副标题，会显示在网站头部； description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO； author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.3.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下： 1language: zh-CN 2.3.3 添加about页about页是一个介绍自己的页面，可以在上面写一些自己的联系方式或者其他平台博客链接之类 在根目录下运行命令： 1hexo new page &#39;about&#39; 打开主题_config.yml，补充详细信息： 1234567891011121314# About pageabout: photo_url: ## Your photo e.g. http:&#x2F;&#x2F;cdn.chaooo.top&#x2F;blog&#x2F;themeauthor.jpg items: - label: email url: ## Your email with mailto: e.g. mailto:zhenggchaoo@gmail.com title: ## Your email e.g. zhenggchaoo@gmail.com - label: github url: ## Your github&#39;url e.g. https:&#x2F;&#x2F;github.com&#x2F;chaooo title: ## Your github&#39;name e.g. chaooo - label: weibo url: ## Your weibo&#39;s url e.g. http:&#x2F;&#x2F;weibo.com&#x2F;zhengchaooo title: ## Your weibo&#39;s name e.g. 秋过冬漫长 2.3.4 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录打开命令行，运行以下命令： 123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置： 1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.3.5 更换主题背景该主题目前有两种背景，深色和浅色，需要设置为深色只需要修改主题_config.yml 12# Theme tonedark: false #true&#x2F;false 2.3.6 添加文章版权信息修改主题_config.yml 12345# Theme tone#Copyrightcopyright: enable: true #true&#x2F;false describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件： 1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置： 1local_search: true 2.5 首页添加文章置顶在根目录下打开命令行窗口安装： 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 假如文章需要添加置顶，只需要在Front-matter中加上top: true即可 123456---title: BlueLake博客主题的详细配置tags: [hexo,BlueLake]categories: Hexo博客折腾top: true--- 2.6 修改站点图标 站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 3. 笔记仓库与博客项目分离我们可以看到目前文章放在source/_posts目录下，我们不可能每次写笔记都跑到这里写，这里我采用git子模块的形式，我们平常笔记在自己的笔记仓库里写，写完推到远端仓库，更新博客只需要先拉一下笔记仓库里的文件，再更新到线上博客。这样做博客项目只负责发布，不负责编辑笔记。我的博客笔记放在https://gitee.com/lingengxiong/blog-note.git 3.1添加子模块的方法1git submodule add 仓库名 路径 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone） 3.2删除子模块方法submodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。 故先把source/_post文件夹删除，然后执行 1git submodule add https:&#x2F;&#x2F;gitee.com&#x2F;lingengxiong&#x2F;blog-note.git source&#x2F;_posts&#x2F; 这样我们已经成功把笔记仓库引入博客项目内，以后只需要定时拉取最新内容进行发布即可 3.3 README.md等文件不生成博客内容我们引入的博客仓库中包含有该仓库的README.md文件，这些文件不需要生成文章，可以修改根目录_config.yml文件进行屏蔽： 1skip_render: [&#39;_posts&#x2F;**&#x2F;README.md&#39;,&#39;_posts&#x2F;**&#x2F;README.en.md&#39;] 4.hexo备份与恢复3.1.备份在公司好不容易把工程搭建起来，却到了下班的时候，回家想继续搞岂不是蛋疼得再配置一遍？这可不行，而且要是电脑坏了怎么办，前面的时间岂不是白费，所以肯定得做好备份~ 最开始想到的是用传统的git 进行备份，但在网上搜了一下，发现前辈们早已想出更懒的办法，并做成插件—-hexo-git-backup，依旧是备份到github，但用起来更加便捷。 首先安装该插件 1npm install hexo-git-backup --save 然后到你的博客根目录的_config.yml配置文件中添加如下配置： 12345678#备份博客backup: type: git theme: hexo-theme-yilia-master message: Back up my blog repository: github: git@github.com:lingengxiong&#x2F;lingengxiong.github.io.git，backup gitee: git@gitee.com:lingengxiong&#x2F;lingengxiong.git,backup 参数解释： theme：你要备份的主题名称 message：自定义提交信息 repository：仓库名，注意仓库地址后面要添加一个分支名，比如我就创建了一个 backup 分支 我这里备份了两份，一份到github，另一份备份到码云，不需要的只配置一个即可，实际上我们是在放博客静态文件的仓库上拉了一个backup分支，如果你不放心，也可新建一个仓库用来存放整个博客工程 实际上，并不是整个工程都需要备份的，只需要备份关键几个文件夹即可，其余到时再次生成即可 1.生成.gitignore文件 1touch .gitignore 2.输入要忽略的文件及文件夹 1234567.DS_StoreThumbs.dbdb.json.lognode_modules&#x2F;public&#x2F;.deploy&#x2F; 3.最后用以下命令备份博客： 1hexo backup 或者简写： 1hexo b 2.恢复已经备份好的hexo，到新发电脑只需要使用以下步骤即可恢复，无需从头开始配置，这里以我的仓库地址为例，实际情况改成自己的地址即可 1.先安装hexo npm install -g hexo-cli 2.把存在远端的备份git clone下来 git clone https://gitee.com/lingengxiong/lingengxiong.git 这里备份在backup分支，可以直接下载对应分支 git clone -b backup https://gitee.com/lingengxiong/lingengxiong.git 3.下载所需要的库文件 npm install 4.下载推送工具deployer npm install hexo-deployer-git 5.接下来就可以用熟悉的命令生成博客站点了 123hexo cleanhexo ghexo s 正常情况下以上步骤完成后即可在浏览器用localhost:4000打开你的博客 继而发布到远端 hexo d 5.添加评论系统gitalk5.1申请第三方评论系统很多，如 多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论、基于Github Issue的GITALK 但国内的有写时不时就没法用了，所以这里还是使用gitalk 1.申请GitHub Application Application name： 应用名称，随便起 Homepage URL： 网站URL，对应自己博客地址 Application description ：描述，随意 Authorization callback URL：# 网站URL，博客地址就好 点击注册，页面会出现其中Client ID和Client Secret在后面的配置中需要用到 5.2 配置在主题_config.yml配置： 123456789101112131415161718comment: gitalk: enable: true ## If you want to use Gitment comment system please set the value to true. owner: lingengxiong ## Your GitHub ID, e.g. username repo: blogtalk ## The repository to store your comments, make sure you&#39;re the repo&#39;s owner, e.g. gitalk.github.io client_id: ## GitHub client ID, e.g. 75752dafe7907a897619 client_secret: ## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50 admin: lingengxiong ## Github repo owner and collaborators, only these guys can initialize github issues. language: zh-CN ## Language pagerDirection: last # Comment sorting direction, available values are last and first. 注意: 1.repo ,存放评论的仓库，这里我们新建一个名为blogtalk的仓库，这里只需要填入blogtalk即可，而不是完整地址 5.3 踩坑5.3.1 Error:Not Found 发现是gittalk中的信息填写错了，name随便写；Homepage URL是你的仓库的名字，Authorization callback URL如果你指向了新 的域名就填新的，比如说我指向了域名http://blog.lgx123.cn/；否则也写仓库的名字就可以。 5.3.2未找到相关Issues进行评论 1.理想状态登录一下github账号即可，假如点击后返回首页，那应该是配置有问题，检测gitalk各项参数 2.配置完成未发布到线上，使用localhost:4000访问，也会出现这种情况，点击登录会跳到线上工程地址，此时只需要试试发布到线上","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[]},{"title":"Android笔记","slug":"android/android笔记","date":"2019-12-28T09:00:00.000Z","updated":"2020-07-31T02:30:06.298Z","comments":true,"path":"2019/12/28/android/android笔记/","link":"","permalink":"http://yoursite.com/2019/12/28/android/android%E7%AC%94%E8%AE%B0/","excerpt":"记录一下Android学习过程","text":"记录一下Android学习过程 Intent一般可用于启动 活动、启动服务、发送广播等场景 四大组件 —— Activity活动的启动模式活动有4种启动模式，分别是standard ,singleTop, singleTask, singleInstance 可以在AndroidMainfest.xml中通过标签指定android:launchMode属性来选择启动模式。 1.standard默认的启动模式，此模式下系统不在乎返回栈中是否存在，每次启动都创新的活动实例 2.singleTop此模式下，在启动活动时发现返回栈的栈顶已经是该活动，则直接使用，不再创建新的活动实例。但如果该活动不位于栈顶位置，则再次启动该活动时，还是会创建新的实例 3.singleTask使用此模式，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没发现该活动实例，就会创建一个新的活动实例。 4.singleInstance此模式不同于以上3种模式，指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果 singleTask 模式指定了不同的 taskAffinity，也会启 动一个新的返回栈）。 应用场景：假设我们的程序中有一个 活动是允许其他程序调用的 ，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，就需要用此模式， 在这种模式下会有一个单独的返回栈来管理这个活 动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实 例的问题 四种布局1.LinearLayouta.线性布局，将它包含的控件在线性方向上一次排列 b.排列方向：可水平方向（vertical)，垂直方向排列(horizontal)，修改方法： 如果LinearLayout的排列方向是horizontal，内部控件宽度不能使用math_parent，会占满整个水平方向，同理vertical时内部控件高度不可使用match_parent。 2.RelativeLayout相对布局，与LinearLayout相比，更加随意一些，它能通过相对定位的方式让控件出现在布局的任何位置，可相对于整个容器，也可相对于某个控件 3.FrameLayout这种布局没有任何定位方式，所有控件都会摆放在布局的左上角（应用场景不多） 4.TableLayout使用表格方式来排列控件（不常用） 单位和尺寸px 像素，屏幕中可以显示的最小元素单位 pt 磅数的意思，1磅等于1/72英尺，一般用作字体的单位 dp 密度无关像素，也称dip，和px相比，它再不同密度的屏幕中的显示比例保持一致 sp 可伸缩像素，采用与dp同样的设计理念，解决字体大小适配问题 密度 Android中密度就是屏幕每英寸所包含的像素数，以dip为单位。 比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果 它的分辨率是 320x480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640*960， 那这个屏幕的密度就是 320dpi，因此密度值越高的屏幕显示的效果就越精细。 Android 规定，在160dpi的屏幕上，1dp等于1px，而在320dpi的屏幕上，1dp等于2px. 因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的 显示比例保持一致。 ​ 四大组件 ——- Broadcast ReceiveAndroid中的广播分为两种类型，即 标准广播 和 有序广播 1.标准广播标准广播是一直完全异步执行的广播，广播发出后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此他们之间没有任何的先后顺序可言。这种广播效率比较高，也意味着它无法被截断 2.有序广播有序广播是一种同步执行的广播，在广播发出后，同一时刻只会有一个广播接收器能接收到这条消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。 此时广播接收器是有先后顺序的，优先级高的广播接收器可以优先收到广播消息，也可截断正则传递的广播，使后面的广播接收器无法接收广播消息 3.注册广播分两种方式：在代码中注册（动态注册）、在AndroidMainifest.xml中注册（静态注册） 持久化计算Android系统主要提供三种数据持久化功能——-文件存储、SharedPreference存储以及数据库存储 1.文件存储不对存储的内容进行任何的格式化出来，所有数据原封不动存在文件中（适合存储一些简单的文本数据或者二进制数据），文件默认存储到/data/data//file/目录下 2.SharedPreferences存储使用键值对的方式来存储数据，较文件存储方便得多，而且支持多种不同数据类型的存储，即如果存入的数据类型是整型，读取出来的数据也是整形的 存储前，先获得SharedPreferences对象，Android中主要提供三种方法得到SharedPreferences对象 2.1. getSharedPreferences​ Context类中的getSharedPreferences(fileName，操作模式)方法 ​ 第一个参数用于指定文件名称，指定文件不存在则会创建一个，SharedPreferences文件存放在/data/data//shared_prefs/目录下 ​ 第二个参数用于指定操作模式，主要有两种模式可以选 择，MODE_PRIVATE 和 MODE_MULTI_PROCESS。MODE_PRIVATE 仍然是默认的操 作模式，和直接传入 0 效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences文件进行读写。MODE_MULTI_PROCESS 则一般是用于会有多个进程中 对同一个 SharedPreferences 文件进行读写的情况。类似地，MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE 这两种模式已在 Android 4.2 版本中被废弃 2.2.getSharedPreferences​ Activity类中的getSharedPreferences()方法 ​ 只接受一个操作模式参数，因为使用此方法时会自动将当前的类名作为SharedPreferences的文件名 2.3.getDefaultSharedPreferences​ PreferencesManager类中的getDefaultSharedPreferences()方法 ​ 这是一个静态方法，接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences对象 a.向SharedPreferences文件中存储数据分三步实现 1.调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象 2.向SharedPreferences对象中添加数据，比如添加布尔类型的数据就是用putBoolean方法 3.调用commit()方法，将添加的数据提交，从而完成数据存储操作 b.从SharedPreferences文件中读取数据使用SharedPreferences的get方法来对存储数据进行读取，每种get方法对应SharedPreferences.Editor中的一种put方法，例如读取布尔值，就使用getBoolean()方法 get方法接受两个参数，第一个是“键”，第二个是 默认值（即传入键找不到对应的值是，返回什么样的默认值） 3.SQLite数据库存储SQLite是一筐轻量级的关系型数据库，运算速度快，占用资源少，通常只需要几百k的内存就够了 Android提供了SQLiteOpenHelper帮助类，这是一个抽象类，有两个抽象方法—-onCreate() 和onUpgrade()， 使用时我们需要创建一个帮助类继承SQLiteOpenHelper，并在自己的帮助类中重写两个抽象方法，然后在这两个方法中区实现创建、升级数据库的逻辑 SQLiteOpenHelper中有两个构造方法可以重写，一般使用参数较少的的方法，此方法接收四个参数； 1.Context 2.数据库名 3.允许我们在查询数据的时候返回一个自定义的Cursor，一般传入null 4.当前数据库的版本号 3.1创建数据库：构建出SQLiteOpenHelper实例后，再调用getReadableDatabase()或getWritableDatabase()就能创建出数据库了，数据库文件存放在/data/data//database/目录下 3.2升级数据库只需要在构建SQLiteOpenHelper时传入的高于之前的版本号，就会调用onUpgrade() 3.3SQLite数据类型integer 整型 real 浮点型 text 文本型 blob 二进制型 四大组件 —— Content Provider主要用于在不同应用程序之间实现数据共享的功能，它的完整机制允许程序访问另一个程序中的数据，同时又保证被访问数据的安全性。 使用内容提供器是Android实现程序共享数据的标准方式 1.访问其他程序中的数据​ 每个应用程序想要访问内容提供器中的共享数据，要借助ContentResolve类，可以通过Context中的getContentResolver()方法获得该类的实例 ContentResolver提供了对数据进行CRUD的操作方法，即 insert()添加数据 update()更新数据 delete()删除数据 query()查询数据 这几个方法都只需要传入Uri参数，即内容URI，内容URI给内容提供器中的数据建立了唯一的标识，由两部分组成，即权限（authority）和路径（path） ​ a.权限用于对不同的应用程序做区分的，为了避免冲突，都会采用程序包名的方式来进行命名，如com.example.app，则该程序对应的权限命名为com.example.app.provider ​ b.路径用于对同一应用程序中不同的表做区分，通常加到权限后面，比如某个程序的数据库中有两张表，table1和table2，此时路径分别命名为/table1和/table2，与权限结合起来，内容URI就变成 com.example.app.provider/table1 和 com.example.app.provider/table2 ​ 在字符串头部加上协议声明，得到最标准的URI的格式写法如下： content://com.example.app.provider/table1 content://com.example.app.provider/table2 ​ 得到URI字符串后，将其解析成Uri对象才可作为参数传入增删改查方法中 ​ Uri uri = Uri.pase(“content://com.example.app.provider/table1”) 异步消息处理机制Android中的异步消息处理主要由四个部分组成，Message、Handler、MessageQueue、和Looper。 1.MessgaeMessage是线程之间传递的消息，可在内部携带少量的信息，用于不同线程之间交换数据。 例如what字段，除此之外arg1和arg2字段可携带一些整型数据，obj字段携带一个Object对象 2.Handler顾名思义就是处理者的意思，主要用你发送和处理消息。 发送消息一般是使用Handler的sendMessage()方法，发出的消息经过一系列辗转后，最终传递到Handler的handlerMessage()方法中。 3.MessageQueue消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象 4.LooperLooper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop()方法后，就会 进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取 出，并传递到 Handler 的 handleMessage()方法中。每个线程中也只会有一个 Looper 对象。 AsyncTaskAsyncTask 基于异步消息处理机制，Android帮我们做了很好的封装 AsyncTask是一个抽象类，使用它得用一个子类去继承它，继承时可以为AsyncTask类指定一个泛型参数。 1.Params​ 在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 2.Progress​ 后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为 进度单位。 3.Result​ 当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值 类型。 因此，一个最简单的自定义 AsyncTask 就可以写成如下方式： 1234class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;……&#125; 需要重写AsyncTask中的几个方法才能完成对任务的定制。 3.1.onPreExecute()​ 在后台任务开始之前调用，用于进行一些界面上的初始化，比如显示一个进度条对话框等 3.2.doInBackground(Params)​ 这个方法中的所有代码都会在子线程中运行，我们在这里处理所有耗时任务。任务完成后通过return语句来返回任务执行结果。如果AsyncTask的第三个泛型参数为void，就不返回执行结果。 ​ 注意：此方法中不可进行UI操作，如需更新UI元素，比如反馈当前任务进度，可以调用publishProgress(Progress …)方法来完成 3.3.onProgressUpdate(Progress…)​ 在后台任务中调用publishProgress(Progress…)方法后，会很快调用此方法，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值对界面元素进行相应的更新。 3.4.onPostExecute(Result)​ 当后台任务执行完毕并通过return语句进行返回时，这个方法就会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如提醒任务执行结果，以及关闭进度条对话框。 因此，一个比较完整的自定义 AsyncTask 就可以写成如下方式： 1234567891011121314151617181920212223242526272829303132333435363738class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; protected void onPreExecute() &#123; progressDialog.show(); &#x2F;&#x2F; 显示进度对话框 &#125; @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true) &#123; int downloadPercent &#x3D; doDownload(); &#x2F;&#x2F; 这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent &gt;&#x3D; 100) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; &#x2F;&#x2F; 在这里更新下载进度 progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;); &#125; @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); &#x2F;&#x2F; 关闭进度对话框 &#x2F;&#x2F; 在这里提示下载结果 if (result) &#123; Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot; Download failed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 四大组件 —— Service1. 定义一个服务基本的Service这样定义，onBind 是service中唯一一个抽象方法，所以必须在子类中进行实现 123456public class MyService extends Service&#123; @Override public IBinder onBind(Intent intent)&#123; return null; &#125;&#125; 让服务去处理一些事情，逻辑应该写在哪里呢？ 我们又重写onCreate()，onStartCommand()和onDestroy(）方法 123456789101112131415161718public class MyService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 以上三个新加的方法是每个服务中最常用的方法 oncreate() 在服务创建的时候调用 onStartCommand() 会在每次服务启动的时候调用 onDestroy() 会在服务销毁的时候调用 所以一旦服务启动就需要执行的动作，逻辑写在onStartCommand()方法中，在onDestroy中回收那些不需要的资源。 注意：每个服务都需要在AndroidManifest.xml中注册才能生效，这似乎是四大组件的共同特点。 123456789101112131415&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;com.example.servicetest&quot; android:versionCode&#x3D;&quot;1&quot; android:versionName&#x3D;&quot;1.0&quot; &gt; …… &lt;application android:allowBackup&#x3D;&quot;true&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_launcher&quot; android:label&#x3D;&quot;@string&#x2F;app_name&quot; android:theme&#x3D;&quot;@style&#x2F;AppTheme&quot; &gt; …… &lt;service android:name&#x3D;&quot;.MyService&quot; &gt; &lt;&#x2F;service&gt; &lt;&#x2F;application&gt;&lt;&#x2F;manifest&gt; 2. 启动和停止服务启动和停止服务主要借助Intent来实现 启动服务： 12Intent starIntent &#x3D; new Intent(this, MyService.class);startService(starIntent); 停止服务 12Intent stopIntent &#x3D; new Intent(this, MyService.class);stopService(stopIntent); 服务除了由活动来决定何时停止外，它也能自己让自己停下来，只需要服务自己调用stopSelf()方法即可 3.活动与服务进行通信​ 上面使用的方法在活动中启动和停止服务，但是服务启动后活动和服务基本没有关系了，无法得知服务的状态，如何才能让活动和服务联系更加紧密呢，让活动能随时指挥服务去执行某些任务？这就需要用到刚才那个我们必须要重写的onBind()方法了。 1234567891011121314151617public class MyService extends Service &#123; private DownloadBinder mBinder &#x3D; new DownloadBinder(); class DownloadBinder extends Binder &#123; public void startDownload() &#123; Log.d(&quot;MyService&quot;, &quot;startDownload executed&quot;); &#125; public int getProgress() &#123; Log.d(&quot;MyService&quot;, &quot;getProgress executed&quot;); return 0; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; ……&#125; ​ 这里我们在刚才建的MyService类中新建一个DownloadBinder类，并继承自Binder，这个类里提供方法供外部使用，我们这里提供了开始下载方法和获取下载进度的方法。然后在MyService中创建了DownloadBinder实例，并在onBind()方法中返回该实例。 ​ 如何在活动中调用服务里的方法呢？实际上当一个活动与服务绑定了之后，就可以调用Binder提供的方法了。 ​ 在活动中，我们首先创建ServiceConnection 匿名类，在里面重写onServiceConnected()方法和 onServiceDisconnected()方法，这两个方法分别在活动与服务成功绑定和解除绑定时调用。在onServiceConnecter()方法中，我们又向下转型得到的DownloadBinder实例，有了实例，我们就可以在活动中调用DownloadBinder中的任何public方法了。 12345678910111213private MyService.DownloadBinder downloadBinder;private ServiceConnection connection &#x3D; new ServiceConnection()&#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder &#x3D; (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125;&#125; ​ 别高兴太早，我们还没实现绑定呢。绑定方法如下: 12Intent bindIntent &#x3D; new Intent(this, Myservice.class);bindService(bindIntent, connection, BIND_AUTO_CREATE); ​ bindService()接收三个参数，第一个就是刚构建出来的Intent对象，第二个参数是前面创角出来的ServiceConnection实例，第三个参数是标志位，BIND_AUTO_CREATE表示在活动和服务进行绑定后自动创建服务，此时MyService中的onCreate()方法会执行，但onStartCommand()方法不会执行。 ​ 解绑方法比较简单： 1unbindService(connetion); ​ 注意：任何一个服务在整个应用程序范围内都是通用的，即任何一个活动都可与之绑定，而且绑定后他们都可以获取到相同的DownloadBinder实例。 4.服务的生命周期onCreate() ,onStartCommand(),onBind(),onDestroy()等方法都是在服务生命周期里可能回调的方法。 1.项目中任意位置调用Context的startService()方法，相应的服务就会启动，并回调onStartCommand()方法，假如服务没创建过，onCreat()方法会先于onStartCommand()方法执行。 2.服务启动后一直保持运行，直到stopService()或stopSelf()被调用 每次调用startService()方法，onStartCommand()方法就会调用一次，但每个服务只会有一个实例，无论调用多少次startService()，只需要调用一次stopService()或stopSelf()即可停止该服务 3.调用Context的bindService()方法，获取一个服务的持久连接，这是就会回调服务的onBind()方法，如果服务没创建过，onCreate()会先于onBind()方法执行。调用方可以获取onBind()方法里返回的IBinder对象的实例，这样即可与服务自由的通信了。调用方与服务之间的连接没有断开，服务就会一直保持运行状态。 4.调用startService()方法后，又调用stopService()方法，onDestroy()方法就会执行，此时服务已经销毁。类似的，调用bindService()方法后又调用unbindService()方法，onDestroy()方法也会执行。 5.Android系统机制规定，一个服务被启动或者被绑定后，就会一直处于运行状态，必须同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。 5.前台服务服务的系统优先级比较低，内存不足时，可能被回收，而前台服务就不会因为内存不足而被回收。 与普通服务最大区别：会有一个正在运行的图标在系统状态栏显示。下拉状态栏可以看到详细信息，类似通知的效果。 创建方法类似创建通知方法： 1234567891011121314151617public class MyService extends Service &#123; …… @Override public void onCreate() &#123; super.onCreate(); Notification notification &#x3D; new Notification(R.drawable.ic_launcher, &quot;Notification comes&quot;, System. currentTimeMillis()); Intent notificationIntent &#x3D; new Intent(this, MainActivity.class); PendingIntent pendingIntent &#x3D; PendingIntent.getActivity(this, 0, notificationIntent, 0); notification.setLatestEventInfo(this, &quot;This is title&quot;, &quot;This is content&quot;, pendingIntent); startForeground(1, notification); Log.d(&quot;MyService&quot;, &quot;onCreate executed&quot;); &#125; ……&#125; 网络1.使用HTTP协议访问网络​ Android 上发送HTTP请求有两种，1.HttpURLConnection和 2. HttpClient 1.1 HttpURLConnection先获取HttpURLConnection实例，new出一个URL对象，传入目标的网络地址，然后调一下openConnection()方法即可： 12URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);HttpURLConnection connection &#x3D; (HttpURLConnection)url.openConnection(); 得到HttpURLConnection的实例后，设置HTTP请求所使用的方法。常用方法：GET 和 POST ​ GET：表示希望从服务器获取数据 ​ POST :表示希望提交数据到服务器 1.1.1 GET写法如下： 1connection.setRequestMethod(&quot;GET&quot;); 设置连接超时、读取超时的毫秒，以及服务器希望得到的一些消息头等。根据自己实际情况进行编写： 12connection.setConnectTimeout(8000);connection.setReadTimeout(8000); 之后调取getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取 1InputStream in &#x3D; connection.getInputStream(); 最后调用disconnect()方法关闭HTTP连接： 1connection.disconnect(); 1.1.2 POST需要向服务器提交数据，采用POST的方式，数据之间用&amp; 123connection.setRequestMethod(&quot;POST&quot;);DataOutputStream out &#x3D; new DataOutputStream(connection.getOutputStream());out.writeBytes(&quot;username&#x3D;admin&amp;password&#x3D;123456&quot;); 1.2. 使用HttpClientHttpClient是Apache提供的HTTP网络访问接口，一开始就被引入Android API中，几乎可以完成与HttpURLConnection同样的效果，只是用法有较大的差别。 HttpClient是一个接口，无法创建它的实例，通常会创建一个DefaultHttpClient的实例： 1HttpClient httpClient &#x3D; new DefaultHttpClient(); 1.2.1 GET想发起一条GET请求，可以创建一个HttpGet对象，传入目标网络地址，然后调用HttpGet的execute()方法： 12HttpGet httpGet &#x3D; new HttpGet(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);httpClient.excute(httpGet); 1.2.2 POST使用POST请求比GET复杂一点，需创建HttpPost对象，并传入目标地址： 1HttpPost httpPost &#x3D; new HttpPost(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;); 1.然后通过一个NameValuePair集合来存放待提交的参数， 2.并将这个参数集合传入一个UrlEncodedFormEntity中， 3.然后调用HttpPost的setEntity()方法将构建好的UrlEncodedFormEntity传入 12345List&lt;NameValuePair&gt; params &#x3D; new ArrayList&lt;NameValuePair&gt;();params.add(new BasicNameValuePair(&quot;username&quot;,&quot;admin&quot;));params.add(new BasicNameValuePair(&quot;password&quot;,&quot;123456&quot;));UrlEncodedFormEntity entity &#x3D; new UrlEncodedFormEntity(params, &quot;utf-8&quot;);httpPost.setEntity(entity); 4.接下来就和HttpGet一样，调用HttpClient的execute()方法，并将HttpPost对象传入 1httpClient.execute(httpPost); 1.2.3 处理返回结果执行完上面的操作，会返回一个HttpResponse对象，包含服务器返回的所有信息。通常我们会先取出服务器返回的状态码，等于200说明请求和响应都成功了 123if (httpResponse.getStatusLine().getStatusCode() &#x3D;&#x3D; 200)&#123; &#x2F;&#x2F;请求、响应都成功&#125; 假如得到状态码200，则可调用getEntity()方法获取到一个HttpEntity实例，然后调用EntityUtils.toString()这个静态方法将HttpEntity转换成字符串即可： 12HttpEntity entity &#x3D; httpResponse.getEntity();String response &#x3D; EntityUtils.toString(entity); 假如返回数据中包含中文，EntityUtils.toString()方法会出现乱码，需要将字符集指定为utf-8： 1String response &#x3D; EntityUtils.toString(entity, &quot;utf-8&quot;); 基于位置的服务简称LBS，利用无线电通信网络或者GPS等定位方式，确定出移动设备所在的位置。安卓中使用LocationManager类就能实现。 1.LocationManager基本用法获取LocationManager实例，可以调用Context的getSystemService() 1LocationManager locationManager &#x3D;(LocationManager)getSystemService(Context.LOCATION_SERVICE); 接着需要选择一个位置提供器来确定设备当前的位置。Android中一般有三种位置提供器供选择，GPS_PROVIDER、NETWORK_PROVIDER 和 PASSIVE_PROVIDER 1.1 获取位置将选择好的内容提供器传入到getLastKnownLocation()方法中，就可以得到一个Location对象： 12String provider &#x3D; LocationManager.NETWORK_PROVIDER;Location location &#x3D; LocationManager.getLastKnownLocation(provider); Location对象中包含经度，纬度，海拔等一系列位置信息，我们从中取出想要的数据即可。 想要经度较高的数据，需要用GPS定位功能，使用之前需要先确定定位功能是否启用。 1List&lt;String&gt; providerList &#x3D; locationManager.getProviders(true); getProviders()方法传入true表示只有启用位置提供器才会被返回，之后再从providerList中判断是否包含GPS定位功能就行。 1.2 监听位置变化getLastKnownLocation() 方法可以获取设备当前位置信息，想要知道设备位置变化，可以使用LocationManager的requestLocationUpdates()方法，只需要传入一个LocatiionListener，配置几个参数即可: 1234567891011121314locationManager.requestLocationUpadtes(LocationManager.GPS_PROVIDER, 5000, 10, new LocationListener()&#123; @Override public void onStatusChanged(String provider, int status, Bundle extras) &#123; &#125; @Override public void onProviderEnabled(String provider) &#123; &#125; @Override public void onProviderDisabled(String provider) &#123; &#125; @Override public void onLocationChanged(Location location) &#123; &#125;&#125;) 参数一：位置提供器类型 参数二 : 监听位置变化的时间间隔，单位：毫秒 参数三：监听位置变化的距离间隔，以米为单位 参数四：LocationListener监听器 所以上面例子的效果是：监听GPS位置变化，每5秒检测一下，距离超过10米时，调用LocationListener的onLocationChanged()方法，把新的位置信息作为参数传入。 2. Geocoding API用法（反向地理编码）","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"webpack笔记","slug":"javascripts/webpack笔记","date":"2019-02-27T10:00:43.000Z","updated":"2020-07-31T02:30:06.318Z","comments":true,"path":"2019/02/27/javascripts/webpack笔记/","link":"","permalink":"http://yoursite.com/2019/02/27/javascripts/webpack%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天想了解一下webpack，但找了网上的一系列教程，都会或多或少出现一些不明报错，实在恼火，经过几番简化，终于用最简单的方法使用了webpack，在此记录一下 一.环境配置1.首先，安装Node.js，这里不赘述，未接触nmp的童鞋可以参考Node.js安装配置 2.在cmd中输入 1npm install webpack -g 3.在自己测试的位置创建一个新的文件夹，命名webpack_demo 4.进入刚刚所创建的文件夹webpack_demo，按住shift键同时点击鼠标右键(即打开cmd并进入webpack_demo文件夹) 5.在打开的命令窗口键入：npm init，根据提示填写信息，name表示项目名，version表示版本等等，不一一赘述了，也可使用默认值，一路回车即可，最后出现“is this ok?”时，敲击回车键，webpack_demo文件夹便生成了package.json文件夹 二.构建webpack项目1.在webpack_demo文件夹下创建webpack.config.js文件，此文件为webpack的配置文件。具体内容如下： 123456789&#x2F;&#x2F;webpack.config.jsmodule.exports&#x3D;&#123; entry:&#39;.&#x2F;src&#x2F;js&#x2F;entry.js&#39;, &#x2F;&#x2F;页面入口文件 &#x2F;&#x2F;输出文件 output:&#123; filename:&#39;index.js&#39;, &#x2F;&#x2F;输出文件名 path:__dirname+&#39;&#x2F;out&#39;, &#x2F;&#x2F;输出文件路径 &#125;&#125; 参数简单说明： entry： 是 页面入口文件配置 （html文件引入唯一的js 文件） output：对应输出项配置 ​ path ：入口文件最终要输出到哪里， ​ filename：输出文件的名称 ​ publicPath：公共资源路径 2.接着，我们在创建一些基本的文件保存路径，我们这里创建网页中最基本的一些文件夹 3.接下来我们在index.html，和entry.js中填充点内容 123456789101112&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt;hello world&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;out&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12&#x2F;&#x2F; entry.jsdocument.write(&#39;呵呵到天亮&#39;); 4.完成以上操作，我们可以来试试效果了，在刚才所打开的cmd窗口中输入webpack （假如已经关闭，按上面第4步操作即可） 下面WARNING in configuration原因及解决办法可点击链接：https://blog.csdn.net/lgx1134569285/article/details/87986317 5.看到上面 的一幕，恭喜你，已经成功了，我们再进一步验证一下， 目录下多了一个out文件夹，out文件生成了我们所命名的index.js 打开内容如下 打开index.html文件，结果不仅打印出html文件中的”hello world”，js中的打印123也生效了 (ps：这里打印中文时假如出现乱码，记得在html文件的标签添加编码)","categories":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}]},{"title":"webpack笔记","slug":"webpack笔记","date":"2019-02-27T10:00:43.000Z","updated":"2020-03-17T14:54:06.389Z","comments":true,"path":"2019/02/27/webpack笔记/","link":"","permalink":"http://yoursite.com/2019/02/27/webpack%E7%AC%94%E8%AE%B0/","excerpt":"今天想了解一下webpack，但找了网上的一系列教程，都会或多或少出现一些不明报错，实在恼火，经过几番简化，终于用最简单的方法使用了webpack，在此记录一下","text":"今天想了解一下webpack，但找了网上的一系列教程，都会或多或少出现一些不明报错，实在恼火，经过几番简化，终于用最简单的方法使用了webpack，在此记录一下一.环境配置1.首先，安装Node.js，这里不赘述，未接触nmp的童鞋可以参考Node.js安装配置 2.在cmd中输入 1npm install webpack -g 3.在自己测试的位置创建一个新的文件夹，命名webpack_demo 4.进入刚刚所创建的文件夹webpack_demo，按住shift键同时点击鼠标右键(即打开cmd并进入webpack_demo文件夹) 5.在打开的命令窗口键入：npm init，根据提示填写信息，name表示项目名，version表示版本等等，不一一赘述了，也可使用默认值，一路回车即可，最后出现“is this ok?”时，敲击回车键，webpack_demo文件夹便生成了package.json文件夹 二.构建webpack项目1.在webpack_demo文件夹下创建webpack.config.js文件，此文件为webpack的配置文件。具体内容如下： 123456789&#x2F;&#x2F;webpack.config.jsmodule.exports&#x3D;&#123; entry:&#39;.&#x2F;src&#x2F;js&#x2F;entry.js&#39;, &#x2F;&#x2F;页面入口文件 &#x2F;&#x2F;输出文件 output:&#123; filename:&#39;index.js&#39;, &#x2F;&#x2F;输出文件名 path:__dirname+&#39;&#x2F;out&#39;, &#x2F;&#x2F;输出文件路径 &#125;&#125; 参数简单说明： entry： 是 页面入口文件配置 （html文件引入唯一的js 文件） output：对应输出项配置 ​ path ：入口文件最终要输出到哪里， ​ filename：输出文件的名称 ​ publicPath：公共资源路径 2.接着，我们在创建一些基本的文件保存路径，我们这里创建网页中最基本的一些文件夹 3.接下来我们在index.html，和entry.js中填充点内容 123456789101112&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt;hello world&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;out&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12&#x2F;&#x2F; entry.jsdocument.write(&#39;呵呵到天亮&#39;); 4.完成以上操作，我们可以来试试效果了，在刚才所打开的cmd窗口中输入webpack （假如已经关闭，按上面第4步操作即可） 下面WARNING in configuration原因及解决办法可点击链接：https://blog.csdn.net/lgx1134569285/article/details/87986317 5.看到上面 的一幕，恭喜你，已经成功了，我们再进一步验证一下， 目录下多了一个out文件夹，out文件生成了我们所命名的index.js 打开内容如下 打开index.html文件，结果不仅打印出html文件中的”hello world”，js中的打印123也生效了 (ps：这里打印中文时假如出现乱码，记得在html文件的标签添加编码)","categories":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"javaScripts","slug":"javaScripts","permalink":"http://yoursite.com/categories/javaScripts/"},{"name":"前端","slug":"javaScripts/前端","permalink":"http://yoursite.com/categories/javaScripts/%E5%89%8D%E7%AB%AF/"}]},{"title":"git笔记","slug":"git/git笔记","date":"2018-08-10T13:34:18.000Z","updated":"2020-07-31T02:30:06.300Z","comments":false,"path":"2018/08/10/git/git笔记/","link":"","permalink":"http://yoursite.com/2018/08/10/git/git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设置用户名、密码12345git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;git remote &#x2F;&#x2F;查看远程库信息git remote -v显示更详细的信息 提交文件12git add readme.txtgit commit -m &quot;message&quot; 查看状态12345git status 告诉你有文件被修改过git diff 可以查看修改内容。git diff HEAD -- readme.txt 查看工作区与版本库最新版的区别git log 命令显示从最近到最远的提交日志，git log --pretty&#x3D;oneline 一行显示 版本回退12git reset --hard HEAD^ &#x2F;&#x2F;回退到上一版本git reset --hard commit_id &#x2F;&#x2F;回退到指定版本 撤销修改123git checkout -- file &#x2F;&#x2F;丢弃工作区修改git reset HEAD &lt;file&gt; &#x2F;&#x2F;缓存区回退到工作去如果修改已经提交到版本区，使用版本回退 删除123a.rm test.txt &#x2F;&#x2F;删除本地工作去文件 （误删可用git checkout --test.txt把误删的文件恢复到最新版本)b.git rm test.txt &#x2F;&#x2F;删除版本库文件d.git commit -m &lt;message&gt; 上传到github1234561.生成ssh key: $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;2.git remote add origin git@github.com:michaelliao&#x2F;learngit.git 要关联一个远程库3.$ git push -u origin master 本地库的所有内容推送到远程库上：由于远程库是空的，我们第一次推送master分支时，加上了-u参数git push origin master推送最新修改 从远程库克隆123 git clone git@github.com:lingengxiong&#x2F;testAgain.git（还可以用https:&#x2F;&#x2F;github.com&#x2F;michaelliao&#x2F;gitskills.git这样的地址。实际上，Git支持多种协议，默认的git:&#x2F;&#x2F;使用ssh，但也可以使用https等其他协议。） 分支管理查看分支：1git branch 创建分支：1git branch &lt;name&gt; 切换分支：1git checkout &lt;name&gt; 创建+切换分支：1git checkout -b &lt;name&gt; 合并某分支到当前分支：1git merge &lt;name&gt; 删除分支：12git branch -d &lt;name&gt;git branch -D &lt;name&gt; &#x2F;&#x2F;强行删除未合并的分支 查看分支合并情况1git log --graph --pretty&#x3D;oneline --abbrev-commit 分支管理策略1git merge --no-ff -m &quot;merge with no-ff&quot; dev --no-ff参数，表示禁用Fast forward 保存工作现场1git stash 查看现场保存情况1git stash list 回复现场12git stash popgit stash apply stash@&#123;0&#125; 多次stash,恢复时，指定stash 创建远程origin的dev分支到本地1git checkout -b dev origin&#x2F;dev 指定本地dev分支与远程origin/dev分支的链接1git branch --set-upstream-to&#x3D;origin&#x2F;dev dev 多人协作1234567891011因此，多人协作的工作模式通常是这样：首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt;。 标签管理创建标签1git tag &lt;name&gt; &#x2F;&#x2F;如git tag v1.0 查看标签1git tag 补打标签12345git log --pretty&#x3D;oneline --abbrev-commit &#x2F;&#x2F;查看历史提交的commit idgit tag v0.9 f52c633git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb &#x2F;&#x2F;创建带有说明的标签，用-a指定标签名，-m指定说明文字git show &lt;tagname&gt;可以看到说明文字 删除标签123git tag -d v0.1git push origin :refs&#x2F;tags&#x2F;v0.9 &#x2F;&#x2F;从远程删除 推送标签123git push origin &lt;tagname&gt;git push origin --tags &#x2F;&#x2F;一次性推送全部尚未推送到远程的本地标签","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}]}]}