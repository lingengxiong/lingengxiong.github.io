<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>呵呵到天亮</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-14T03:01:41.816Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lingengxiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity_Shader入门精要学习笔记3</title>
    <link href="http://yoursite.com/2020/09/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%813-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/09/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%813-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-14T02:53:45.000Z</published>
    <updated>2020-09-14T03:01:41.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="Shader" scheme="http://yoursite.com/categories/Shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity Shader入门精要学习笔记2</title>
    <link href="http://yoursite.com/2020/08/27/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%812-Unity%20Shader%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/27/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%812-Unity%20Shader%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-27T02:41:40.000Z</published>
    <updated>2020-09-14T03:01:41.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第3章-Unity-Shader基础"><a href="#第3章-Unity-Shader基础" class="headerlink" title="第3章 Unity Shader基础"></a>第3章 Unity Shader基础</h3><h4 id="3-1-Unity-Shader概述"><a href="#3-1-Unity-Shader概述" class="headerlink" title="3.1 Unity Shader概述"></a>3.1 Unity Shader概述</h4><h5 id="3-1-1-材质和Unity-Shader"><a href="#3-1-1-材质和Unity-Shader" class="headerlink" title="3.1.1 材质和Unity Shader"></a>3.1.1 材质和Unity Shader</h5><p>在Unity中，我们使用<strong>材质（Material）</strong>和Unity Shader才能达到想要的效果。流程如下：</p><ol><li>创建一个材质</li><li>创建一个Unity Shader，并赋给上一步中创建的材质；</li><li>把材质赋给渲染对象；</li><li>在材质面板中调整Unity Shader的属性，以得到满意的效果。</li></ol><p><img src="http://lgx.itengshe.com/20200827105849.png" alt=""></p><h5 id="3-1-2-Unity中的材质"><a href="#3-1-2-Unity中的材质" class="headerlink" title="3.1.2 Unity中的材质"></a>3.1.2 Unity中的材质</h5><p>Unity中材质需要结合一个GameObject的Mesh或者Particle Systems组件来工作。</p><p>创建材质：</p><p>Assets -&gt; Create -&gt; Material</p><h5 id="3-1-3-Unity中的Shader"><a href="#3-1-3-Unity中的Shader" class="headerlink" title="3.1.3 Unity中的Shader"></a>3.1.3 Unity中的Shader</h5><p>Unity中，共提供了4种Shader模板供我们选择：</p><ul><li>Standard Surface Shader：产生一个包含了标准光照模型的<strong>表面着色器</strong>模型</li><li>Unlit Shader：产生一个不包含光照（但包含雾效）的基本的<strong>顶点/片元着色器</strong></li><li>Image Effect Shader：为我们实现各种屏幕后处理效果提供一个基本模板</li><li>Compute Shader：产生一种特殊的Shader文件，这类Shader利用GPU的并行性来进行一些与常规渲染流水线无关的计算</li></ul><h4 id="3-2-Unity-Shader的基础：ShaderLab"><a href="#3-2-Unity-Shader的基础：ShaderLab" class="headerlink" title="3.2 Unity Shader的基础：ShaderLab"></a>3.2 Unity Shader的基础：ShaderLab</h4><p>Unity Shader是Unity为开发者提供的高层级的渲染抽象层，用这种方式让开发者更加轻松地控制渲染。</p><ul><li>没有使用Unity Shader，开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果。</li><li>在Unity Shader帮助下，开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有工作。</li></ul><p><img src="http://lgx.itengshe.com/20200827153153.png" alt=""></p><p>什么是ShaderLab？</p><p>ShaderLab是Unity 提供的编写Unity Shader的说明性语言。它使用一些嵌套在花括号内部的语义来描述Unity Shader文件的结构。这些结构包含了许多渲染所需要的的数据。</p><p>一个Unity Shader的基础结构如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"ShaderName"</span>&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡A使用的子着色器</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡B使用的子着色器</span></span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"VertexLit"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-Unity-Shader的结构"><a href="#3-3-Unity-Shader的结构" class="headerlink" title="3.3 Unity Shader的结构"></a>3.3 Unity Shader的结构</h4><h5 id="3-3-1-Shader的名字"><a href="#3-3-1-Shader的名字" class="headerlink" title="3.3.1 Shader的名字"></a>3.3.1 Shader的名字</h5><p>ShaderLab 文件第一行，指定Shader的名字，通过斜杆(“/”)，可控制Unity Shader在材质面板中的位置，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custon&#x2F;MyShader&quot;</span><br></pre></td></tr></table></figure><p>则Shader所在位置：</p><p><img src="https://gitee.com/lingengxiong/blogImage/raw/master/img/20200312174616.png" alt=""></p><h5 id="3-3-2-材质和Unity-Shader的桥梁：Properties"><a href="#3-3-2-材质和Unity-Shader的桥梁：Properties" class="headerlink" title="3.3.2 材质和Unity Shader的桥梁：Properties"></a>3.3.2 材质和Unity Shader的桥梁：Properties</h5><p>Properties语义块包含了一系列属性，这些属性会出现在材质面板中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">Name1(&quot;display name1&quot;, PropertyType1) &#x3D; DefaultValue1</span><br><span class="line">Name2(&quot;display name2&quot;, PropertyType2) &#x3D; DefaultValue2</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性名通常以下划线”_”开头，定义了这些属性后，即可在材质面板调节各种材质属性。使用每个属性的名字(Name) 可在Shader中访问它们。</p><p>每种属性都需要指定类型（PropertyType），以及赋予默认值，常用属性如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性类型</th><th style="text-align:left">默认值定义语法</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">Int</td><td style="text-align:left">number</td><td style="text-align:left">_Int(“Int”, Int) = 2</td></tr><tr><td style="text-align:left">Float</td><td style="text-align:left">number</td><td style="text-align:left">_Float(“Int”, Float) = 2</td></tr><tr><td style="text-align:left">Range(min, max)</td><td style="text-align:left">number</td><td style="text-align:left">_Range(“Range”, Range(0.0, 10.0)) = 1.5</td></tr><tr><td style="text-align:left">Color</td><td style="text-align:left">(number,number,number,number,)</td><td style="text-align:left">_Color(“Color”, Color) = (255,255,255,255)</td></tr><tr><td style="text-align:left">Vector</td><td style="text-align:left">(number,number,number,number,)</td><td style="text-align:left">_Vector(“Vector”, Vector) = (1, 1, 1 ,1)</td></tr><tr><td style="text-align:left">2D</td><td style="text-align:left">“defaulttexture”{}</td><td style="text-align:left">_2D(‘2D’, 2D) = “”{}</td></tr><tr><td style="text-align:left">Cube</td><td style="text-align:left">“defaulttexture”{}</td><td style="text-align:left">_Cube(‘Cube’, Cube= “white”{}</td></tr><tr><td style="text-align:left">3D</td><td style="text-align:left">“defaulttexture”{}</td><td style="text-align:left">_3D(‘3D’, 3D) = “black”{}</td></tr></tbody></table></div><h5 id="3-3-3-SubShader"><a href="#3-3-3-SubShader" class="headerlink" title="3.3.3 SubShader"></a>3.3.3 SubShader</h5><p>每个Unity Shader文件可包含至少一个SubShader。当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择一个能够在目标平台运行 的SubShader。假如没有一个SubShader支持的话，Unity会使用Fallback语义指定的Unity Shader。</p><p><strong>原因：</strong>不同显卡能力性能不同，比较老的显卡可能支持的操作指令数量较少，高级的显卡可支持的指令数较多，故而我们希望程序能在旧的显卡上运行，又能在高级的显卡上有更好的体验。</p><p>SubShader语义块通常如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">&#x2F;&#x2F;可选 标签</span><br><span class="line">[Tags]</span><br><span class="line">&#x2F;&#x2F;可选 状态</span><br><span class="line">[RenderSetup]</span><br><span class="line"></span><br><span class="line">Pass&#123;</span><br><span class="line">&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Pass：每个Pass定义了一次完整的渲染流程，Pass过多会造成渲染性能下降</li><li>状态设置：ShaderLab提供了一系列渲染状态的指令，这些指令可以设置显卡的各种状态，例如：是否开启混合，或者是否开启深度测试。</li></ul><p>常用渲染状态设置选项如下：</p><div class="table-container"><table><thead><tr><th>状态名称</th><th>设置指令</th><th>解释</th></tr></thead><tbody><tr><td>Cull</td><td>Cull Back\</td><td>Front\</td><td>Off</td><td>设置剔除模式：剔除背面/正面/关闭剔除</td></tr><tr><td>ZTest</td><td>ZTest Less Greater\</td><td>LEqual\</td><td>GEqual\</td><td>Equal\</td><td>NotEqual\</td><td>Always</td><td>设置深度测试时使用的函数</td></tr><tr><td>ZWrite</td><td>ZWrite On\</td><td>Off</td><td>开启/关闭深度写入</td></tr><tr><td>Blend</td><td>Blend SrcFactor DstFactor</td><td>开启并设置混合模式</td></tr></tbody></table></div><p>在SubShader块中设置上述渲染状态时，将会应用到所有的Pass，假如不希望这样，只想作用于特定Pass，可以再Pass语义块中单独进行设置。</p><ul><li>SubShader的标签</li></ul><p>SubShader的标签(Tags)是一个键值对(Key/Value Pair)，它的键和值都是字符串类型。这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：SubShader希望如何、以及何时渲染这个对象。</p><p>标签结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; &quot;TagName1&quot; &#x3D; &quot;Value1&quot; &quot;TagName2&quot; &#x3D; &quot;Value2&quot;&#125;</span><br></pre></td></tr></table></figure><p>SubShader的标签块支持的标签类型如下：</p><p><img src="https://gitee.com/lingengxiong/blogImage/raw/master/img/20200312231618.png" alt=""><strong>注意：</strong>上述标签只能在SubShader中声明，不能在Pass块中声明。</p><ul><li><p>Pass语义块</p><p>Pass语义块的语义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    [Name]</span><br><span class="line">    [Tags]</span><br><span class="line">    [RenderSetup]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>定义Pass名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name &quot;MyPassName&quot;</span><br></pre></td></tr></table></figure><p>通过这个名字，可以在其他Unity Shader中使用该Pass：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass &quot;MyShader&#x2F;MYPASSNAME&quot;</span><br></pre></td></tr></table></figure><p>这样就提高了代码的复用性，我们可以发现调用的过程中使用了大写的形式，这并不是写错，而是因为Unity内部会把所有的Pass的名称都转成大写，故而我们在使用UsePass时，必须使用大写的形式。</p></li><li><p>Pass标签<br>Pass同样可以设置标签，它的标签不同于SubShader的标签，这些标签也是用于告诉渲染引擎如何来渲染该物体。以下是Pass中使用的标签类型：</p></li></ol><div class="table-container"><table><thead><tr><th>标签类型</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>LightMode</td><td>定义该Pass在Unity的渲染流水线中的角色</td><td>Tags{“LightMode” = “ForwardBase”}</td></tr><tr><td>RequireOptions</td><td>用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串。目前Unity支持的选项有：SoftVegetation</td><td>Tags{“RequireOptions” = “SoftVegetation”}</td></tr></tbody></table></div><p>除了上面普通的Pass定义外，Unity Shader还支持一些特殊的Pass，以便进行代码复用或者实现更复杂的效果。</p><ul><li>UsePass : 可以使用该命令来复用其他Unity Shader中的Pass。</li><li>GrabPass：该Pass负责抓取屏幕并将结果存储在一张纹理中，用于后续的Pass处理。</li></ul><h5 id="3-3-4-Fallback"><a href="#3-3-4-Fallback" class="headerlink" title="3.3.4 Fallback"></a>3.3.4 Fallback</h5><p>在ShaderLab语义块的最后，是一个Fallback指令，它告诉Unity如果上面的所有SubShader在这块显卡都不能运行，就使用这个最低级的Shader！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fallback &quot;name&quot;&#x2F;&#x2F;告诉显卡使用哪个Unity Shader</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">Fallback Off</span><br></pre></td></tr></table></figure><h4 id="3-4-Unity-Shader的形式"><a href="#3-4-Unity-Shader的形式" class="headerlink" title="3.4 Unity Shader的形式"></a>3.4 Unity Shader的形式</h4><h5 id="3-4-1-表面着色器"><a href="#3-4-1-表面着色器" class="headerlink" title="3.4.1 表面着色器"></a>3.4.1 表面着色器</h5><p>表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。它的代码量很少，但渲染代价比较大。当给Unity提供一个表面着色器的时候，Unity需要在背后做很多工作，把它转换成顶点/片元着色器。</p><p>好处：Unity对顶点/片元着色器更高一层的的抽象，为我们处理很多光照细节，我们不需要操心这些事。</p><p>简单的表面着色器如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom&#x2F;Simple Surface Shader&quot;&#123;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Tags&#123;&quot;RenderType&quot; &#x3D; &quot;Opaque&quot;&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line">#pragma surface surf Lambert</span><br><span class="line">struct Input&#123;</span><br><span class="line">float4 color : COLOR;</span><br><span class="line">&#125;;</span><br><span class="line">void surf(Input IN, input SurfaceOutput 0)&#123;</span><br><span class="line">o.Albedo &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中，表面着色器被定义在SubShader语义块中的CGPROGRAM和ENDCG中(而不是Pass中)，因为表面着色器不需要开发者关心使用多少个Pass以及每个Pass如何渲染，这些事情都交给Unity去完成就好了。</p><p>CGPROGRAM和ENDCG之间的代码是使用CG/HLSL编写的，我们需要把CG/HLSL语言嵌套在ShaderLab语言中<br>        <strong>注意：</strong>此处的CG/HLSL是Unity封装过的，与标准的CG/HLSL几乎一样，只有细微差别，一些原生的函数可能Unity并没有提供。</p><h5 id="3-4-2-顶点-片元着色器"><a href="#3-4-2-顶点-片元着色器" class="headerlink" title="3.4.2 顶点/片元着色器"></a>3.4.2 顶点/片元着色器</h5><p>在Unity中，我们可以使用CG/HLSL语言来编写<strong>顶点/片元着色器（Vertex/Fragment Shader）</strong>。它更加复杂，但也更加灵活了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom&#x2F;Simple VertexFragement Shader&quot;&#123;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Pass&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br><span class="line">float4 vert(float4 v:POSITION):SV_POSITION&#123;</span><br><span class="line">return mul(UNITY_MATRIX_MVP, v);</span><br><span class="line">&#125;</span><br><span class="line">float4 frag():AV_Target&#123;</span><br><span class="line">return fixed4(1.0, 0.0, 0.0, 1.0)</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码同样写在CGPROGRAM和ENDCG之间，但顶点/片元着色器是写在Pass语义块内的，而不是Subshader内，因为我们需要自己定义每个Pass。因此我们需要编写更多的代码，但也因如此变得灵活性更高，可以控制渲染的实现细节。</p><h5 id="3-4-3-固定函数着色器"><a href="#3-4-3-固定函数着色器" class="headerlink" title="3.4.3 固定函数着色器"></a>3.4.3 固定函数着色器</h5><p>对于一些比较老旧的设备，它们不支持可编程管线着色器，此时需要使用<strong>固定函数着色器（Fixed Function Shader）</strong>，这样的着色器往往只能完成一些简单的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Tutorial&#x2F;Basic&quot;&#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_Color (&quot;Main Color&quot;, Color) &#x3D; (1, 0.5, 0.5, 1)</span><br><span class="line">&#125;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Pass&#123;</span><br><span class="line">Material&#123;</span><br><span class="line">Diffuse [_Color]</span><br><span class="line">&#125;</span><br><span class="line">Lighting On</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于固定函数着色器来说，我们需要完全使用ShaderLab的语法(即使用ShaderLab的渲染设置命令)来编写，而不是CG/HLSL。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第3章-Unity-Shader基础&quot;&gt;&lt;a href=&quot;#第3章-Unity-Shader基础&quot; class=&quot;headerlink&quot; title=&quot;第3章 Unity Shader基础&quot;&gt;&lt;/a&gt;第3章 Unity Shader基础&lt;/h3&gt;&lt;h4 id=&quot;3
      
    
    </summary>
    
    
      <category term="Shader" scheme="http://yoursite.com/categories/Shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Win10修改文件默认打开方式</title>
    <link href="http://yoursite.com/2020/08/25/CMD/Win10%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/08/25/CMD/Win10%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</id>
    <published>2020-08-25T07:23:16.000Z</published>
    <updated>2020-09-14T03:01:41.795Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>更新win10的一些版本之后，会出现无法设置默认打开方式的情况，例如我想默认用<code>NotePad++</code>来打开<code>.json</code>文件都没办法，只有已经列出的和”在Microsoft Store中查找”</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>网上很多都是通过手动修改注册表的方式，但那堆注册表，翻起来有点麻烦。直接用命令修改更快一些。</p><ol><li><p>以管理员打开cmd</p></li><li><p>查看当前打开方式，这里以<code>.json</code>为例</p><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assoc .json</span><br></pre></td></tr></table></figure><p> 结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;assoc .json</span><br><span class="line">.json=VisualStudio.json.14.0</span><br></pre></td></tr></table></figure><p>可以看到目前默认用的是VisualStudio</p></li><li><p>设置默认打开方式</p><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assoc .json=json_auto_file</span><br></pre></td></tr></table></figure><p>   结果：</p></li></ol>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;assoc .json=json_auto_file</span><br><span class="line">  .json=json_auto_file</span><br></pre></td></tr></table></figure><p>   命令：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftype json_auto_file="C:\Program Files (x86)\Notepad++\notepad++.exe" "%1"</span><br></pre></td></tr></table></figure><p>结果：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;ftype json_auto_file="C:\Program Files (x86)\Notepad++\notepad++.exe" "%1"</span><br><span class="line">json_auto_file="C:\Program Files (x86)\Notepad++\notepad++.exe" "%1"</span><br></pre></td></tr></table></figure><p>   路径以指定软件实际安装目录为准</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h4&gt;&lt;p&gt;更新win10的一些版本之后，会出现无法设置默认打开方式的情况，例如我想默认用&lt;code&gt;NotePad++&lt;/code&gt;来打开&lt;c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Tomcat安装配置</title>
    <link href="http://yoursite.com/2020/08/18/tomcat/Tomcat%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/08/18/tomcat/Tomcat%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-18T03:07:28.000Z</published>
    <updated>2020-09-14T03:01:41.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-下载"><a href="#一-下载" class="headerlink" title="一. 下载"></a>一. 下载</h3><p>下载地址：<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">https://tomcat.apache.org/</a></p><p>左侧选择下载版本，我这里下载Tomcat9</p><p><img src="http://lgx.itengshe.com/20200818111135.png" alt=""></p><p>下载跟电脑系统匹配的版本：</p><p><img src="http://lgx.itengshe.com/20200818111245.png" alt=""></p><p><strong>注意：要根据自己的JDK版本选择Tomcat的版本。</strong></p><p><img src="http://lgx.itengshe.com/20200818111354.png" alt=""></p><h3 id="二-配置环境变量"><a href="#二-配置环境变量" class="headerlink" title="二. 配置环境变量"></a>二. 配置环境变量</h3><p>变量值根据自己的安装包放置位置配置。</p><p><img src="http://lgx.itengshe.com/20200818111554.png" alt=""></p><p>系统环境变量Path，添加%CATALINA_HOME%\bin；</p><h3 id="三-验证配置是否成功"><a href="#三-验证配置是否成功" class="headerlink" title="三. 验证配置是否成功"></a>三. 验证配置是否成功</h3><p>cmd 输入<code>catalina version</code>，出现如下结果表明安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">λ catalina version</span><br><span class="line">Using CATALINA_BASE:   "D:\Program Files\apache-tomcat-9.0.37"</span><br><span class="line">Using CATALINA_HOME:   "D:\Program Files\apache-tomcat-9.0.37"</span><br><span class="line">Using CATALINA_TMPDIR: "D:\Program Files\apache-tomcat-9.0.37\temp"</span><br><span class="line">Using JRE_HOME:        "C:\Program Files\Java\jdk1.8.0_144"</span><br><span class="line">Using CLASSPATH:       "D:\Program Files\apache-tomcat-9.0.37\bin\bootstrap.jar;D:\Program Files\apache-tomcat-9.0.37\bin\tomcat-juli.jar"</span><br><span class="line">Server version: Apache Tomcat/9.0.37</span><br><span class="line">Server built:   Jun 30 2020 20:09:49 UTC</span><br><span class="line">Server number:  9.0.37.0</span><br><span class="line">OS Name:        Windows 10</span><br><span class="line">OS Version:     10.0</span><br><span class="line">Architecture:   amd64</span><br><span class="line">JVM Version:    1.8.0_144-b01</span><br><span class="line">JVM Vendor:     Oracle Corporation</span><br></pre></td></tr></table></figure><h3 id="四-启动Tomcat"><a href="#四-启动Tomcat" class="headerlink" title="四. 启动Tomcat"></a>四. 启动Tomcat</h3><p>命令行直接执行<code>startup.bat</code>，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a>/</p><p><img src="http://lgx.itengshe.com/20200818112835.png" alt=""></p><h3 id="五-配置http文件下载服务器"><a href="#五-配置http文件下载服务器" class="headerlink" title="五. 配置http文件下载服务器"></a>五. 配置http文件下载服务器</h3><p>本次配置变量如下，实际配置已自己情况灵活变动。</p><p>文件放置目录：E:\CDN</p><p>tomcat安装目录：D:\Program Files\apache-tomcat-9.0.37</p><ol><li><p>设置tomcat虚拟目录</p><p>在D:\Program Files\apache-tomcat-9.0.37\conf\Catalina\localhost 新建XML文件，名字随意，这里起名download，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/download2"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">docBase</span>=<span class="string">"E:\CDN"</span> <span class="attr">crossContext</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面download2名字可以随意，最终目录以文件名为准，所以就算这里是download2，最终还是以download为准。</p></li><li><p>允许tongcat列举文件</p><p>修改D:\Program Files\apache-tomcat-9.0.37\conf\web.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>验证</p><p>重启tomcat程序，即可在浏览器中访问<a href="http://localhost:8080/download/" target="_blank" rel="noopener">http://localhost:8080/download/</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-下载&quot;&gt;&lt;a href=&quot;#一-下载&quot; class=&quot;headerlink&quot; title=&quot;一. 下载&quot;&gt;&lt;/a&gt;一. 下载&lt;/h3&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://tomcat.apache.org/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Unity Shader入门精要学习笔记1</title>
    <link href="http://yoursite.com/2020/08/16/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%811-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2020/08/16/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity_Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%811-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-08-16T14:11:33.000Z</published>
    <updated>2020-09-14T03:01:41.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第2章-渲染流水线"><a href="#第2章-渲染流水线" class="headerlink" title="第2章 渲染流水线"></a>第2章 渲染流水线</h3><h4 id="2-1-什么是渲染流水线"><a href="#2-1-什么是渲染流水线" class="headerlink" title="2.1 什么是渲染流水线"></a>2.1 什么是渲染流水线</h4><p>渲染流水线中3个概念阶段：应用阶段，几何阶段，光栅化阶段</p><p><img src="http://lgx.itengshe.com/20200816221630.png" alt=""></p><ul><li><p>应用阶段</p><p>由CPU负责，此阶段我们需要设置好每个模型的渲染状态，渲染状态包括但不限于它的材质，纹理以及使用的Shader等。此阶段最重要的输出是渲染所需的几何信息——渲染图元(rendering primitives)。</p><p>渲染图元可以是点、线、三角面等。渲染图元将被传递到下一阶段——几何阶段。</p></li><li><p>几何阶段</p><p>这一阶段通常在GPU上进行，决定需要绘制的图元是什么，如何绘制它们，在哪绘制它们。</p><p>这阶段负责和应用阶段传过来的每个 <strong>渲染图元</strong> 打交道，进行逐顶点、逐多边形的操作，可细分为更小的流水线阶段。</p><p>几何阶段的重要任务就是把顶点坐标转换到屏幕空间中，交给光栅器进行处理。此阶段对渲染图元进行处理后，会输出屏幕空间的二维顶点坐标，每个顶点对应的深度值，着色等相关信息，并传到下一阶段——光栅化阶段</p></li><li><p>光栅化阶段</p><p>此阶段也是在GPU上进行，使用上阶段传递过来的数据来产生屏幕像素，并渲染出最终的图像。</p><p>主要任务是决定每个渲染图元中的哪些像素应该绘制到屏幕上。需要对上一阶段得到的逐顶点数据（如纹理坐标，顶点颜色等）进行插值，然后进行逐像素处理。</p></li></ul><h4 id="2-2-CPU和GPU之间的通信"><a href="#2-2-CPU和GPU之间的通信" class="headerlink" title="2.2  CPU和GPU之间的通信"></a>2.2  CPU和GPU之间的通信</h4><p>​    渲染流水线的起点是CPU，即应用阶段，应用阶段大概分为3个阶段：</p><ol><li>把数据加载到显存。</li><li>设置渲染状态</li><li>调用Draw Call</li></ol><h5 id="2-2-1-把数据加载到显存"><a href="#2-2-1-把数据加载到显存" class="headerlink" title="2.2.1 把数据加载到显存"></a>2.2.1 把数据加载到显存</h5><p>​    渲染数据先从<strong>硬盘</strong>加载到<strong>内存</strong>中，然后网格和纹理等数据又被加载到<strong>显存</strong>中。</p><p>​    数据加载到<strong>显存</strong>后，<strong>内存</strong>中的数据就能移除了，但有些数据我们可能还需要访问它（例如，我们可能需要CPU访问网格数据来进行碰撞检测），此时数据就暂时不需要移除出<strong>内存</strong>。</p><h5 id="2-2-2-设置渲染状态"><a href="#2-2-2-设置渲染状态" class="headerlink" title="2.2.2 设置渲染状态"></a>2.2.2 设置渲染状态</h5><p>​    渲染状态定义了场景中网格如何被渲染，例如使用哪个顶点着色器，哪个片元着色器，使用什么材质等。假如不更改渲染状态，所有网格将使用同一种渲染状态，所以看起来不同网格外观像是使用了同一种材质。</p><h5 id="2-2-3-调用Draw-Call"><a href="#2-2-3-调用Draw-Call" class="headerlink" title="2.2.3 调用Draw Call"></a>2.2.3 调用Draw Call</h5><p>​    Draw Call是一个命令，由CPU发起，由GPU接收。</p><p>​    当给定一个Draw Call时，GPU会根据 <strong>渲染状态</strong> 和 <strong>所有顶点数据</strong> 来进行计算，最终输出到屏幕显示出像素。</p><h4 id="2-3-GPU流水线"><a href="#2-3-GPU流水线" class="headerlink" title="2.3 GPU流水线"></a>2.3 GPU流水线</h4><h5 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h5><p>​    概念阶段中，<strong>几何阶段</strong>和<strong>光栅化阶段</strong>，开发者的控制权限有限。这两个阶段又可分为更小的流水线阶段，由GPU来实现这些流水阶段，每个阶段GPU提供了不同的 <strong>可配置性</strong> 或 <strong>可编程性</strong>。</p><p><img src="http://lgx.itengshe.com/20200818101644.png" alt=""></p><p><strong>几何阶段</strong>：</p><ul><li><strong>输入</strong>：顶点数据，由应用阶段加载到显存中，再由Draw Call指定。</li><li><strong>顶点着色器（Vertex Shader)</strong>：完全可编程，常用于顶点空间变换，顶点着色。</li><li><strong>曲面细分着色器（Tessellation Shader）</strong>：可选着色器，用于细分图元。</li><li><strong>几何着色器（Geometry Shader）</strong>：可选着色器，用于执行逐图元着色操作，或产生更多图元。</li><li><strong>裁剪（Clipping）</strong>：可配置，将不再摄像机视野内的顶点裁剪掉，剔除某些三角图元的面片。</li><li><strong>屏幕映射（Screen Mapping）</strong>：不可配置不可编程，负责将图元的坐标转换到屏幕坐标系中。</li></ul><p><strong>光栅化阶段</strong>：</p><ul><li><strong>三角形设置（Triangle Setup）</strong>：固定函数阶段</li><li><strong>三角形遍历（Triangle Traversal）</strong>：固定函数阶段</li><li><strong>片元着色器（Fragment Shader）</strong>：完全可编程，用于实现逐片元的着色操作。</li><li><strong>逐片元操作（Per-Fragment Operations）</strong>：不可编程，但有很高可配性，可以执行很多重要操作，如：修改颜色，深度缓冲，进行混合等。</li></ul><h5 id="2-3-2-顶点着色器"><a href="#2-3-2-顶点着色器" class="headerlink" title="2.3.2 顶点着色器"></a>2.3.2 顶点着色器</h5><p>​    <strong>处理单位：</strong>顶点着色器是流水线的第一阶段，输入来自CUP。处理单位是顶点，输入的每个顶点都会调用一次顶点着色器。</p><p>​    <strong>速度快：</strong>顶点着色器本身不会创建或销毁任何顶点，也无法知道顶点与顶点之间的关系（也就是说我们无法知道两个顶点是否属于同一个三角网格）。也正因为这种相互独立性，GPU可以利用本身的特性并行化处理每个顶点，这样这一阶段处理速度会很快。</p><p>​    <strong>主要工作：</strong>坐标变换、逐顶底光照</p><p><img src="http://lgx.itengshe.com/20200818143748.png" alt=""></p><ul><li>坐标变换：对顶点的坐标进行某种变换。顶点着色器可在这一步改变顶点的位置，这样可以实现一些我们需要的效果，如模拟水面，布料等。</li><li>顶点着色器必须完成的工作：把顶点坐标从模拟空间转换到齐次裁剪空间。</li></ul><h5 id="2-3-3-裁剪"><a href="#2-3-3-裁剪" class="headerlink" title="2.3.3 裁剪"></a>2.3.3 裁剪</h5><p>​    我们的场景可能非常大，但是摄像机视野是有限的，场景中不在我们视野中的物体完全没必要渲染，裁剪就是为了这个目的被提出来的。</p><p>​    一个图元跟摄像机视野的关系：</p><ul><li><p>完全在视野内：图元继续传到下一阶段</p></li><li><p>部分在视野内：进行裁剪，保留在视野内部分，裁剪掉视野外部分。</p></li><li><p>完全在视野外：不会继续向下传递，因为不需要被渲染</p></li></ul><p>这个阶段不可编程，无法通过程序来控制裁剪的过程，而是硬件固定操作。但我们可以自定义应该裁剪操作来对这一步进行配置。</p><h5 id="2-3-4-屏幕映射"><a href="#2-3-4-屏幕映射" class="headerlink" title="2.3.4 屏幕映射"></a>2.3.4 屏幕映射</h5><p>​    这一阶段的输入坐标仍然是三维坐标。</p><p>​    <strong>任务：</strong>把每个图元的x和y坐标转换到<strong>屏幕坐标系</strong>下，屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。</p><p>​    屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远。</p><p>​    <strong>注意：</strong>屏幕坐标系在<strong>OpenGL</strong>和<strong>DirectX</strong>之间存在差异</p><ul><li><strong>OpenGL</strong>把屏幕左下角作为坐标原点(0, 0)</li><li><strong>DirectX</strong>把屏幕左上角作为坐标原点(0, 0)</li></ul><p><img src="http://lgx.itengshe.com/20200312131104.png" alt=""></p><h5 id="2-3-5-三角形设置"><a href="#2-3-5-三角形设置" class="headerlink" title="2.3.5 三角形设置"></a>2.3.5 三角形设置</h5><p>​    从这开始，进入<strong>光栅化阶段</strong>。上阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的额外信息（如：深度值，法线方向，视角方向等）</p><p>​    光栅化重要目标：</p><ul><li>计算每个图元覆盖了哪些像素</li><li>为这些像素计算它们的颜色</li></ul><p>​    <strong>三角形设置</strong> 是光栅化流水线的一个个阶段。这一阶段会计算光栅化一个三角网格所需的信息。</p><p>​    上一阶段输出的都是三角网格的顶点，我们得到的是三角网格每条边的两个端点。想要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。</p><p>​    为了计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式，这样一个计算三角网格表示数据的过程就叫三角形设置。</p><h5 id="2-3-6-三角形遍历"><a href="#2-3-6-三角形遍历" class="headerlink" title="2.3.6 三角形遍历"></a>2.3.6 三角形遍历</h5><p>​    此阶段会检查每个像素是否被一个三角网格覆盖，如果被覆盖，会生成一个<strong>片元</strong>。</p><p>​    找哪些像素被三角网格覆盖的过程就是 <strong>三角形遍历</strong> ，也称为 <strong>扫描变换</strong>。</p><p>​    三角形遍历阶段会根据上一阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。</p><p><img src="http://lgx.itengshe.com/20200819112501.png" alt=""></p><p>​    此阶段输出的是一个片元序列，需要注意的是，一个片云不是真正意义上的像素，而是包含了多种状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括但不限于屏幕坐标，深度信息等，以及其他几何阶段输出的顶点信息，如法线、纹理坐标等。</p><h5 id="2-3-7-片元着色器"><a href="#2-3-7-片元着色器" class="headerlink" title="2.3.7 片元着色器"></a>2.3.7 片元着色器</h5><p>​    片元着色器是非常重要的可编程着色器阶段。</p><p>​    前面的光栅化阶段实际不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎么覆盖每个像素的。每个片元就负责存储这样一系列数据。真正对像素产生影响的阶段是——逐片元操作。</p><p>​    输入：上阶段对顶点信息插值得到的结果</p><p>​    输出： 一个或多个颜色值</p><p>​    这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是 <strong>纹理采样</strong> ，为了在片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值，就可以得到其覆盖的片元纹理坐标了。</p><p><img src="http://lgx.itengshe.com/20200819151033.png" alt=""></p><p>​    <strong>局限性</strong>：仅可以影响单个片元，执行片元着色器时，它不可以将自己的任何结果发送给它的邻居。</p><h5 id="2-3-8-逐片元操作"><a href="#2-3-8-逐片元操作" class="headerlink" title="2.3.8 逐片元操作"></a>2.3.8 逐片元操作</h5><p>此阶段高度可配置性，我们可以设置每一步的操作细节。</p><p>渲染流水线最后阶段，在OpenGL中和DirectX中有不同叫法：</p><ul><li>OpenGL中：逐片元操作</li><li>DirectX中：输出合并阶段</li></ul><p>主要任务：</p><ul><li>决定每个片元的可见性，涉及很多测试工作，如深度测试，模板测试等。</li><li>如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说混合。</li></ul><p>下面是逐片元操作所做的操作：</p><p><img src="http://lgx.itengshe.com/20200819160150.png" alt=""></p><p>下面是模板测试和深度测试的简化流程图：</p><p><img src="http://lgx.itengshe.com/20200819161334.png" alt=""></p><ul><li><p>模板测试</p><p>如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取到的参考值进行比较，比较函数可以由开发者指定。如果一个片元没有通过测试，该片元将会被舍弃。不管一个片元有没有通过模板测试，我们都可以根据模板测试和深度测试结果来修改模板缓冲区。</p></li><li><p>深度测试</p><p>通过了模板检测的片元，会进行下一个测试——深度测试。</p><p>如果开启了深度测试，GPU会把该片元的深度和已经存在于深度缓冲区中的深度进行比较。这个比较函数也可以由开发者设置。</p><p>和模板测试测试不同，一个片元如果没有通过深度测试，它没有权利更改深度缓冲区中的值。</p></li><li><p>混合</p><p>对于不透明物体，开发者可以关闭<strong>混合</strong>操作，这样片元着色器计算得到的颜色就会直接覆盖颜色缓冲区中的像素值</p><p>对于半透明物体，我们就需要使用混合操作来让这个物体看起来是透明的。</p></li></ul><p><img src="http://lgx.itengshe.com/20200819163917.png" alt=""></p><p>​    当模型的图元经过上面层层计算和测试后，就会显示到我们的屏幕上，我们的屏幕显示的是颜色缓冲区中的颜色值。但是为了避免我们看到那些正在进行光栅化的图元，GUP会使用<strong>双重缓冲（Double Buffering</strong>）的策略。这意味着，对场景的渲染是在幕后发生的，即在<strong>后置缓冲区</strong>中。一旦场景已经被渲染到后置缓冲中，GUP会交换后置缓冲区和前置缓冲区中的内容，而前置缓冲区是之前显示在屏幕上的图像，由此保证我们看到的画面是连续的。</p><h4 id="2-4-容易困惑的地方"><a href="#2-4-容易困惑的地方" class="headerlink" title="2.4 容易困惑的地方"></a>2.4 容易困惑的地方</h4><h5 id="2-4-1-什么是OpenGL-DirextX"><a href="#2-4-1-什么是OpenGL-DirextX" class="headerlink" title="2.4.1 什么是OpenGL/DirextX"></a>2.4.1 什么是OpenGL/DirextX</h5><p>OpenGL/DirextX是图像应用编程接口，这些接口用于渲染二维或三维图形。可以说这些接口架起了上层应用程序和底层GPU的沟通桥梁。一个应用程序向这些接口发送渲染命令，而这些接口会依次向显卡驱动发送渲染命令，【显卡驱动】是真正知道如何跟GPU通信的角色，它们负责将OpenGL/DirextX的函数翻译成GPU能听懂的语言，同时它们也负责把纹理等数据转换成GPU所支持的格式。</p><h5 id="2-4-2-什么是HLSL、GLSL、CG"><a href="#2-4-2-什么是HLSL、GLSL、CG" class="headerlink" title="2.4.2 什么是HLSL、GLSL、CG"></a>2.4.2 什么是HLSL、GLSL、CG</h5><p>都是着色语言（Shading Language）</p><ul><li>HLSL：(Hight Level Shading Language)，DirectX</li><li>GLSL：(OpenGL Shading Language)，OpenGL </li><li>CG：(C for Graphic)， NVIDIA</li></ul><h5 id="2-4-3-什么是Draw-Call"><a href="#2-4-3-什么是Draw-Call" class="headerlink" title="2.4.3 什么是Draw Call"></a>2.4.3 什么是Draw Call</h5><p>​    Draw Call就是CPU调用图像编程接口， 以命令GPU进行渲染的操作。</p><p>​    Draw Call造成性能问题的元凶是CPU而非GPU。</p><p><strong><font color=#ff0000>问题一：GPU 和CPU如何并行工作</font></strong></p><p>​    为了提高效率，CPU和GPU需要并行工作，实现方式：使用<strong>命令缓冲区（Command Buffer）</strong></p><p>​    命令缓冲区包含一个命令队列，由CPU向其中添加命令，GPU负责读取命令，添加跟读取过程都是相互独立的，这样就实现了并行工作。</p><p>​    命令缓冲区的命令很多种，Draw Call是其中一种，其他命令还有改变渲染状态等（例如改变使用的着色器，使用不同纹理等）。</p><p><img src="http://lgx.itengshe.com/20200819174535.png" alt=""></p><p>往往改变渲染状态命令更加耗时。</p><p>​    <strong><font color=#ff0000>问题二. 为什么Draw Call多了会影响帧率</font></strong></p><p>​    每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据，状态和命令等。这一阶段CPU需要完成很多工作，例如检查渲染状态等。一旦CPU完成了这些准备工作，CPU就可以开始本次的渲染。</p><p>​    GPU渲染能力很强，速度往往快于CPU提交命令的速度，如果Draw Call数量太多，CPU就会把大量时间花费在提交Draw Clall上，造成CPU过载。</p><p>​    <strong><font color=#ff0000>问题三. 如何减少Draw Call</font></strong></p><p>​    可以使用批处理（bathching）方法，把小的DrawCall合并成一个大的DrawCall</p><p>​    游戏开发过程中，为减少Draw Call的开销，需注意：</p><ol><li>避免使用大量的很小的网格，当不可避免地使用很小的网格结构时，考虑是否可以合并它们。</li><li>避免使用过多的材质。尽量在不同网格之间共用同一个材质。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第2章-渲染流水线&quot;&gt;&lt;a href=&quot;#第2章-渲染流水线&quot; class=&quot;headerlink&quot; title=&quot;第2章 渲染流水线&quot;&gt;&lt;/a&gt;第2章 渲染流水线&lt;/h3&gt;&lt;h4 id=&quot;2-1-什么是渲染流水线&quot;&gt;&lt;a href=&quot;#2-1-什么是渲染流水线&quot;
      
    
    </summary>
    
    
      <category term="Shader" scheme="http://yoursite.com/categories/Shader/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode插件开发</title>
    <link href="http://yoursite.com/2020/08/14/vscode%E6%8F%92%E4%BB%B6/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2020/08/14/vscode%E6%8F%92%E4%BB%B6/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2020-08-14T08:19:45.000Z</published>
    <updated>2020-09-14T03:01:41.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><h4 id="1-安装脚手架"><a href="#1-安装脚手架" class="headerlink" title="1. 安装脚手架"></a>1. 安装脚手架</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br></pre></td></tr></table></figure><p>cd 到项目目录，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br></pre></td></tr></table></figure><h4 id="2-运行看效果"><a href="#2-运行看效果" class="headerlink" title="2. 运行看效果"></a>2. 运行看效果</h4><p>构建完成后，直接用vscode打开项目，按F5运行项目，此时会弹出一个新的vscode窗口（类似我们写html后，会运行浏览器来看效果，新打开的vscode窗口就起到浏览器相同的作用）。</p><p>同时按下ctrl+shift+p，在输入框中输入Hello Word，即可在右下角看到插件运行的消息</p><h4 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h4><p>主要配置文件：extension.ts 和 package.json</p><p><img src="http://lgx.itengshe.com/20200814171756.png" alt=""></p><p>package.json关键内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">"name": "vscode-plugin-bear",</span><br><span class="line">"displayName": "vscode-plugin-bear",</span><br><span class="line">"description": "My VSCode plugin",</span><br><span class="line">"version": "0.0.1",</span><br><span class="line">"publisher": "bear",</span><br><span class="line">"engines": &#123;</span><br><span class="line">"vscode": "^1.27.0"</span><br><span class="line">&#125;,</span><br><span class="line">"categories": [</span><br><span class="line"><span class="string">"Other"</span></span><br><span class="line">],</span><br><span class="line">"activationEvents": [</span><br><span class="line"><span class="string">"onCommand:extension.helloWorld"</span></span><br><span class="line">],</span><br><span class="line">"main": "./out/extension.js",</span><br><span class="line">"contributes": &#123;</span><br><span class="line">"commands": [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.helloWorld"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键说明：</p><ul><li>name 和 publisher：VS Code使用\<publisher>.\<name>作为插件的唯一ID，例如我这里会以bear.vscode-plugin-bear作为唯一ID。</li><li>displayName：插件展示名称</li><li>description：插件自我描述</li><li>version：版本号</li><li>engines：使用此插件的VS Code最低版本要求</li><li>categories：插件分类，可选值[Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs]</li><li>activationEvents：拓展可被激活的事件数组</li><li>main：入口文件</li><li>activationEvents</li></ul><p>貌似有<a href="http://blog.haoji.me/vscode-plugin-package-json.html" target="_blank" rel="noopener">博主</a>描述的更全面，这里拿来用用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 插件的名字，应全部小写，不能有空格</span></span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"vscode-plugin-demo"</span>,</span><br><span class="line"><span class="comment">// 插件的友好显示名称，用于显示在应用市场，支持中文</span></span><br><span class="line"><span class="attr">"displayName"</span>: <span class="string">"VSCode插件demo"</span>,</span><br><span class="line"><span class="comment">// 描述</span></span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"VSCode插件demo集锦"</span>,</span><br><span class="line"><span class="comment">// 关键字，用于应用市场搜索</span></span><br><span class="line"><span class="attr">"keywords"</span>: [<span class="string">"vscode"</span>, <span class="string">"plugin"</span>, <span class="string">"demo"</span>],</span><br><span class="line"><span class="comment">// 版本号</span></span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line"><span class="comment">// 发布者，如果要发布到应用市场的话，这个名字必须与发布者一致</span></span><br><span class="line"><span class="attr">"publisher"</span>: <span class="string">"sxei"</span>,</span><br><span class="line"><span class="comment">// 表示插件最低支持的vscode版本</span></span><br><span class="line"><span class="attr">"engines"</span>: &#123;</span><br><span class="line"><span class="attr">"vscode"</span>: <span class="string">"^1.27.0"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 插件应用市场分类，可选值： [Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs]</span></span><br><span class="line"><span class="attr">"categories"</span>: [</span><br><span class="line"><span class="string">"Other"</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 插件图标，至少128x128像素</span></span><br><span class="line"><span class="attr">"icon"</span>: <span class="string">"images/icon.png"</span>,</span><br><span class="line"><span class="comment">// 扩展的激活事件数组，可以被哪些事件激活扩展，后文有详细介绍</span></span><br><span class="line"><span class="attr">"activationEvents"</span>: [</span><br><span class="line"><span class="string">"onCommand:extension.sayHello"</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 插件的主入口</span></span><br><span class="line"><span class="attr">"main"</span>: <span class="string">"./src/extension"</span>,</span><br><span class="line"><span class="comment">// 贡献点，整个插件最重要最多的配置项</span></span><br><span class="line"><span class="attr">"contributes"</span>: &#123;</span><br><span class="line"><span class="comment">// 插件配置项</span></span><br><span class="line"><span class="attr">"configuration"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line"><span class="comment">// 配置项标题，会显示在vscode的设置页</span></span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"vscode-plugin-demo"</span>,</span><br><span class="line"><span class="attr">"properties"</span>: &#123;</span><br><span class="line"><span class="comment">// 这里我随便写了2个设置，配置你的昵称</span></span><br><span class="line"><span class="attr">"vscodePluginDemo.yourName"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line"><span class="attr">"default"</span>: <span class="string">"guest"</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"你的名字"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 是否在启动时显示提示</span></span><br><span class="line"><span class="attr">"vscodePluginDemo.showTip"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"boolean"</span>,</span><br><span class="line"><span class="attr">"default"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"是否在每次启动时显示欢迎提示！"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 命令</span></span><br><span class="line"><span class="attr">"commands"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.sayHello"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 快捷键绑定</span></span><br><span class="line"><span class="attr">"keybindings"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.sayHello"</span>,</span><br><span class="line"><span class="attr">"key"</span>: <span class="string">"ctrl+f10"</span>,</span><br><span class="line"><span class="attr">"mac"</span>: <span class="string">"cmd+f10"</span>,</span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"editorTextFocus"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 菜单</span></span><br><span class="line"><span class="attr">"menus"</span>: &#123;</span><br><span class="line"><span class="comment">// 编辑器右键菜单</span></span><br><span class="line"><span class="attr">"editor/context"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 表示只有编辑器具有焦点时才会在菜单中出现</span></span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"editorFocus"</span>,</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.sayHello"</span>,</span><br><span class="line"><span class="comment">// navigation是一个永远置顶的分组，后面的@6是人工进行组内排序</span></span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation@6"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"editorFocus"</span>,</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.getCurrentFilePath"</span>,</span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation@5"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 只有编辑器具有焦点，并且打开的是JS文件才会出现</span></span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"editorFocus &amp;&amp; resourceLangId == javascript"</span>,</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.testMenuShow"</span>,</span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"z_commands"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.openWebview"</span>,</span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 编辑器右上角图标，不配置图片就显示文字</span></span><br><span class="line"><span class="attr">"editor/title"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"editorFocus &amp;&amp; resourceLangId == javascript"</span>,</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.testMenuShow"</span>,</span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 编辑器标题右键菜单</span></span><br><span class="line"><span class="attr">"editor/title/context"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"resourceLangId == javascript"</span>,</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.testMenuShow"</span>,</span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 资源管理器右键菜单</span></span><br><span class="line"><span class="attr">"explorer/context"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.getCurrentFilePath"</span>,</span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.openWebview"</span>,</span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 代码片段</span></span><br><span class="line"><span class="attr">"snippets"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"language"</span>: <span class="string">"javascript"</span>,</span><br><span class="line"><span class="attr">"path"</span>: <span class="string">"./snippets/javascript.json"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"language"</span>: <span class="string">"html"</span>,</span><br><span class="line"><span class="attr">"path"</span>: <span class="string">"./snippets/html.json"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 自定义新的activitybar图标，也就是左侧侧边栏大的图标</span></span><br><span class="line"><span class="attr">"viewsContainers"</span>: &#123;</span><br><span class="line"><span class="attr">"activitybar"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"beautifulGirl"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"美女"</span>,</span><br><span class="line"><span class="attr">"icon"</span>: <span class="string">"images/beautifulGirl.svg"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 自定义侧边栏内view的实现</span></span><br><span class="line"><span class="attr">"views"</span>: &#123;</span><br><span class="line"><span class="comment">// 和 viewsContainers 的id对应</span></span><br><span class="line"><span class="attr">"beautifulGirl"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"beautifulGirl1"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"国内美女"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"beautifulGirl2"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"国外美女"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"beautifulGirl3"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"人妖"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 图标主题</span></span><br><span class="line"><span class="attr">"iconThemes"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"testIconTheme"</span>,</span><br><span class="line"><span class="attr">"label"</span>: <span class="string">"测试图标主题"</span>,</span><br><span class="line"><span class="attr">"path"</span>: <span class="string">"./theme/icon-theme.json"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 同 npm scripts</span></span><br><span class="line"><span class="attr">"scripts"</span>: &#123;</span><br><span class="line"><span class="attr">"postinstall"</span>: <span class="string">"node ./node_modules/vscode/bin/install"</span>,</span><br><span class="line"><span class="attr">"test"</span>: <span class="string">"node ./node_modules/vscode/bin/test"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 开发依赖</span></span><br><span class="line"><span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line"><span class="attr">"typescript"</span>: <span class="string">"^2.6.1"</span>,</span><br><span class="line"><span class="attr">"vscode"</span>: <span class="string">"^1.1.6"</span>,</span><br><span class="line"><span class="attr">"eslint"</span>: <span class="string">"^4.11.0"</span>,</span><br><span class="line"><span class="attr">"@types/node"</span>: <span class="string">"^7.0.43"</span>,</span><br><span class="line"><span class="attr">"@types/mocha"</span>: <span class="string">"^2.2.42"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 后面这几个应该不用介绍了</span></span><br><span class="line"><span class="attr">"license"</span>: <span class="string">"SEE LICENSE IN LICENSE.txt"</span>,</span><br><span class="line"><span class="attr">"bugs"</span>: &#123;</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"https://github.com/sxei/vscode-plugin-demo/issues"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"repository"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"https://github.com/sxei/vscode-plugin-demo"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 主页</span></span><br><span class="line"><span class="attr">"homepage"</span>: <span class="string">"https://github.com/sxei/vscode-plugin-demo/blob/master/README.md"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>前面项目构建完成后运行看效果实际上完成了三件事：</p><ul><li>注册<strong>onCommand</strong>的激活事件：<code>onCommand:extension.helloWorld</code>，所以插件会在运行Hello World命令的时候被激活。</li><li>在<code>contributes.commands</code>配置 Hello World命令，并绑定到<code>extension.helloWorld</code>上</li><li>使用VSCode API <code>commands.registerCommand</code>绑定方法到已经注册的命令ID<code>extension.helloWorld</code>上</li></ul><h4 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h4><p>在extension.ts中，添加以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.subscriptions.push(vscode.commands.registerCommand(<span class="string">'extension.sayHello'</span>, () =&gt; &#123;</span><br><span class="line">vscode.window.showInformationMessage(<span class="string">'您执行了extension.sayHello命令！'</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>然后在package.json清单位置，添加声明</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"commands": [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.sayHello"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>说明：<code>vscode.commands.registerCommand</code>是注册命令的API，返回Disposable，最后将结果放到<code>context.subscriptions</code>中</p><p><strong>回调函数参数</strong></p><p>注册命令回调函数可接受uri参数</p><blockquote><ul><li>注册资源管理器右键命令时，会把选中的资源路径uri传到回调函数中；</li><li>在编辑器打开文件中右键，则会将当前文件路径回调回去；</li><li>使用ctrl+shift+p执行命令时，则uir为空；</li></ul></blockquote><p>在extension.ts中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.subscriptions.push(vscode.commands.registerCommand(<span class="string">'extension.showMyPath'</span>, (uri)=&gt;&#123;</span><br><span class="line">vscode.window.showInformationMessage(<span class="string">`当前文件路径：<span class="subst">$&#123;uri ? uri.path : <span class="string">'kk'</span>&#125;</span>`</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>package.json添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"menus": &#123;</span><br><span class="line">    "editor/context": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"when"</span>: <span class="string">"editorFocus"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"extension.showMyPath"</span>,</span><br><span class="line">            <span class="attr">"group"</span>: <span class="string">"navigation"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "explorer/context": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"extension.showMyPath"</span>,</span><br><span class="line">            <span class="attr">"group"</span>: <span class="string">"navigation"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建菜单"><a href="#创建菜单" class="headerlink" title="创建菜单"></a>创建菜单</h3><p>一个菜单项创建如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"contributes": &#123;</span><br><span class="line">"menus": &#123;</span><br><span class="line">"editor/title": [&#123;</span><br><span class="line">"when": "resourceLangId == markdown",</span><br><span class="line">"command": "markdown.showPreview",</span><br><span class="line">"alt": "markdown.showPreviewToSide",</span><br><span class="line">"group": "navigation"</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>editor/title</code>是key值，定义这个菜单出现在哪里；</p></li><li><p><code>when</code>控制菜单合适出现；</p></li><li><p><code>command</code>定义菜单被点击后要执行什么操作；</p></li><li><p><code>alt</code>定义备用命令，按住<code>alt</code>键打开菜单时将执行对应命令；</p></li><li><p><code>group</code>定义菜单分组；</p></li></ul><h4 id="插件位置选择"><a href="#插件位置选择" class="headerlink" title="插件位置选择"></a><strong>插件位置选择</strong></h4><ul><li>资源管理器上下文菜单 - <code>explorer/context</code></li><li>编辑器上下文菜单 - <code>editor/context</code></li><li>编辑标题菜单栏 - <code>editor/title</code></li><li>编辑器标题上下文菜单 - <code>editor/title/context</code></li><li>调试callstack视图上下文菜单 - <code>debug/callstack/context</code></li><li>SCM标题菜单 -<code>scm/title</code></li><li>SCM资源组菜单 -<code>scm/resourceGroup/context</code></li><li>SCM资源菜单 -<code>scm/resource/context</code></li><li>SCM更改标题菜单 -<code>scm/change/title</code></li><li>左侧视图标题菜单 -<code>view/title</code></li><li>视图项菜单 -<code>view/item/context</code></li><li>控制命令是否显示在命令选项板中 - <code>commandPalette</code></li></ul><p>图标在<code>commands</code>里面配置，light和dark分别对应浅色和深色主题，如果不配置图标则直接显示文字：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"commands": [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.testMenuShow"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"这个菜单仅在JS文件中出现"</span>,</span><br><span class="line"><span class="attr">"icon"</span>: &#123;</span><br><span class="line"><span class="attr">"light"</span>: <span class="string">"./images/tool-light.svg"</span>,</span><br><span class="line"><span class="attr">"dark"</span>: <span class="string">"./images/tool-light.svg"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="时机when"><a href="#时机when" class="headerlink" title="时机when"></a>时机when</h4><p>通过可选的when语句，<code>VS Code</code>可以很好地控制什么时候显示菜单项，当然，when语句语法不仅仅适用于菜单项的控制。</p><p>when语句语法有很多，这里列举几个常用的：</p><ul><li><code>resourceLangId == javascript</code>：当编辑的文件是js文件时；</li><li><code>resourceFilename == test.js</code>：当当前打开文件名是<code>test.js</code>时；</li><li><code>isLinux</code>、<code>isMac</code>、<code>isWindows</code>：判断当前操作系统；</li><li><code>editorFocus</code>：编辑器具有焦点时；</li><li><code>editorHasSelection</code>：编辑器中有文本被选中时；</li><li><code>view == someViewId</code>：当当前视图ID等于<code>someViewId</code>时；</li><li>等等等</li></ul><p>多个条件可以通过与或非进行组合，例如：<code>editorFocus &amp;&amp; isWindows &amp;&amp; resourceLangId == javascript</code>。</p><p>有关when语句的更多完整语法请参考官方文档：<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts" target="_blank" rel="noopener">https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts</a></p><h4 id="alt"><a href="#alt" class="headerlink" title="alt"></a>alt</h4><p><code>alt</code>很好理解，表示没有按下alt键时，点击右键菜单执行的是<code>command</code>对应的命令，而按下了alt键后执行的是alt对应的命令。这里不做过多解释。</p><h4 id="group"><a href="#group" class="headerlink" title="group"></a>group</h4><h5 id="组间排序"><a href="#组间排序" class="headerlink" title="组间排序"></a>组间排序</h5><p>控制菜单的分组和排序。不同的菜单拥有不同的默认分组</p><p><code>editor/context</code>中有这些默认组：</p><ul><li><code>navigation</code>- 放在这个组的永远排在最前面；</li><li><code>1_modification</code> - 更改组；</li><li><code>9_cutcopypaste</code> - 编辑组</li><li><code>z_commands</code> - 最后一个默认组，其中包含用于打开命令选项板的条目。</li></ul><p><img src="http://lgx.itengshe.com/20200815131125.png" alt=""></p><p>除了<code>navigation</code>是强制放在最前面之外，其它分组都是按照0-9、a-z的顺序排列的，所以如果你想在<code>1_modification</code>和<code>9_cutcopypaste</code>插入一个新的组别的话，你可以定义一个诸如<code>6_test</code>：</p><p><code>explorer/context</code>有这些默认组：</p><ul><li>navigation - 放在这个组的永远排在最前面；</li><li>2_workspace - 与工作空间操作相关的命令。</li><li>3_compare - 与差异编辑器中的文件比较相关的命令。</li><li>4_search - 与在搜索视图中搜索相关的命令。</li><li>5_cutcopypaste - 与剪切，复制和粘贴文件相关的命令。</li><li>7_modification - 与修改文件相关的命令。</li></ul><p>在<code>编辑器选项卡上下文菜单</code>有这些默认组：</p><ul><li>1_close - 与关闭编辑器相关的命令。</li><li>3_preview - 与固定编辑器相关的命令。</li></ul><p>在<code>editor/title</code>有这些默认组：</p><ul><li>1_diff - 与使用差异编辑器相关的命令。</li><li>3_open - 与打开编辑器相关的命令。</li><li>5_close - 与关闭编辑器相关的命令。</li></ul><h5 id="组内排序"><a href="#组内排序" class="headerlink" title="组内排序"></a>组内排序</h5><p>默认同一个组的顺序取决于菜单名称，如果想自定义排序的话可以再组后面通过<code>@&lt;number&gt;</code>的方式来自定义顺序，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"editor/context": [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"editorFocus"</span>,</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.sayHello"</span>,</span><br><span class="line"><span class="comment">// 强制放在navigation组的第2个</span></span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation@2"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"when"</span>: <span class="string">"editorFocus"</span>,</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.demo.getCurrentFilePath"</span>,</span><br><span class="line"><span class="comment">// 强制放在navigation组的第1个</span></span><br><span class="line"><span class="attr">"group"</span>: <span class="string">"navigation@1"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"contributes": &#123;</span><br><span class="line">"keybindings": [&#123;</span><br><span class="line"><span class="comment">// 指定快捷键执行的操作</span></span><br><span class="line">"command": "extension.sayHello",</span><br><span class="line"><span class="comment">// windows下快捷键</span></span><br><span class="line">"key": "ctrl+f10",</span><br><span class="line"><span class="comment">// mac下快捷键</span></span><br><span class="line">"mac": "cmd+f10",</span><br><span class="line"><span class="comment">// 快捷键何时生效</span></span><br><span class="line">"when": "editorTextFocus"</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想了解更多有关快捷键绑定的详细细节可以继续阅读官方文档：<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">https://code.visualstudio.com/docs/getstarted/keybindings</a></p><hr><h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><h4 id="本地打包"><a href="#本地打包" class="headerlink" title="本地打包"></a>本地打包</h4><p>打包需要借助vsce工具，先安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vsce -g</span><br></pre></td></tr></table></figure><p>cd到项目根目录，运行打包命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce package</span><br></pre></td></tr></table></figure><p>生成的vsix，可在vscode插件窗口，右上角选择<code>Install from VSIX</code>安装</p><h4 id="发布到应用市场"><a href="#发布到应用市场" class="headerlink" title="发布到应用市场"></a>发布到应用市场</h4><ol><li><p>注册Miscrosoft账户，已经有账户的直接进入下一步</p><p>注册地址：<a href="https://login.live.com/" target="_blank" rel="noopener">https://login.live.com/</a></p></li><li><p>访问<a href="https://aka.ms/SignupAzureDevOps" target="_blank" rel="noopener">https://aka.ms/SignupAzureDevOps</a>，没使用过会出现如下提示框，直接点继续</p><p><img src="http://lgx.itengshe.com/20200815211354.png" alt=""></p></li><li><p>创建令牌</p><p>进入组织主页后，点击右上角，选择<code>Personal access tokens</code></p><p><img src="http://lgx.itengshe.com/20200815211900.png" alt=""></p><p>选择New Token，会出现下面界面，<code>Organization</code>要选择<code>all accessible organizations</code>，<code>Scopes</code>要选择<code>Full access</code>，否则后面发布会失败。</p><p><img src="http://lgx.itengshe.com/20200815212302.png" alt=""></p><p>随后就会生成一个令牌，此时必须拷贝保存起来，要是忘了就找不回来了。</p></li><li><p>创建发布账户</p><p>获得令牌后，接下来创建发布者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce create-publisher your-publisher-name</span><br></pre></td></tr></table></figure><p>此处<code>your-publisher-name</code>需要以字母数字下划线组成，然后依次输入昵称，邮箱，和刚才生成的令牌。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E:\Projects\vscode_extension\plugin-bear (master) (bear@0.0.1)</span><br><span class="line">λ vsce create-publisher lgx123</span><br><span class="line">Publisher human-friendly name: (lgx123) 呵呵到天亮</span><br><span class="line">E-mail: 1134569285@qq.com</span><br><span class="line">Personal Access Token: ****************************************************</span><br><span class="line"> DONE  Created publisher 'lgx123'.</span><br></pre></td></tr></table></figure><p>创建成功后，默认会登陆这个账户，假如已经创建过账户了，可以直接登陆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce login your-publisher-name</span><br></pre></td></tr></table></figure><p>也可以用网页版来创建发布账户：<a href="https://marketplace.visualstudio.com/manage" target="_blank" rel="noopener">https://marketplace.visualstudio.com/manage</a></p></li><li><p>发布</p><p>上面登陆好发布者账户后，直接可以运行发布命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce publish</span><br></pre></td></tr></table></figure><p>成功结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vsce publish</span><br><span class="line">Executing prepublish script 'npm run vscode:prepublish'...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bear@0.0.1 vscode:prepublish E:\Projects\vscode_extension\plugin-bear</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> npm run compile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bear@0.0.1 compile E:\Projects\vscode_extension\plugin-bear</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tsc -p ./</span></span><br><span class="line"></span><br><span class="line">Personal Access Token for publisher 'lgx': ****************************************************</span><br><span class="line"></span><br><span class="line">Publishing lgx.bear@0.0.1...</span><br><span class="line"> DONE  Published lgx.bear@0.0.1</span><br><span class="line">Your extension will live at https://marketplace.visualstudio.com/items?itemName=lgx.bear (might take a few minutes for it to show up).</span><br></pre></td></tr></table></figure><p>发布成功稍等几分钟即可在应用市场搜到，也可在vscode网页应用市场搜到</p><p><a href="https://marketplace.visualstudio.com/items?itemName=lgx.bear" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=lgx.bear</a></p><p><img src="http://lgx.itengshe.com/20200815214537.png" alt=""></p></li><li><p>发布注意事项</p></li></ol><ul><li><code>README.md</code>文件默认会显示在插件主页；</li><li><code>README.md</code>中的资源必须全部是<code>HTTPS</code>的，如果是<code>HTTP</code>会发布失败；</li><li><code>CHANGELOG.md</code>会显示在变更选项卡；</li><li>如果代码是放在git仓库并且设置了repository字段，发布前必须先提交git，否则会提示<code>Git working directory not clean</code>；</li></ul><ol><li><p>增量发布</p><p>版本号：<code>major.minor.patch</code></p><p>如果想让发布之后版本号的patch自增，例如：<code>1.0.2</code> -&gt; <code>1.0.3</code>，可以这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce publish patch</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vsce publish patch</span><br><span class="line">v0.0.2</span><br><span class="line">Executing prepublish script 'npm run vscode:prepublish'...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bear@0.0.2 vscode:prepublish E:\Projects\vscode_extension\plugin-bear</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> npm run compile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bear@0.0.2 compile E:\Projects\vscode_extension\plugin-bear</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tsc -p ./</span></span><br><span class="line"></span><br><span class="line">Publishing lgx.bear@0.0.2...</span><br><span class="line"> DONE  Published lgx.bear@0.0.2</span><br><span class="line">Your extension will live at https://marketplace.visualstudio.com/items?itemName=lgx.bear (might take a few minutes for it to show up).</span><br></pre></td></tr></table></figure><p>执行这个命令后会自动修改<code>package.json</code>里面的版本号。同理，<code>vsce publish minor</code>也是可以的。</p></li><li><p>取消发布</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce unpublish (publisher name).(extension name)</span><br></pre></td></tr></table></figure></li><li><p>更新</p><p>如果修改了插件代码想要重新发布，只需要修改版本号然后重新执行<code>vsce publish</code>即可</p></li><li><p>vsce 其他命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash"> vsce --<span class="built_in">help</span></span></span><br><span class="line">    </span><br><span class="line"> Usage: vsce [options] [command]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> Options:</span><br><span class="line">    </span><br><span class="line">   -V, --version  output the version number</span><br><span class="line">   -h, --help     output usage information</span><br><span class="line">    </span><br><span class="line">Commands:</span><br><span class="line">    </span><br><span class="line">   ls [options]                         列出实际会发布的文件列表</span><br><span class="line">   package [options]                    打包成一个插件</span><br><span class="line">   publish [options] [&lt;version&gt;]        发布插件</span><br><span class="line">   unpublish [options] [&lt;extensionid&gt;]  插件下架</span><br><span class="line">   list &lt;publisher&gt;                     列出某个发布者下所有发布的,需要配置好token 额,不然会提示输入</span><br><span class="line">   ls-publishers                        列出所有已知的发布者</span><br><span class="line">   create-publisher &lt;publisher&gt;         创建一个新的发布者</span><br><span class="line">   delete-publisher &lt;publisher&gt;         删除一个发布者</span><br><span class="line">   login &lt;publisher&gt;                    登录一个发布者到发布者列表中</span><br><span class="line">   logout &lt;publisher&gt;                   反之,退出发布者</span><br></pre></td></tr></table></figure></li></ol><ol><li></li></ol><blockquote><p>本文大部分内容出自<a href="http://blog.haoji.me/?tag=vscode" target="_blank" rel="noopener">http://blog.haoji.me/?tag=vscode</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;项目创建&quot;&gt;&lt;a href=&quot;#项目创建&quot; class=&quot;headerlink&quot; title=&quot;项目创建&quot;&gt;&lt;/a&gt;项目创建&lt;/h3&gt;&lt;h4 id=&quot;1-安装脚手架&quot;&gt;&lt;a href=&quot;#1-安装脚手架&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Unity 3D使用protobuf 导excel表格数据</title>
    <link href="http://yoursite.com/2020/08/08/unity/Unity3D%E4%BD%BF%E7%94%A8protobuf%E5%AF%BCexcel%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2020/08/08/unity/Unity3D%E4%BD%BF%E7%94%A8protobuf%E5%AF%BCexcel%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/</id>
    <published>2020-08-08T08:38:22.000Z</published>
    <updated>2020-09-14T03:01:41.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-资源下载"><a href="#1-资源下载" class="headerlink" title="1.资源下载"></a>1.资源下载</h3><p><a href="https://github.com/protocolbuffers/protobuf/releases/download/v2.5.0/protobuf-2.5.0.zip" target="_blank" rel="noopener">protobuf-2.5.0.zip</a></p><p><a href="https://github.com/protocolbuffers/protobuf/releases/download/v2.5.0/protoc-2.5.0-win32.zip" target="_blank" rel="noopener">protoc-2.5.0-win32.zip</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-资源下载&quot;&gt;&lt;a href=&quot;#1-资源下载&quot; class=&quot;headerlink&quot; title=&quot;1.资源下载&quot;&gt;&lt;/a&gt;1.资源下载&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/protocolbuffers/protobuf/r
      
    
    </summary>
    
    
      <category term="Unity 3D" scheme="http://yoursite.com/categories/Unity-3D/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity接入tolua框架</title>
    <link href="http://yoursite.com/2020/08/03/unity/Unity%E6%8E%A5%E5%85%A5tolua%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/08/03/unity/Unity%E6%8E%A5%E5%85%A5tolua%E6%A1%86%E6%9E%B6/</id>
    <published>2020-08-03T10:49:10.000Z</published>
    <updated>2020-09-14T03:01:41.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里我们不使用tolua框架本身的项目，而是在我们已有的工程项目中接入tolua热更框架。</p></blockquote><h3 id="引入tolua"><a href="#引入tolua" class="headerlink" title="引入tolua"></a>引入tolua</h3><ol><li><p>下载tolua资源</p><p>在引入tolua到我们的项目之前，需要下载tolua的资源包：<a href="https://github.com/topameng/tolua/archive/master.zip" target="_blank" rel="noopener">tolua资源包</a></p></li><li><p>资源引入项目中</p><p>上面下载完tolua资源后，我们得到 tolua-master.zip 一个，解压后即可看到这样的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├─Assets</span><br><span class="line">│  ├─Editor</span><br><span class="line">│  ├─Lua</span><br><span class="line">│  ├─Plugins</span><br><span class="line">│  ├─Source</span><br><span class="line">│  └─ToLua</span><br><span class="line">├─Luajit</span><br><span class="line">├─Luajit64</span><br><span class="line">├─ProjectSettings</span><br><span class="line">└─Unity5.x</span><br></pre></td></tr></table></figure><p>我们需要的只是Assets中的文件，将Assets文件夹中所有文件都复制到我们项目的Assets目录中。</p></li><li><p>生成常用类型注册文件</p><p>将上面文件复制到我们项目对应目录后，在Uinty窗口会弹出这样一个窗口，点确定即可：</p><p><img src="http://lgx.itengshe.com/20200803165853.png" alt=""></p></li></ol><hr><h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><p>在刚引入到项目中的Tolua\Msic中，有一个LuaClient.cs文件，这是tolua为我们封装好的启动接口，可以继承这个类来编写我们自己的tolua管理器，这里我们建立一个LuaMgr.cs，继承自LuaClient，并重写两个接口：InitLoader和LoadLuaFiles</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> LuaInterface;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaMgr</span> : <span class="title">LuaClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> LuaFileUtils <span class="title">InitLoader</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LuaResLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LoadLuaFiles</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="comment">// 添加编辑器环境下获取 lua 脚本的路径（Assets/lua）</span></span><br><span class="line">        luaState.AddSearchPath(Application.dataPath + <span class="string">"/lua"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        OnLoadFinished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在游戏控制中心脚本GameMgr的Awake方法中，启动lua管理器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameMgr</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GameMgr _instance;</span><br><span class="line">    <span class="keyword">private</span> LuaMgr _luaMgr = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameMgr Instance&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123; <span class="keyword">return</span> _instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        _instance = <span class="keyword">this</span>;</span><br><span class="line">        transform.name = <span class="string">"GameMgr"</span>;</span><br><span class="line">        GameObject.DontDestroyOnLoad(gameObject);</span><br><span class="line">        StartCoroutine(Init());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Screen.sleepTimeout = SleepTimeout.NeverSleep;  <span class="comment">//阻止息屏</span></span><br><span class="line">        Debug.Log(<span class="string">"-- GameMgr Start"</span>);</span><br><span class="line">        _luaMgr = gameObject.AddComponent&lt;LuaMgr&gt;();</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动我们的游戏，此时可以看到打印出这样的信息：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">32</span>:<span class="number">10.921</span><span class="number">-0</span>: LuaState start</span><br><span class="line">UnityEngine.Debug:Log(Object)</span><br></pre></td></tr></table></figure><p>这是在lua中打印出来的日志，具体位置：Assets/Lua/Main.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--主入口函数。从这里开始lua逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"logic start"</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--场景切换通知</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OnLevelWasLoaded</span><span class="params">(level)</span></span></span><br><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">"collect"</span>)</span><br><span class="line">Time.timeSinceLevelLoad = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OnApplicationQuit</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>至此，tolua框架算是引入成功了。</p><hr><h3 id="目录结构整理"><a href="#目录结构整理" class="headerlink" title="目录结构整理"></a>目录结构整理</h3><p>导入tolua资源后，Assets目录结构不一定符合我们的要求，需要根据需要进行调整，tolua框架也支持我们这么做。</p><ol><li><p>修改Generate目录</p><p>Assets/Source/Generate目录用来保存tolua生成的可供lua调用的C#类的绑定类，我们项目希望将其放在Assets/Code/Module/Lua目录下，修改只需要打开Assets/Editor/Custom/CustomSettings.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> saveDir = Application.dataPath + <span class="string">"/Source/Generate/"</span>;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> saveDir = Application.dataPath + <span class="string">"/Code/Module/Lua/Generate/"</span>;</span><br></pre></td></tr></table></figure><p>然后将Assets/Source/LuaConst.cs移动到Assets/Code/Module/Lua中，并在此目录中创一个Generate目录，然后将鼠标焦点移到Unity编辑器，又会弹出之前的“点击确定自动生成常用类型注册文件，也可通过菜单逐步完成此功能”窗口，依旧点确定即可</p><p><img src="http://lgx.itengshe.com/20200803165853.png" alt=""></p><p>然后就可以在Assets/Code/Module/Lua/Generate/目录中看到一堆*wrap.cs文件，还能在unity编辑器中看到一堆报错~~~，这是因为我们自己生成了一份wrap.cs文件，跟原来的那堆文件重名了，只需要把Source目录删除即可，这样就成功修改了存放wrap.cs文件的目录。</p></li><li><p>修改Tolua目录</p><p>Assets/Tolua目录是tolua框架的核心库存放的地方，但是我们习惯将第三方插件存放在项目的Assets/ThirdParty目录下，这里我们直接将Tolua目录挪到Assets/ThirdParty目录下，然后修改以下配置：</p><ol><li><p><code>LuaConst.cs</code> 中的 <code>toluaDir</code> ：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> toluaDir = Application.dataPath + <span class="string">"/ThirdParty/ToLua/Lua"</span>;        <span class="comment">//tolua lua文件目录</span></span><br></pre></td></tr></table></figure></li><li><p><code>CustomSettings.cs</code> 中的 <code>toluaBaseType</code> ：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> toluaBaseType = Application.dataPath + <span class="string">"/ThirdParty/ToLua/BaseType/"</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>修改入口文件main.lua的位置</p><p>我们希望将lua的入口文件放置到Assets/Code/Lua目录下，只需要将Assets/Lua整个目录移动到Assets/Code下，然后修改LuaConst.cs文件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> luaDir = Application.dataPath + <span class="string">"/Code/Lua"</span>;                <span class="comment">//lua逻辑代码目录</span></span><br></pre></td></tr></table></figure></li><li><p>Done</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这里我们不使用tolua框架本身的项目，而是在我们已有的工程项目中接入tolua热更框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引入tolua&quot;&gt;&lt;a href=&quot;#引入tolua&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
    
      <category term="Unity 3D" scheme="http://yoursite.com/tags/Unity-3D/"/>
    
  </entry>
  
  <entry>
    <title>C语言</title>
    <link href="http://yoursite.com/2020/08/02/C/C%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2020/08/02/C/C%E8%AF%AD%E8%A8%80/</id>
    <published>2020-08-02T03:19:40.000Z</published>
    <updated>2020-09-14T03:01:41.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-第一段C"><a href="#一-第一段C" class="headerlink" title="一. 第一段C"></a>一. 第一段C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li><h1 id="include-引入头文件"><a href="#include-引入头文件" class="headerlink" title="include : 引入头文件"></a>include : 引入头文件</h1></li><li><p>所有程序从main函数开始执行。</p></li><li><p>printf：格式化输出到屏幕，依赖stdio.h头文件。</p></li><li><p>stdio.h ：标准输入输出头文件，使用printf()函数时，没提前引入此头文件会编译出错</p></li><li><p>return 0：退出程序。</p></li></ul><h3 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二. 数据类型"></a>二. 数据类型</h3><ol><li><p>基本类型：算术类型，包括</p><ul><li>整数类型</li><li>浮点类型</li></ul></li><li><p>枚举类型</p><p>也是算术类型，用来定义在程序中只能赋予一定的离散整数值的变量</p></li><li><p>void类型</p><p>类型说明符void说明没有可用的值。</p></li><li><p>派生类型</p><ul><li>指针类型</li><li>数组类型</li><li>结构类型：<strong>数组类型</strong>和<strong>结构类型</strong>统称为<strong>聚合类型</strong></li><li>共用体类型</li><li>函数类型：指的是函数返回值的类型</li></ul></li></ol><h4 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1. 整数类型"></a>1. 整数类型</h4><p>标准整数类型的的存储大小和值范围</p><div class="table-container"><table><thead><tr><th>类型</th><th>存储大小(字节)</th><th>值范围</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>-128到127或0到255</td></tr><tr><td>unsigned char</td><td>1</td><td>0到255</td></tr><tr><td>signed char</td><td>1</td><td>-128到127</td></tr><tr><td>int</td><td>2或4</td><td>-32768到32767或-2147483648到2147483647</td></tr><tr><td>unsigned int</td><td>2或4</td><td>0到65535或0到4294967295</td></tr><tr><td>short</td><td>2</td><td>-32768到32767</td></tr><tr><td>unsigned</td><td>2</td><td>0到65535</td></tr><tr><td>long</td><td>4</td><td>-2147483648到2147483647</td></tr><tr><td>unsigned</td><td>4</td><td>0到4294967295</td></tr></tbody></table></div><p>各种数据类型存储大小和系统位数有关，需要得到该类型在当前系统上的大小，可以使用sizeof运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int 的大小：%lu \n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> 存储大小 : <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a>2. 浮点型</h4><p>标准浮点型的存储大小，值范围，精度：</p><div class="table-container"><table><thead><tr><th>类型</th><th>存储大小（字节）</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td>float</td><td>4</td><td>1.2E-38 到 3.4E+38</td><td>6 位小数</td></tr><tr><td>double</td><td>8</td><td>2.3E-308 到 1.7E+308</td><td>15位小数</td></tr><tr><td>long double</td><td>16</td><td>3.4E-4932 到 1.1E+4932</td><td>19 位小数</td></tr></tbody></table></div><p>在程序中可以这样获得以上这些值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float 存储大小：%lu \n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float 最小值：%E \n"</span>, FLT_MIN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float 最大值：%E \n"</span>, FLT_MAX);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float 精度：%d\n"</span>, FLT_DIG);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：%E是以指数形式输出单，双精度实数</p><h3 id="三-变量"><a href="#三-变量" class="headerlink" title="三. 变量"></a>三. 变量</h3><p>变量其实只是程序可操作的存储区的名称。C语言中，每个变量都有类型，类型决定变量存储的大小。</p><p>变量命名必须以字母或下划线开头，后面可以跟着数字，字母和下划线，并且字母区分大小写。</p><h4 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1. 变量定义"></a>1. 变量定义</h4><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。定义的时候需指定变量的数据类型，并包含一个或多个变量列表。</p><p>以下为变量的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="keyword">char</span> d;</span><br><span class="line"><span class="keyword">float</span> e, f;</span><br><span class="line"><span class="keyword">double</span> g;</span><br></pre></td></tr></table></figure><p>写多个变量名表示同事创建多个变量。</p><p>变量的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h4 id="2-变量的声明"><a href="#2-变量的声明" class="headerlink" title="2. 变量的声明"></a>2. 变量的声明</h4><p>变量的声明向编译器保证变量以指定的类型和名称存在，变量的声明有两种情况：</p><ol><li><p>需要建立存储空间。</p><p>例如：int a在声明的时候就建立了存储空间。</p></li><li><p>不需要建立存储空间。</p><p>通过extern关键字声明的变量名而不定义他，如：extern int a，a变量可以不在这定义，而是在其他文件进行定义</p><p>除有extern关键字的，都是变量的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a; <span class="comment">//变量的声明</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">//变量的声明，也是变量的定义</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-左值-Lvalues-和右值-Rvalues"><a href="#3-左值-Lvalues-和右值-Rvalues" class="headerlink" title="3. 左值(Lvalues)和右值(Rvalues)"></a>3. 左值(Lvalues)和右值(Rvalues)</h4><p>C中有两种类型的表达式：</p><ol><li><p>左值</p><p>指向内存位置的表达式称为左值表达式，左值表达式可出现在“=”左边或右边。</p></li><li><p>右值</p><p>右值指的是存储在内存中某些地址的数值。右值不能进行赋值，也就是说右值不能出现在“=”左边，只能存在右边。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//a为左值，指向数字1在内存中所在的地址，故a可在等号左边和右边</span></span><br><span class="line"><span class="keyword">int</span> b = a；</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> = <span class="number">2</span>; <span class="comment">// 数值型为右值型，只能在等号右边，所以这样写会报错。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="四-常量"><a href="#四-常量" class="headerlink" title="四. 常量"></a>四. 常量</h3><p>常量是固定值，在程序执行过程不会改变，这些固定的值也叫<strong>字面量</strong>。常量的值在定义后不能进行修改。</p><p>常量可以是任何基本数据类型，如字符常量，整数常量等。</p><h4 id="1-整数常量"><a href="#1-整数常量" class="headerlink" title="1. 整数常量"></a>1. 整数常量</h4><p> 带前缀整数常量可以是：</p><ul><li>十进制：不带前缀</li><li>八进制：0为前缀</li><li>十六进制：0x或0X为前缀</li></ul><p>带后缀整数常量(后缀可大写可小写)：</p><ul><li>后缀 U (或u)：无符号整数(unsigned)</li><li>后缀 L (或l)：长整数(long)</li><li>UL或LU：无符号长整型</li></ul><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span><span class="comment">//十进制</span></span><br><span class="line"><span class="number">0123</span><span class="comment">//八进制</span></span><br><span class="line"><span class="number">0x4b</span><span class="comment">//十六进制</span></span><br><span class="line"><span class="number">3</span><span class="comment">//整数</span></span><br><span class="line"><span class="number">3u</span><span class="comment">//无符号整数</span></span><br><span class="line"><span class="number">3l</span><span class="comment">//长整数</span></span><br><span class="line"><span class="number">3u</span>l<span class="comment">//无符号长整数</span></span><br></pre></td></tr></table></figure><h4 id="2-浮点常量"><a href="#2-浮点常量" class="headerlink" title="2. 浮点常量"></a>2. 浮点常量</h4><p>浮点数由整数部分、小数点、小数部分、指数部分组成。浮点常量表现形式：</p><ul><li><p>小数形式：必须包含整数部分、小数部分，或两者都有</p></li><li><p>指数形式：必须包含小数点、指数，或两者都有</p></li></ul><h4 id="3-字符常量"><a href="#3-字符常量" class="headerlink" title="3. 字符常量"></a>3. 字符常量</h4><p>字符常量是在单引号中，可以是以下类型：</p><ul><li>普通字符：例如’x’</li><li>转义序列：例如:’\t’</li><li>通用字符：例如’\u02C0’</li></ul><h4 id="4-字符串常量"><a href="#4-字符串常量" class="headerlink" title="4. 字符串常量"></a>4. 字符串常量</h4><p>跟字符常量类似，但字符串常量括在双引号中””</p><h4 id="5-定义常量"><a href="#5-定义常量" class="headerlink" title="5. 定义常量"></a>5. 定义常量</h4><p>在C中，有两种方式定义常用：</p><ol><li><p>使用#define预处理器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10</span></span><br></pre></td></tr></table></figure></li><li><p>使用const关键字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LENGTH = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol><p>注意：<em>通常把常量定义为大写字母形式</em></p><h3 id="五-存储类"><a href="#五-存储类" class="headerlink" title="五. 存储类"></a>五. 存储类</h3><p>C程序中，存储类定义程序中变量、函数的范围（可见性）和生命周期，这些说明符房子啊他们所修饰的类型之前。下面是C程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li></ul><h4 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. auto</h4><p>auto存储类是所有局部变量默认的存储类，auto只能用在函数类，也就是说auto只能修饰局部变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 下面定义的变量其实带有相同的存储类 */</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-register"><a href="#2-register" class="headerlink" title="2. register"></a>2. register</h4><p>register存储类用于定义存储在<strong>寄存器</strong>的局部变量，而不是RAM中的局部变量，这意味着变量的最大尺寸等于寄存器的大小，而且不能用’&amp;’运算符对它进行运算(因为它没有内存位置)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-static"><a href="#3-static" class="headerlink" title="3. static"></a>3. static</h4><p>static存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在进入和离开作用域时进行创建和销毁。所以，使用static修饰的局部变量可以在函数之间调用保持局部变量的值。</p><p>使用static修饰全局变量时，会使变量的作用域限制在声明它的文件内。只要方法跟变量在同个文件内，都可调用该变量。</p><h4 id="4-extern"><a href="#4-extern" class="headerlink" title="4. extern"></a>4. extern</h4><p>extern存储类用于提供一个全局变量的引用，全局变量对所有程序文件都是可见的。</p><p>当使用extern时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当有多个文件，且定义一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern来得到已定义的变量或函数。extern就是用来在另一个文件中声明一个全局变量或函数。</p><p>文件一：main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">print_count</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//声明printcount.c中定义的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    count = <span class="number">10</span>;</span><br><span class="line">    print_count();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件二：printcount.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;<span class="comment">//声明在main.c中定义的count</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_count</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"count is %d\n"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count is <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="六-运算符"><a href="#六-运算符" class="headerlink" title="六. 运算符"></a>六. 运算符</h3><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符作用于位，并逐位执行操作，真值表如下：</p><div class="table-container"><table><thead><tr><th>p</th><th>q</th><th>p&amp;q(与)</th><th>p\</th><th>q(或)</th><th>p^q(异或)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>&lt;&lt;二进制左移运行：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）.</p><p>>&gt; 二进制右移运算：将一个数的二进制位全部右移若干位，正数左补0；负数左bu1，右边丢弃。</p><h4 id="杂项运算符"><a href="#杂项运算符" class="headerlink" title="杂项运算符"></a>杂项运算符</h4><ul><li>sizeof()：返回变量的大小</li><li>&amp;：返回变量的地址</li><li>*：指向一个变量</li></ul><h3 id="七-判断"><a href="#七-判断" class="headerlink" title="七. 判断"></a>七. 判断</h3><p>C语言中“非零即为真”，就是说<strong>非零</strong>和<strong>非空</strong>认定为true，<strong>零</strong>或null认定为false</p><h3 id="八-循环"><a href="#八-循环" class="headerlink" title="八. 循环"></a>八. 循环</h3><h4 id="for无限循环"><a href="#for无限循环" class="headerlink" title="for无限循环"></a>for无限循环</h4><p>由于构成for循环的三个表达式中任何一个都不是必须的，所以三个条件都为空就构成一个无限循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">    <span class="comment">//无限循环执行下去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九-函数"><a href="#九-函数" class="headerlink" title="九. 函数"></a>九. 函数</h3><p>函数是一组一起执行的任务语句。</p><p>函数的<strong>声明</strong>告诉编译器函数的名称、返回类型和参数；</p><p>函数的<strong>定义</strong>提供函数的实际主体。</p><h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><p>形参：如果函数要使用参数，则必须声明接受参数的变量，这些变量就称为函数的形参。形参在进入函数时被创建，退出函数时被销毁。</p><p>函数调用时的两种传递参数方式：</p><ul><li><p>传值调用</p><p>该方法把参数的实际值复制给函数的形参，此时修改函数的形参并不会影响实参</p></li><li><p>引用调用</p><p>通过指针传递，形参为指向实参地址的指针，当操作形参时，相当于同时在操作实参。</p></li></ul><p>默认情况下，C语言使用传值调用。</p><h3 id="十-枚举"><a href="#十-枚举" class="headerlink" title="十. 枚举"></a>十. 枚举</h3><p>第一个枚举成员的默认值为整型0，后续枚举成员的值在前一个成员加1。</p><p>枚举变量的定义，有三种方式：</p><ol><li><p>先定义枚举类型，再定义枚举变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY&#123;</span><br><span class="line">    MON = <span class="number">1</span>,</span><br><span class="line">    TUE,</span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> DAY day;</span><br></pre></td></tr></table></figure></li><li><p>定义枚举类型的同时定义枚举变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY&#123;</span><br><span class="line">    MON = <span class="number">1</span>,</span><br><span class="line">    TUE,</span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">&#125;day;</span><br></pre></td></tr></table></figure></li><li><p>省略枚举名称，直接定义枚举变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>&#123;</span><br><span class="line">    MON = <span class="number">1</span>,</span><br><span class="line">    TUE,</span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">&#125;day;</span><br></pre></td></tr></table></figure></li></ol><h3 id="十一-指针"><a href="#十一-指针" class="headerlink" title="十一. 指针"></a>十一. 指针</h3><p><strong>内存地址：</strong></p><p>每个变量都有一个内存位置，每个内存位置都定义了可使用连字号(&amp;)运算符访问的地址，它表示在内存中的一个地址。</p><p><strong>什么是指针?</strong></p><p>指针是一个变量，其值是另一个变量的地址，即，内存位置的直接地址。</p><p>实际数据类型，不管是整形，浮点型或者字符型等，对应的指针的值类型都是一样的，都是一个代表内存地址的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p><p><strong>使用指针：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *ip;</span><br><span class="line"></span><br><span class="line">    ip = &amp;var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"var 的地址：%p\n"</span>, &amp;var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"指针变量的值：%p\n"</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"指针所指的值：%d\n"</span>, *ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C中的Null指针</strong></p><p>声明变量时，如果没有确定可以赋值的地址，通常给指针变量赋NULL值，此时的指针称为<strong>空指针</strong>。</p><p>NULL指针是定义在标准库中值为零的常量，</p><h3 id="十二-函数指针"><a href="#十二-函数指针" class="headerlink" title="十二. 函数指针"></a>十二. 函数指针</h3><p>通常指针变量是指向例如整形，字符型等变量，而函数指针是指向函数的指针变量。</p><p>函数指针可用于调用函数，传递参数。</p><p><strong>回调函数</strong></p><p>函数指针作为某个函数的参数：</p><p>函数指针可以作为某个函数的参数来使用，回调函数就是一个通过函数指针调用的函数，也就是说回调函数是由别人的函数执行时调用你实现的函数。</p><h3 id="十三-结构体"><a href="#十三-结构体" class="headerlink" title="十三. 结构体"></a>十三. 结构体</h3><p>C数组允许存储相同类型的数据，<strong>结构</strong>是C语言中可由用户自定义的数据类型，它允许存储不同类型的数据项。</p><p><strong>定义结构</strong></p><p>使用struct语句定义一个包含多个成员的新数据类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line">    member1;</span><br><span class="line">    member2;</span><br><span class="line">    ...</span><br><span class="line">&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><ul><li>tag：结构体标签</li><li>member：标准的变量定义，比如int a。</li><li>variable-list：结构变量，定义在结构的末尾，可以指定一个或多个结构变量。</li></ul><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">50</span>];</span><br><span class="line">&#125;book;</span><br></pre></td></tr></table></figure><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，从而实现一些更高级的数据结构，比如<strong>树</strong>结构或者<strong>链表</strong>等。</p><p><strong>结构体变量的初始化</strong></p><p>结构体变量可以在定义时指定初始值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">50</span>];</span><br><span class="line">&#125;book = &#123;<span class="number">123456</span>, <span class="string">"C 语言"</span>, <span class="string">"hehe"</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>访问结构成员</strong></p><p>可以使用<strong>成员访问运算符(.)</strong>来访问结构成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> tilte[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(Book1.tilte, <span class="string">"C Programming"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(Book1.author, <span class="string">"hehe"</span>);</span><br><span class="line">    Book1.id = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Book1 title: %s\n"</span>, Book1.tilte);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Book1 author: %s\n"</span>, Book1.author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Book1 id: %d\n"</span>, Book1.id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book1 title: C Programming</span><br><span class="line">Book1 author: hehe</span><br><span class="line">Book1 id: <span class="number">123</span></span><br></pre></td></tr></table></figure><p><strong>指向结构的指针</strong></p><p>定义指向结构的指针方式跟定义指向其他类型变量的指针类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br></pre></td></tr></table></figure><p>给结构指针变量赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcut_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure><p>为了使用指向该结构的指针访问结构成员，需使用-&gt;运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure><p>上面例子使用结构的指针来访问成员变量来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> tilte[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br><span class="line"></span><br><span class="line">    struct_pointer = &amp;Book1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(Book1.tilte, <span class="string">"C Programming"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(Book1.author, <span class="string">"hehe"</span>);</span><br><span class="line">    Book1.id = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Book1 title: %s\n"</span>, struct_pointer-&gt;tilte);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Book1 author: %s\n"</span>, struct_pointer-&gt;author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Book1 id: %d\n"</span>, struct_pointer-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十四-共用体"><a href="#十四-共用体" class="headerlink" title="十四. 共用体"></a>十四. 共用体</h3><p>共用体是一种特殊的数据类型，允许在相同的内存中存储不同的数据类型。共用体可以定义多个成员变量，但任何时候只能有一个成员变量带有值。共用体提供一种使用相同内存位置的有效方式。</p><p><strong>定义共用体</strong></p><p>定义共用体，需使用union语句，方式跟结构体相似。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><p>共用体占用的内存为成员变量中最大的那个，例如上面例子中，Data占用10个字节。</p><p><strong>访问共用体成员</strong></p><p>访问共用体成员，可以使用<strong>成员访问符(.)</strong>。共用体变量的定义可以使用union，例如定义一个共用体类型的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unit Data data;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>同一时间只能使用一个变量。</p><h3 id="十五-typedef"><a href="#十五-typedef" class="headerlink" title="十五. typedef"></a>十五. typedef</h3><p>C语言中typedef关键字，可以用来为已有类型或者自定义的数据类型取一个新的名字。例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br></pre></td></tr></table></figure><p>这样重命名后，以后就可以用BYTE来定义unsigned char了，这好比给自己起了一个昵称之后，以后朋友可以用你原来的名字叫你，也可用昵称来叫你了。</p><p><strong>typedef 与#define的比较</strong>：</p><ul><li>typedef仅限为类型定义符号名称，#define不仅为类型定义别名，也能为数值定义别名，例如我们能将数字1定义为ONE</li><li>typedef是由<strong>编译器</strong>执行解释的，#define语句是<strong>预编译器</strong>进行处理的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-第一段C&quot;&gt;&lt;a href=&quot;#一-第一段C&quot; class=&quot;headerlink&quot; title=&quot;一. 第一段C&quot;&gt;&lt;/a&gt;一. 第一段C&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CMD命令</title>
    <link href="http://yoursite.com/2020/07/31/CMD/CMD%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/07/31/CMD/CMD%E5%91%BD%E4%BB%A4/</id>
    <published>2020-07-31T07:41:35.000Z</published>
    <updated>2020-09-14T03:01:41.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tree-——显示磁盘目录结构"><a href="#tree-——显示磁盘目录结构" class="headerlink" title="tree ——显示磁盘目录结构"></a>tree ——显示磁盘目录结构</h3><p>1．功能：显示指定驱动器上所有目录路径和这些目录下的所有文件名。<br>2．类型：外部命令<br>3．格式：TREE[盘符：][/F][》PRN]<br>4．使用说明：<br>（1）使用/F参数时显示所有目录及目录下的所有文件，省略时，只显示目录，不显示目录下的文件；<br>（2）选用＞PRN参数时，则把所列目录及目录中的文件名打印输出。</p><p>导出当前目录的文件夹/文件的目录树到tree.txt文件中。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> /f &gt;<span class="built_in">tree</span>.txt</span><br></pre></td></tr></table></figure><blockquote><p>Tip:</p><ul><li>假如</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tree-——显示磁盘目录结构&quot;&gt;&lt;a href=&quot;#tree-——显示磁盘目录结构&quot; class=&quot;headerlink&quot; title=&quot;tree ——显示磁盘目录结构&quot;&gt;&lt;/a&gt;tree ——显示磁盘目录结构&lt;/h3&gt;&lt;p&gt;1．功能：显示指定驱动器上所有目录路
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构/链表 Linked List</title>
    <link href="http://yoursite.com/2020/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%20Linked%20List/"/>
    <id>http://yoursite.com/2020/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%20Linked%20List/</id>
    <published>2020-07-31T02:30:06.354Z</published>
    <updated>2020-07-31T02:30:06.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 Linked List</h2><ol><li><p>什么是链表</p><p>线性表：也称线性存储结构，线性表中的数据元素之间的关系是一对一的关系，除了第一个和最后要给数据元素，其他的数据元素都是首尾相连的。</p><p><strong>链表</strong>：线性表中使用链式存储的就是链表。</p></li><li><p>线性表存储结构</p><ul><li>顺序存储结构：将数据依次存储在连续的整块的物理空间中，称为顺序存储结构，简称<strong>顺序表</strong>。<ul><li>随机取读，访问一个元素的时间复杂度为O(1)</li></ul></li><li>链式存储结构：数据分散存储在物理空间中，每一个元素都有一个指针域，指针域存储着下个元素的指针，这种存储结构称为链式存储结构，也称<strong>链表</strong>。<ul><li>优点：定点插入和定点删除时间复杂度为O(1)，不浪费内存，添加元素才申请内存，删除元素释放内存。</li><li>缺点：访问的时间复杂度最坏为O(n)。</li></ul></li></ul></li><li><p>链表分类</p><p>根据指针域的不同分为：</p><ul><li>单向链表</li><li>双向链表</li><li>循环链表</li></ul></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表-Linked-List&quot;&gt;&lt;a href=&quot;#链表-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;链表 Linked List&quot;&gt;&lt;/a&gt;链表 Linked List&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是链表&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>unity/unity备忘</title>
    <link href="http://yoursite.com/2020/07/31/unity/unity%E5%A4%87%E5%BF%98/"/>
    <id>http://yoursite.com/2020/07/31/unity/unity%E5%A4%87%E5%BF%98/</id>
    <published>2020-07-31T02:30:06.330Z</published>
    <updated>2020-07-31T02:30:06.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设置变量在界面中显示"><a href="#设置变量在界面中显示" class="headerlink" title="设置变量在界面中显示"></a>设置变量在界面中显示</h4><ol><li><p>将变量设置为public</p></li><li><p>假如不想设置为public，可在前面加[SerializeField]</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> speed;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;设置变量在界面中显示&quot;&gt;&lt;a href=&quot;#设置变量在界面中显示&quot; class=&quot;headerlink&quot; title=&quot;设置变量在界面中显示&quot;&gt;&lt;/a&gt;设置变量在界面中显示&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将变量设置为public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>unity/UnityEditor异常处理</title>
    <link href="http://yoursite.com/2020/07/31/unity/UnityEditor%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/31/unity/UnityEditor%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2020-07-31T02:30:06.329Z</published>
    <updated>2020-09-14T03:01:32.622Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-UnityEditor-AsyncHTTPClient-Done-State-Int32-异常处理"><a href="#一-UnityEditor-AsyncHTTPClient-Done-State-Int32-异常处理" class="headerlink" title="一. UnityEditor.AsyncHTTPClient:Done(State, Int32)异常处理"></a>一. UnityEditor.AsyncHTTPClient:Done(State, Int32)异常处理</h4><p><img src="http://lgx.itengshe.com/20200615202416.png" alt=""></p><h4 id="二-使用Chinemachine-Confiner无Confine-Screen-Edges"><a href="#二-使用Chinemachine-Confiner无Confine-Screen-Edges" class="headerlink" title="二. 使用Chinemachine Confiner无Confine Screen Edges"></a>二. 使用Chinemachine Confiner无Confine Screen Edges</h4><p><img src="C:\Users\LGX\AppData\Roaming\Typora\typora-user-images\1594469478334.png" alt="1594469478334"></p><p>此时想要使用此插件限制跟随相机的范围不生效，依旧能看到背景之外的东西。</p><p><img src="http://lgx.itengshe.com/20200711201355.png" alt=""></p><p>后来才发现要使用这个插件，主摄像机需要使用orthographic，而不是</p><p>perspective</p><p><img src="http://lgx.itengshe.com/20200711201752.png" alt=""></p><p>之后即可看到Confine Screen Edges选项</p><p><img src="http://lgx.itengshe.com/20200711201856.png" alt=""></p><p>此时摄像机也被限制在规定范围内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-UnityEditor-AsyncHTTPClient-Done-State-Int32-异常处理&quot;&gt;&lt;a href=&quot;#一-UnityEditor-AsyncHTTPClient-Done-State-Int32-异常处理&quot; class=&quot;headerlin
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python/python笔记</title>
    <link href="http://yoursite.com/2020/07/31/python/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/31/python/python%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-31T02:30:06.326Z</published>
    <updated>2020-07-31T02:30:06.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表拼接的三种方式"><a href="#列表拼接的三种方式" class="headerlink" title="列表拼接的三种方式"></a>列表拼接的三种方式</h3><p><strong>方式一</strong>：使用”+”</p><p><img src="http://lgx.itengshe.com/img20200704164157.png" alt=""></p><p>使用此方法拼接，列表依旧不是原来的列表了，列表名此时已经指向内存空间中一个新的地址了</p><p><strong>方式二</strong>：切片赋值</p><p><img src="http://lgx.itengshe.com/img20200704164849.png" alt=""></p><p>这种方式拼接后依旧是原来的列表，要实在说有什么缺点，只能说可读性不高，比较难记</p><p><strong>方式三</strong>：列表自带extend方法</p><p><img src="http://lgx.itengshe.com/img20200704165147.png" alt=""></p><p>三种方法中，这种相对比较好一些，不需要开辟新的存储空间，而且比较好理解</p><h3 id="获取文件拓展名"><a href="#获取文件拓展名" class="headerlink" title="获取文件拓展名"></a>获取文件拓展名</h3><p>方法一：最后一个点的位置直到末尾就是文件拓展名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileName = <span class="string">"abc.txt"</span></span><br><span class="line">end = fileName[fileName.rfind(<span class="string">'.'</span>)+<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list = fileName.split(<span class="string">'.'</span>)</span><br><span class="line">end = list[len(list)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>方法三：此方法获取到的会带”.”，例如“.txt”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">end = os.path.splitext(fileName[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;列表拼接的三种方式&quot;&gt;&lt;a href=&quot;#列表拼接的三种方式&quot; class=&quot;headerlink&quot; title=&quot;列表拼接的三种方式&quot;&gt;&lt;/a&gt;列表拼接的三种方式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;方式一&lt;/strong&gt;：使用”+”&lt;/p&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python/python读写Excel表格</title>
    <link href="http://yoursite.com/2020/07/31/python/python%E8%AF%BB%E5%86%99Excel%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2020/07/31/python/python%E8%AF%BB%E5%86%99Excel%E8%A1%A8%E6%A0%BC/</id>
    <published>2020-07-31T02:30:06.326Z</published>
    <updated>2020-07-31T02:30:06.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python读写Excel表格"><a href="#python读写Excel表格" class="headerlink" title="python读写Excel表格"></a>python读写Excel表格</h3><p>python读写Excel表格其实就依赖两个库：</p><ul><li>python读excel——xlrd</li><li>python写excel——xlwt</li></ul><h4 id="一-python读excel"><a href="#一-python读excel" class="headerlink" title="一. python读excel"></a>一. python读excel</h4><p>1.先安装读表所需要的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xlrd</span><br></pre></td></tr></table></figure><p>2.导入库，打开表格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">improt xlrd</span><br><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">table = xlrd.open_workbook(<span class="string">"角色表.xlsx"</span>,<span class="string">'rb'</span>)</span><br></pre></td></tr></table></figure><p>3.找到指定工作簿</p><p>​    python获取工作簿方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：通过索引</span></span><br><span class="line">sheet = table.sheets()[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#方法二：通过索引获取表格</span></span><br><span class="line">sheet = table.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#方法三：通过名字获取表格</span></span><br><span class="line">sheet = table.sheet_by_name(<span class="string">'sheetname'</span>)</span><br></pre></td></tr></table></figure><p>4.获取工作簿行数、列数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行数</span></span><br><span class="line">row_num = sheet.nrows</span><br><span class="line"><span class="comment"># 列数</span></span><br><span class="line">col_num = sheet.ncols</span><br></pre></td></tr></table></figure><p>5.获取某行某列的值，i代表行数或者列数的索引(从0开始)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取某行的值</span></span><br><span class="line">row_values = sheet.row_values(i)</span><br><span class="line"><span class="comment"># 获取某列的值</span></span><br><span class="line">col_values = sheet.col_values(i)</span><br></pre></td></tr></table></figure><p>6.读取某个单元格数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = sheet.cell(i,j).value</span><br></pre></td></tr></table></figure><p>7.单元格内容类型</p><p>excel单元格内容返回类型有5种ctype：</p><ul><li>0 : empty</li><li>1 : string</li><li>2 : number</li><li>3 : date</li><li>4 ：boolean</li><li>5 ：error</li></ul><p>假如单元格类型为3(即date)，输出为一串数字，需要进一步处理才能显示为日期格式，转换步骤如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cell = sheet.cell(i,j)</span><br><span class="line"><span class="keyword">if</span> cell.ctype == <span class="number">3</span>:</span><br><span class="line">    date = xlrd.xldate_as_datetime(cell.value, <span class="number">0</span>)</span><br><span class="line">    cell = date.strftime(<span class="string">'%Y%m%d'</span>)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">if</span> cell.ctype == <span class="number">3</span>:</span><br><span class="line">    sCell = skin.cell_value(i,j)</span><br><span class="line">    date = datetime(*xldate_as_tuple(sCell, <span class="number">0</span>))</span><br><span class="line">    cell = date.strftime(<span class="string">'%Y%m%d'</span>)</span><br></pre></td></tr></table></figure><h4 id="二-python写excel"><a href="#二-python写excel" class="headerlink" title="二. python写excel"></a>二. python写excel</h4><p>1.安装xlwt</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xlwt</span><br></pre></td></tr></table></figure><p>2.导入xlwt，创建工作簿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import xlwt</span><br><span class="line">workbook &#x3D; xlwt.Workbook()</span><br><span class="line">worksheet &#x3D; workbook.add_sheet(&#39;test&#39;)</span><br></pre></td></tr></table></figure><p>3.写入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worksheet.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'hehe'</span>)</span><br></pre></td></tr></table></figure><p>4.存入到excel文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workbook.save(<span class="string">'test.xls'</span>)</span><br></pre></td></tr></table></figure><p>5.打开test.xls文件即可看到里面已经插入了test工作表，而且A1的内容为hehe。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python读写Excel表格&quot;&gt;&lt;a href=&quot;#python读写Excel表格&quot; class=&quot;headerlink&quot; title=&quot;python读写Excel表格&quot;&gt;&lt;/a&gt;python读写Excel表格&lt;/h3&gt;&lt;p&gt;python读写Excel表格其实就
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python/python打包成exe</title>
    <link href="http://yoursite.com/2020/07/31/python/python%E6%89%93%E5%8C%85%E6%88%90exe/"/>
    <id>http://yoursite.com/2020/07/31/python/python%E6%89%93%E5%8C%85%E6%88%90exe/</id>
    <published>2020-07-31T02:30:06.325Z</published>
    <updated>2020-07-31T02:30:06.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python打包成exe"><a href="#python打包成exe" class="headerlink" title="python打包成exe"></a>python打包成exe</h3><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>安装pyinstaller</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure></li><li><p>将目录切到python文件所在目录，或者在对应目录按shift+右键，打开命令行。</p></li><li><p>执行打包命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstall <span class="operator">-F</span> test.py</span><br></pre></td></tr></table></figure></li><li><p>之后即可在目录下看的新增dist文件夹，exe就存放在这里</p></li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>有时候python直接运行没有问题，打包后却无法正常运行，出现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find a suitable TLS CA certificate bundle, invalid path: C:\\Users\\...cacert.pem</span><br></pre></td></tr></table></figure><p>那是因为找不到cacert.pem文件了，项目中引入了其他的库很可能就会出现这样的问题</p><p>解决办法：手动将所需库/文件添加到程序的引用中</p><p>1.例如使用requests库打包就会出现这种问题，此时需要到python安装目录下，找到\Lib\site-packages\requests\cacert.pem复制到包含您的exe的dist目录</p><p>2.在代码中添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">os.environ[<span class="string">'REQUESTS_CA_BUNDLE'</span>] = os.path.join(os.path.dirname(sys.argv[<span class="number">0</span>]), <span class="string">'cacer'</span>)</span><br></pre></td></tr></table></figure><p>3.重新进行打包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python打包成exe&quot;&gt;&lt;a href=&quot;#python打包成exe&quot; class=&quot;headerlink&quot; title=&quot;python打包成exe&quot;&gt;&lt;/a&gt;python打包成exe&lt;/h3&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python/openpyxl修改excel(不修改原格式)</title>
    <link href="http://yoursite.com/2020/07/31/python/openpyxl%E4%BF%AE%E6%94%B9excel(%E4%B8%8D%E4%BF%AE%E6%94%B9%E5%8E%9F%E6%A0%BC%E5%BC%8F)/"/>
    <id>http://yoursite.com/2020/07/31/python/openpyxl%E4%BF%AE%E6%94%B9excel(%E4%B8%8D%E4%BF%AE%E6%94%B9%E5%8E%9F%E6%A0%BC%E5%BC%8F)/</id>
    <published>2020-07-31T02:30:06.324Z</published>
    <updated>2020-07-31T02:30:06.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python修改excel-不修改原格式"><a href="#python修改excel-不修改原格式" class="headerlink" title="python修改excel(不修改原格式)"></a>python修改excel(不修改原格式)</h3><p>使用xlwt虽然可以编辑excel中的数据，但假如原本的表格中一些单元格是带格式的，例如加粗，颜色不一样等，编辑后这些格式都会丢失。</p><p>因为编辑过程是先把整个表格先复制一遍，然后在复制的数据上进行修改，最终再把编辑好的数据保存到原本的表格中进行覆盖，xlwt复制是不会复制表格文本的格式的，所以修改后的数据覆盖原本的数据就把格式给弄丢了。</p><p>使用openpyxl模块来编辑表格就没这样的问题，用它来修改表格，原来的格式依旧存在，使用方法如下：</p><ol><li><p>下载openpyxl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure></li><li><p>打开已存在表格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line">wb = load_workbook(<span class="string">'表格.xlsx'</span>)</span><br></pre></td></tr></table></figure></li><li><p>获取工作表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet = wb.get_sheet_by_name(<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure></li><li><p>获取单元格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式一</span></span><br><span class="line">cell = sheet[<span class="string">'A1'</span>]</span><br><span class="line"><span class="comment">#方式二</span></span><br><span class="line">cell = sheet.cell(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>设置单元格数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.value = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure></li><li><p>保存到表格内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.save(<span class="string">'表格.xlsx'</span>)</span><br></pre></td></tr></table></figure></li></ol><p><strong><u>使用汇总</u></strong></p><ol><li><p>安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure></li><li><p>打开文件</p><p>2.1 创建、保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line">wb = Workbook()</span><br><span class="line">wb.save(<span class="string">'hehe.xlsx'</span>)</span><br></pre></td></tr></table></figure><p>2.2 打开已存在文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">form openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line">wb = load_workbook(<span class="string">'hehe.xlsx'</span>)</span><br></pre></td></tr></table></figure></li><li><p>工作簿操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wb = load_workbook(<span class="string">'hehe.xlsx'</span>)</span><br><span class="line"><span class="comment">#获取工作簿中的列表</span></span><br><span class="line">print(wb.sheetnames)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否只读</span></span><br><span class="line">print(wb.read_only)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文档编码</span></span><br><span class="line">print(wb.encoding)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建表</span></span><br><span class="line">sheet1 = wb.create_sheet(<span class="string">'sheet1'</span>)</span><br><span class="line">sheet2 = wb.create_sheet(<span class="string">'sheet2'</span>, <span class="number">0</span>) <span class="comment">#插到开始位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择表格</span></span><br><span class="line">sheet = wb.get_sheet_by_name(<span class="string">'sheetname'</span>))</span><br><span class="line">sheet = wb[<span class="string">'sheetname'</span>]</span><br><span class="line">sheet = wb.active<span class="comment">#获取当前活跃的woksheet</span></span><br></pre></td></tr></table></figure></li><li><p>工作表(sheet)操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sheet = wb[<span class="string">'sheetname'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取最大行数/列数</span></span><br><span class="line">rows_num = sheet.max_row</span><br><span class="line">col_num = sheet.column</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取所有的行/列</span></span><br><span class="line">rows = sheet.rows</span><br><span class="line">columns = sheet.columns</span><br></pre></td></tr></table></figure></li><li><p>单元格(cell)操作(单个单元格)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#访问单元格</span></span><br><span class="line">cell = sheet[<span class="string">'A1'</span>]</span><br><span class="line">cell = sheet.cell(row=<span class="number">4</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取单元格数据</span></span><br><span class="line">value = cell.value</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改单元格内容</span></span><br><span class="line">cell.value = <span class="string">'hehe'</span><span class="comment">#方式一</span></span><br><span class="line">sheet.cell(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>)<span class="comment">#方式二</span></span><br></pre></td></tr></table></figure></li><li><p>多单元格操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选择整行</span></span><br><span class="line">row = sheet[<span class="number">10</span>]</span><br><span class="line"><span class="comment">#选择多行</span></span><br><span class="line">rows = sheet[<span class="number">1</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择整列</span></span><br><span class="line">col = sheet[<span class="string">'C'</span>]</span><br><span class="line"><span class="comment">#选择多列</span></span><br><span class="line">cols = sheet[<span class="string">'C:D'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取多个单元格</span></span><br><span class="line">cell_range = sheet[<span class="string">'A1'</span>:<span class="string">'C2'</span>]</span><br></pre></td></tr></table></figure></li></ol><p>7. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python修改excel-不修改原格式&quot;&gt;&lt;a href=&quot;#python修改excel-不修改原格式&quot; class=&quot;headerlink&quot; title=&quot;python修改excel(不修改原格式)&quot;&gt;&lt;/a&gt;python修改excel(不修改原格式)&lt;/h3
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux/linux常用命令</title>
    <link href="http://yoursite.com/2020/07/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/07/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-07-31T02:30:06.320Z</published>
    <updated>2020-07-31T02:30:06.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>linux目录结构为树状结构，顶级目录为根目录/。</p><h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3><ul><li><p>绝对路径</p><p>由根路径 / 写起，如：/usr/local/share</p></li><li><p>相对路径</p><p>不是由 / 写起，例如从/usr/local/share到/usr/local/src中去，可以这样写：cd  ../src，这样的写法就是相对路径的写法。</p></li></ul><h3 id="常用目录命令"><a href="#常用目录命令" class="headerlink" title="常用目录命令"></a>常用目录命令</h3><ul><li>ls：列出目录</li><li>cd：切换目录</li><li>mkdir：创建新目录</li><li>rmdir：删除空目录</li><li>cp：复制文件或目录</li><li>rm：移除文件或目录</li><li>mv：移动文件与目录，或者重命名文件或目录</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录管理&quot;&gt;&lt;a href=&quot;#目录管理&quot; class=&quot;headerlink&quot; title=&quot;目录管理&quot;&gt;&lt;/a&gt;目录管理&lt;/h2&gt;&lt;p&gt;linux目录结构为树状结构，顶级目录为根目录/。&lt;/p&gt;
&lt;h3 id=&quot;绝对路径与相对路径&quot;&gt;&lt;a href=&quot;#绝对路
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>markdown数学公式</title>
    <link href="http://yoursite.com/2020/03/28/markdown%E4%BD%BF%E7%94%A8/markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/28/markdown%E4%BD%BF%E7%94%A8/markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</id>
    <published>2020-03-28T13:34:18.000Z</published>
    <updated>2020-07-31T02:30:06.323Z</updated>
    
    <content type="html"><![CDATA[<p>行内插入数学公式：<code>$公式$</code></p><p>插入公式块：<code>$$公式内容$$</code></p><h3 id="1-上下标"><a href="#1-上下标" class="headerlink" title="1.上下标"></a>1.上下标</h3><p>分别用^和_，例如<code>x_i^2</code>就是$ x_i^2 $</p><h3 id="2-常用运算符"><a href="#2-常用运算符" class="headerlink" title="2.常用运算符"></a>2.常用运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>说明</th><th>运算符案例</th><th>实现</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>x+y</td><td><code>$x+y$</code></td></tr><tr><td>-</td><td>减</td><td>x-y</td><td><code>$x-y$</code></td></tr><tr><td>\times</td><td>乘</td><td>$x \times y$</td><td><code>$x \times y$</code></td></tr><tr><td>\cdot</td><td>点积</td><td>$x \cdot y$</td><td><code>$x \cdot y$</code></td></tr><tr><td>\ast</td><td>乘</td><td>$x \ast y$</td><td><code>$x \ast y $</code></td></tr><tr><td>\div</td><td>除</td><td>$ x \div y$</td><td><code>$ x\div y $</code></td></tr><tr><td>\frac</td><td>分数</td><td>$\frac {x}{y} $</td><td><code>\frac {x}{y}</code></td></tr><tr><td>\ neq</td><td>不等于</td><td>$\neq$</td><td><code>$\neq$</code></td></tr><tr><td>\sqrt</td><td>根号</td><td>$\sqrt x$</td><td><code>$\sqrt x$</code></td></tr><tr><td>\sum</td><td>累加</td><td>$\sum_{k=1}^n$</td><td><code>$\sum_{k=1}^n$</code></td></tr></tbody></table></div><h3 id="3-大括号"><a href="#3-大括号" class="headerlink" title="3.大括号"></a>3.大括号</h3><p>左括号：\left (，右括号：\right)，则<code>\left( \frac x2 \right)</code>表示$\left( \frac x2 \right)$</p><h3 id="5-根号"><a href="#5-根号" class="headerlink" title="5. 根号"></a>5. 根号</h3><p><code>\sqrt{x}</code>用来表示$\sqrt{x}$</p><h3 id="6-戴帽符号"><a href="#6-戴帽符号" class="headerlink" title="6. 戴帽符号"></a>6. 戴帽符号</h3><div class="table-container"><table><thead><tr><th>符号</th><th>写法</th></tr></thead><tbody><tr><td>$\hat{x}$</td><td>\hat{x}</td></tr><tr><td>$\widehat{xyz}$</td><td>\widehat{xyz}</td></tr><tr><td>$\check{x}$</td><td>\check{x}</td></tr><tr><td>$\breve{y}$</td><td>\breve{y}</td></tr><tr><td>$\tilde{x}$</td><td>\tilde{x}</td></tr><tr><td>$\widetilde{xyz}$</td><td>\widetilde{xyz}</td></tr><tr><td>$\grave{x}$</td><td>\grave{x}</td></tr></tbody></table></div><h3 id="7-矩阵"><a href="#7-矩阵" class="headerlink" title="7. 矩阵"></a>7. 矩阵</h3><p>(1) 普通矩阵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line">   a &amp; b &amp; c &amp; d &amp; e\\</span><br><span class="line">   f &amp; g &amp; h &amp; i &amp; j \\</span><br><span class="line">   k &amp; l &amp; m &amp; n &amp; o \\</span><br><span class="line">   p &amp; q &amp; r &amp; s &amp; t</span><br><span class="line">  \end&#123;matrix&#125; </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果：</p><script type="math/tex; mode=display">\begin{matrix}   a & b & c & d & e\\   f & g & h & i & j \\   k & l & m & n & o \\   p & q & r & s & t  \end{matrix}</script><p>(2) 带中括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\left[</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line">   a &amp; b &amp; c &amp; d &amp; e\\</span><br><span class="line">   f &amp; g &amp; h &amp; i &amp; j \\</span><br><span class="line">   k &amp; l &amp; m &amp; n &amp; o \\</span><br><span class="line">   p &amp; q &amp; r &amp; s &amp; t</span><br><span class="line">  \end&#123;matrix&#125; </span><br><span class="line">\right]</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\left[ \begin{matrix}   a & b & c & d & e\\   f & g & h & i & j \\   k & l & m & n & o \\   p & q & r & s & t  \end{matrix} \right]</script><h3 id="8-希腊字母"><a href="#8-希腊字母" class="headerlink" title="8.希腊字母"></a>8.希腊字母</h3><div class="table-container"><table><thead><tr><th>字母</th><th>写法</th></tr></thead><tbody><tr><td>$\alpha$</td><td>\alpha</td></tr><tr><td>$\beta$</td><td>\beta</td></tr><tr><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\theta$</td><td>\theta</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><h3 id="9-三角运算符"><a href="#9-三角运算符" class="headerlink" title="9.三角运算符"></a>9.三角运算符</h3><div class="table-container"><table><thead><tr><th>符号</th><th>写法</th></tr></thead><tbody><tr><td>$\sin$</td><td>\sin</td></tr><tr><td>$\cos$</td><td>\cos</td></tr><tr><td>$\tan$</td><td>\tan</td></tr><tr><td>$\cot$</td><td>\cot</td></tr><tr><td>$\sec$</td><td>\sec</td></tr><tr><td>$\csc$</td><td>\csc</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;行内插入数学公式：&lt;code&gt;$公式$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;插入公式块：&lt;code&gt;$$公式内容$$&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-上下标&quot;&gt;&lt;a href=&quot;#1-上下标&quot; class=&quot;headerlink&quot; title=&quot;1.上下标&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://yoursite.com/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>获取url中的参数</title>
    <link href="http://yoursite.com/2020/03/28/javascripts/%E8%8E%B7%E5%8F%96url%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/28/javascripts/%E8%8E%B7%E5%8F%96url%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/</id>
    <published>2020-03-28T13:34:18.000Z</published>
    <updated>2020-07-31T02:30:06.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="获取url中的参数"><a href="#获取url中的参数" class="headerlink" title="获取url中的参数"></a>获取url中的参数</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function getUrlParams (search) &#123;</span><br><span class="line">  search &#x3D; search || location.search;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 判断是否为字符串类型</span><br><span class="line">  if (typeof search !&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    search &#x3D; search.toString();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  var paramsSplit &#x3D; search.replace(&#x2F;^[^\?]*\?&#x2F;i, &#39;&#39;).split(&#x2F;&amp;&#x2F;);</span><br><span class="line">  var params &#x3D; &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 数据为空</span><br><span class="line">  if (paramsSplit.length &lt; 1) &#123;</span><br><span class="line">    return params;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  if (Array.isArray(paramsSplit)) &#123;</span><br><span class="line">    paramsSplit.forEach(function (item) &#123;</span><br><span class="line">      &#x2F;&#x2F; 数据为空, 退出方法</span><br><span class="line">      if (!item) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      var itemSplit &#x3D; item.split(&#x2F;&#x3D;&#x2F;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 判断字符串中是否有多个&#x3D;</span><br><span class="line">      if (itemSplit.length &gt;&#x3D; 2) &#123; &#x2F;&#x2F; 是</span><br><span class="line">        var key &#x3D; itemSplit.splice(0, 1);</span><br><span class="line">        params[key] &#x3D; itemSplit.join(&#39;&#x3D;&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取url中参数</span><br><span class="line">    function GetRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        var url &#x3D; location.search;   &#x2F;&#x2F;获取url中&quot;?&quot;符后的字串   </span><br><span class="line">        var theRequest &#x3D; new Object();</span><br><span class="line">        if (url.indexOf(&quot;?&quot;) !&#x3D; -1) </span><br><span class="line">        &#123;</span><br><span class="line">            var str &#x3D; url.substr(1);</span><br><span class="line">            strs &#x3D; str.split(&quot;&amp;&quot;);</span><br><span class="line">            for (var i &#x3D; 0; i &lt; strs.length; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                theRequest[strs[i].split(&quot;&#x3D;&quot;)[0]] &#x3D; unescape(strs[i].split(&quot;&#x3D;&quot;)[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return theRequest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="根据key-获取url中的参数"><a href="#根据key-获取url中的参数" class="headerlink" title="根据key,获取url中的参数"></a>根据key,获取url中的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function GetRequest2(key)</span><br><span class="line">    &#123;</span><br><span class="line">        var url &#x3D; location.search;  </span><br><span class="line">        var theRequest &#x3D; new Object();</span><br><span class="line">        if (url.indexOf(&quot;?&quot;) !&#x3D; -1) </span><br><span class="line">        &#123;</span><br><span class="line">            var str &#x3D; url.substr(1);</span><br><span class="line">            strs &#x3D; str.split(&quot;&amp;&quot;);</span><br><span class="line">            for (var i &#x3D; 0; i &lt; strs.length; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                theRequest[strs[i].split(&quot;&#x3D;&quot;)[0]] &#x3D; unescape(strs[i].split(&quot;&#x3D;&quot;)[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var value &#x3D; theRequest[key];</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;获取url中的参数&quot;&gt;&lt;a href=&quot;#获取url中的参数&quot; class=&quot;headerlink&quot; title=&quot;获取url中的参数&quot;&gt;&lt;/a&gt;获取url中的参数&lt;/h3&gt;&lt;h4 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="javaScripts" scheme="http://yoursite.com/categories/javaScripts/"/>
    
    
      <category term="javaScripts" scheme="http://yoursite.com/tags/javaScripts/"/>
    
  </entry>
  
</feed>
