<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>Android笔记 | 呵呵到天亮</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android笔记</h1><a id="logo" href="/.">呵呵到天亮</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Android笔记</h1><div class="post-meta"><a href="/2019/12/28/android%E7%AC%94%E8%AE%B0/#comments" class="comment-count"></a><p><span class="date">Dec 28, 2019</span><span><a href="/categories/Android/" class="category">Android</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>记录一下Android学习过程</p>
<a id="more"></a>
<h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>一般可用于启动 活动、启动服务、发送广播等场景</p>
<h2 id="四大组件-——-Activity"><a href="#四大组件-——-Activity" class="headerlink" title="四大组件 —— Activity"></a>四大组件 —— Activity</h2><h3 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h3><p>活动有4种启动模式，分别是standard ,singleTop, singleTask, singleInstance</p>
<p>可以在AndroidMainfest.xml中通过<activity>标签指定android:launchMode属性来选择启动模式。</p>
<h3 id="1-standard"><a href="#1-standard" class="headerlink" title="1.standard"></a>1.standard</h3><p>默认的启动模式，此模式下系统不在乎返回栈中是否存在，每次启动都创新的活动实例</p>
<p><img src="http://lgx.itengshe.com/20191226131944-1.png" alt=""></p>
<h3 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="2.singleTop"></a>2.singleTop</h3><p>此模式下，在启动活动时发现返回栈的<strong>栈顶已经是该活动</strong>，则直接使用，不再创建新的活动实例。但如果该活动不位于栈顶位置，则再次启动该活动时，<strong>还是会创建新的实例</strong></p>
<p><img src="http://lgx.itengshe.com/20191226132113-1.png" alt=""></p>
<h3 id="3-singleTask"><a href="#3-singleTask" class="headerlink" title="3.singleTask"></a>3.singleTask</h3><p>使用此模式，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没发现该活动实例，就会创建一个新的活动实例。</p>
<p><img src="http://lgx.itengshe.com/20191226132132-1.png" alt=""></p>
<h3 id="4-singleInstance"><a href="#4-singleInstance" class="headerlink" title="4.singleInstance"></a>4.singleInstance</h3><p>此模式不同于以上3种模式，指定为singleInstance模式的活动会启用一个<strong>新的返回栈</strong>来管理这个活动（其实如果 singleTask 模式指定了不同的 taskAffinity，也会启 动一个新的返回栈）。</p>
<p><em>应用场景</em>：假设我们的程序中有一个 活动是允许其他程序调用的 ，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，就需要用此模式，</p>
<p>在这种模式下会有一个单独的返回栈来管理这个活 动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实 例的问题    </p>
<p><img src="http://lgx.itengshe.com/20191226132159-1.png" alt=""></p>
<h2 id="四种布局"><a href="#四种布局" class="headerlink" title="四种布局"></a>四种布局</h2><h3 id="1-LinearLayout"><a href="#1-LinearLayout" class="headerlink" title="1.LinearLayout"></a>1.LinearLayout</h3><p>a.线性布局，将它包含的控件在线性方向上一次排列</p>
<p>b.<strong>排列方向：</strong>可水平方向（vertical)，垂直方向排列(horizontal)，修改方法：</p>
<p><img src="http://lgx.itengshe.com/20191226132300-1.png" alt=""></p>
<p>如果LinearLayout的排列方向是<strong>horizontal</strong>，内部控件宽度不能使用math_parent，会占满整个水平方向，同理<strong>vertical</strong>时内部控件高度不可使用match_parent。</p>
<h3 id="2-RelativeLayout"><a href="#2-RelativeLayout" class="headerlink" title="2.RelativeLayout"></a>2.RelativeLayout</h3><p>相对布局，与LinearLayout相比，更加随意一些，它能通过相对定位的方式让控件出现在布局的任何位置，可相对于整个容器，也可相对于某个控件</p>
<h3 id="3-FrameLayout"><a href="#3-FrameLayout" class="headerlink" title="3.FrameLayout"></a>3.FrameLayout</h3><p>这种布局没有任何定位方式，所有控件都会摆放在布局的左上角（应用场景不多）</p>
<h3 id="4-TableLayout"><a href="#4-TableLayout" class="headerlink" title="4.TableLayout"></a>4.TableLayout</h3><p>使用表格方式来排列控件（不常用）</p>
<h2 id="单位和尺寸"><a href="#单位和尺寸" class="headerlink" title="单位和尺寸"></a>单位和尺寸</h2><p><strong>px</strong>    像素，屏幕中可以显示的最小元素单位</p>
<p><strong>pt</strong>    磅数的意思，1磅等于1/72英尺，一般用作字体的单位</p>
<p><strong>dp</strong>    密度无关像素，也称dip，和px相比，它再不同密度的屏幕中的显示比例保持一致</p>
<p><strong>sp</strong>    可伸缩像素，采用与dp同样的设计理念，解决字体大小适配问题</p>
<p><strong>密度</strong>    Android中密度就是屏幕每英寸所包含的像素数，以dip为单位。</p>
<p>比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果 它的分辨率是 320x480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640*960， 那这个屏幕的密度就是 320dpi，因此密度值越高的屏幕显示的效果就越精细。</p>
<p>Android 规定，在160dpi的屏幕上，1dp等于1px，而在320dpi的屏幕上，1dp等于2px.</p>
<p>因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的 显示比例保持一致。    </p>
<p>​    </p>
<h2 id="四大组件-——-Broadcast-Receive"><a href="#四大组件-——-Broadcast-Receive" class="headerlink" title="四大组件 ——- Broadcast Receive"></a>四大组件 ——- Broadcast Receive</h2><p>Android中的广播分为两种类型，即 <strong>标准广播</strong> 和 <strong>有序广播</strong></p>
<h3 id="1-标准广播"><a href="#1-标准广播" class="headerlink" title="1.标准广播"></a>1.标准广播</h3><p>标准广播是一直完全异步执行的广播，广播发出后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此他们之间没有任何的先后顺序可言。这种广播效率比较高，也意味着它无法被截断</p>
<p><img src="http://lgx.itengshe.com/20191226132321-1.png" alt=""></p>
<h3 id="2-有序广播"><a href="#2-有序广播" class="headerlink" title="2.有序广播"></a>2.有序广播</h3><p>有序广播是一种同步执行的广播，在广播发出后，同一时刻只会有一个广播接收器能接收到这条消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。</p>
<p>此时广播接收器是有先后顺序的，优先级高的广播接收器可以优先收到广播消息，也可截断正则传递的广播，使后面的广播接收器无法接收广播消息</p>
<p><img src="http://lgx.itengshe.com/20191226132340-1.png" alt=""></p>
<h3 id="3-注册广播"><a href="#3-注册广播" class="headerlink" title="3.注册广播"></a>3.注册广播</h3><p>分两种方式：在代码中注册（动态注册）、在AndroidMainifest.xml中注册（静态注册）</p>
<h2 id="持久化计算"><a href="#持久化计算" class="headerlink" title="持久化计算"></a>持久化计算</h2><p>Android系统主要提供三种数据持久化功能——-<strong>文件存储</strong>、<strong>SharedPreference存储</strong>以及<strong>数据库存储</strong></p>
<h3 id="1-文件存储"><a href="#1-文件存储" class="headerlink" title="1.文件存储"></a>1.文件存储</h3><p>不对存储的内容进行任何的格式化出来，所有数据原封不动存在文件中（适合存储一些简单的文本数据或者二进制数据），文件默认存储到/data/data/<packagename>/file/目录下</p>
<h3 id="2-SharedPreferences存储"><a href="#2-SharedPreferences存储" class="headerlink" title="2.SharedPreferences存储"></a>2.SharedPreferences存储</h3><p>使用<strong>键值对</strong>的方式来存储数据，较文件存储方便得多，而且支持多种不同数据类型的存储，即如果存入的数据类型是整型，读取出来的数据也是整形的</p>
<p>存储前，先获得SharedPreferences对象，Android中主要提供三种方法得到SharedPreferences对象</p>
<h4 id="2-1-getSharedPreferences"><a href="#2-1-getSharedPreferences" class="headerlink" title="2.1. getSharedPreferences"></a>2.1. getSharedPreferences</h4><p>​    Context类中的getSharedPreferences(fileName，操作模式)方法</p>
<p>​    <strong>第一个参数</strong>用于指定文件名称，指定文件不存在则会创建一个，SharedPreferences文件存放在/data/data/<packagename>/shared_prefs/目录下</p>
<p>​    <strong>第二个参数</strong>用于指定操作模式，主要有两种模式可以选 择，MODE_PRIVATE 和 MODE_MULTI_PROCESS。MODE_PRIVATE 仍然是默认的操 作模式，和直接传入 0 效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences文件进行读写。MODE_MULTI_PROCESS 则一般是用于会有多个进程中 对同一个 SharedPreferences 文件进行读写的情况。类似地，MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE 这两种模式已在 Android 4.2 版本中被废弃    </p>
<h4 id="2-2-getSharedPreferences"><a href="#2-2-getSharedPreferences" class="headerlink" title="2.2.getSharedPreferences"></a><strong>2.2.</strong>getSharedPreferences</h4><p>​    Activity类中的getSharedPreferences()方法</p>
<p>​    只接受一个操作模式参数，因为使用此方法时会自动将当前的类名作为SharedPreferences的文件名</p>
<h4 id="2-3-getDefaultSharedPreferences"><a href="#2-3-getDefaultSharedPreferences" class="headerlink" title="2.3.getDefaultSharedPreferences"></a><strong>2.3.</strong>getDefaultSharedPreferences</h4><p>​    PreferencesManager类中的getDefaultSharedPreferences()方法</p>
<p>​    这是一个静态方法，接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences对象</p>
<h5 id="a-向SharedPreferences文件中存储数据"><a href="#a-向SharedPreferences文件中存储数据" class="headerlink" title="a.向SharedPreferences文件中存储数据"></a>a.<strong>向SharedPreferences文件中存储数据</strong></h5><p>分三步实现</p>
<p>1.调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象</p>
<p>2.向SharedPreferences对象中添加数据，比如添加布尔类型的数据就是用putBoolean方法</p>
<p>3.调用commit()方法，将添加的数据提交，从而完成数据存储操作</p>
<h5 id="b-从SharedPreferences文件中读取数据"><a href="#b-从SharedPreferences文件中读取数据" class="headerlink" title="b.从SharedPreferences文件中读取数据"></a>b.从SharedPreferences文件中读取数据</h5><p>使用SharedPreferences的get方法来对存储数据进行读取，每种get方法对应SharedPreferences.Editor中的一种put方法，例如读取布尔值，就使用getBoolean()方法</p>
<p>get方法接受两个参数，第一个是“键”，第二个是 默认值（即传入键找不到对应的值是，返回什么样的默认值）</p>
<h3 id="3-SQLite数据库存储"><a href="#3-SQLite数据库存储" class="headerlink" title="3.SQLite数据库存储"></a>3.SQLite数据库存储</h3><p>SQLite是一筐轻量级的关系型数据库，运算速度快，占用资源少，通常只需要几百k的内存就够了</p>
<p>Android提供了<strong>SQLiteOpenHelper</strong>帮助类，这是一个抽象类，有两个抽象方法—-onCreate() 和onUpgrade()，</p>
<p>使用时我们需要创建一个帮助类继承SQLiteOpenHelper，并在自己的帮助类中重写两个抽象方法，然后在这两个方法中区实现创建、升级数据库的逻辑</p>
<p><strong>SQLiteOpenHelper</strong>中有两个构造方法可以重写，一般使用参数较少的的方法，此方法接收四个参数；</p>
<p>1.Context     2.数据库名    3.允许我们在查询数据的时候返回一个自定义的Cursor，一般传入null</p>
<p>4.当前数据库的版本号</p>
<h5 id="3-1创建数据库："><a href="#3-1创建数据库：" class="headerlink" title="3.1创建数据库："></a><em>3.1创建数据库：</em></h5><p>构建出SQLiteOpenHelper实例后，再调用getReadableDatabase()或getWritableDatabase()就能创建出数据库了，数据库文件存放在/data/data/<packagename>/database/目录下</p>
<h5 id="3-2升级数据库"><a href="#3-2升级数据库" class="headerlink" title="3.2升级数据库"></a>3.2升级数据库</h5><p>只需要在构建SQLiteOpenHelper时传入的高于之前的版本号，就会调用onUpgrade()</p>
<h5 id="3-3SQLite数据类型"><a href="#3-3SQLite数据类型" class="headerlink" title="3.3SQLite数据类型"></a><strong>3.3SQLite数据类型</strong></h5><p>integer     整型</p>
<p>real        浮点型</p>
<p>text        文本型</p>
<p>blob    二进制型</p>
<hr>
<h2 id="四大组件-——-Content-Provider"><a href="#四大组件-——-Content-Provider" class="headerlink" title="四大组件 —— Content Provider"></a>四大组件 —— Content Provider</h2><p>主要用于在不同应用程序之间实现数据共享的功能，它的完整机制允许程序访问另一个程序中的数据，同时又保证被访问数据的安全性。</p>
<p>使用内容提供器是Android实现程序共享数据的标准方式</p>
<h3 id="1-访问其他程序中的数据"><a href="#1-访问其他程序中的数据" class="headerlink" title="1.访问其他程序中的数据"></a>1.访问其他程序中的数据</h3><p>​    每个应用程序想要访问内容提供器中的共享数据，要借助ContentResolve类，可以通过Context中的<strong>getContentResolver()</strong>方法获得该类的实例</p>
<p>ContentResolver提供了对数据进行CRUD的操作方法，即</p>
<ol>
<li>insert()添加数据 </li>
<li>update()更新数据</li>
<li>delete()删除数据</li>
<li>query()查询数据</li>
</ol>
<p>这几个方法都只需要传入Uri参数，即内容URI，内容URI给内容提供器中的数据建立了唯一的标识，由两部分组成，即权限（authority）和路径（path）</p>
<p>​    a.权限用于对不同的应用程序做区分的，为了避免冲突，都会采用程序包名的方式来进行命名，如com.example.app，则该程序对应的权限命名为com.example.app.provider</p>
<p>​    b.路径用于对同一应用程序中不同的表做区分，通常加到权限后面，比如某个程序的数据库中有两张表，table1和table2，此时路径分别命名为/table1和/table2，与权限结合起来，内容URI就变成              com.example.app.provider/table1 和</p>
<p>com.example.app.provider/table2</p>
<p>​    在字符串头部加上协议声明，得到最标准的URI的格式写法如下：</p>
<p>content://com.example.app.provider/table1 </p>
<p>content://com.example.app.provider/table2</p>
<p>​    得到URI字符串后，将其解析成Uri对象才可作为参数传入增删改查方法中</p>
<p>​    Uri uri = Uri.pase(“content://com.example.app.provider/table1”)</p>
<h2 id="异步消息处理机制"><a href="#异步消息处理机制" class="headerlink" title="异步消息处理机制"></a>异步消息处理机制</h2><p>Android中的异步消息处理主要由四个部分组成，Message、Handler、MessageQueue、和Looper。</p>
<h3 id="1-Messgae"><a href="#1-Messgae" class="headerlink" title="1.Messgae"></a>1.Messgae</h3><p>Message是线程之间传递的消息，可在内部携带少量的信息，用于不同线程之间交换数据。</p>
<p>例如what字段，除此之外arg1和arg2字段可携带一些整型数据，obj字段携带一个Object对象</p>
<h3 id="2-Handler"><a href="#2-Handler" class="headerlink" title="2.Handler"></a>2.Handler</h3><p>顾名思义就是处理者的意思，主要用你发送和处理消息。</p>
<p>发送消息一般是使用Handler的sendMessage()方法，发出的消息经过一系列辗转后，最终传递到Handler的handlerMessage()方法中。</p>
<h3 id="3-MessageQueue"><a href="#3-MessageQueue" class="headerlink" title="3.MessageQueue"></a>3.MessageQueue</h3><p>消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象</p>
<h3 id="4-Looper"><a href="#4-Looper" class="headerlink" title="4.Looper"></a>4.Looper</h3><p>Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop()方法后，就会 进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取 出，并传递到 Handler 的 handleMessage()方法中。每个线程中也只会有一个 Looper 对象。  </p>
<hr>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask 基于异步消息处理机制，Android帮我们做了很好的封装</p>
<p>AsyncTask是一个抽象类，使用它得用一个子类去继承它，继承时可以为AsyncTask类指定一个泛型参数。</p>
<h3 id="1-Params"><a href="#1-Params" class="headerlink" title="1.Params"></a>1.Params</h3><p>​    在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。    </p>
<h3 id="2-Progress"><a href="#2-Progress" class="headerlink" title="2.Progress"></a>2.Progress</h3><p>​    后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为 进度单位。    </p>
<h3 id="3-Result"><a href="#3-Result" class="headerlink" title="3.Result"></a>3.Result</h3><p>​    当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值 类型。    </p>
<p>因此，一个最简单的自定义 AsyncTask 就可以写成如下方式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要重写AsyncTask中的几个方法才能完成对任务的定制。</p>
<h4 id="3-1-onPreExecute"><a href="#3-1-onPreExecute" class="headerlink" title="3.1.onPreExecute()"></a>3.1.onPreExecute()</h4><p>​    在后台任务开始之前调用，用于进行一些界面上的初始化，比如显示一个进度条对话框等</p>
<h4 id="3-2-doInBackground-Params"><a href="#3-2-doInBackground-Params" class="headerlink" title="3.2.doInBackground(Params)"></a>3.2.doInBackground(Params)</h4><p>​    这个方法中的所有代码都会在子线程中运行，我们在这里处理所有耗时任务。任务完成后通过return语句来返回任务执行结果。如果AsyncTask的第三个泛型参数为void，就不返回执行结果。</p>
<p>​    <strong>注意</strong>：此方法中不可进行UI操作，如需更新UI元素，比如反馈当前任务进度，可以调用publishProgress(Progress …)方法来完成</p>
<h4 id="3-3-onProgressUpdate-Progress…"><a href="#3-3-onProgressUpdate-Progress…" class="headerlink" title="3.3.onProgressUpdate(Progress…)"></a>3.3.onProgressUpdate(Progress…)</h4><p>​    在后台任务中调用publishProgress(Progress…)方法后，会很快调用此方法，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值对界面元素进行相应的更新。</p>
<h4 id="3-4-onPostExecute-Result"><a href="#3-4-onPostExecute-Result" class="headerlink" title="3.4.onPostExecute(Result)"></a>3.4.onPostExecute(Result)</h4><p>​    当后台任务执行完毕并通过return语句进行返回时，这个方法就会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如提醒任务执行结果，以及关闭进度条对话框。</p>
<p>因此，一个比较完整的自定义 AsyncTask 就可以写成如下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line">    protected void onPreExecute() &#123;</span><br><span class="line">    	progressDialog.show(); &#x2F;&#x2F; 显示进度对话框</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Boolean doInBackground(Void... params) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                int downloadPercent &#x3D; doDownload(); &#x2F;&#x2F; 这是一个虚构的方法</span><br><span class="line">                publishProgress(downloadPercent);</span><br><span class="line">                if (downloadPercent &gt;&#x3D; 100) &#123;</span><br><span class="line">                	break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        	return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onProgressUpdate(Integer... values) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在这里更新下载进度</span><br><span class="line">        progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onPostExecute(Boolean result) &#123;</span><br><span class="line">        progressDialog.dismiss(); &#x2F;&#x2F; 关闭进度对话框</span><br><span class="line">        &#x2F;&#x2F; 在这里提示下载结果</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                Toast.makeText(context, &quot;Download succeeded&quot;,</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast.makeText(context, &quot; Download failed&quot;,</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四大组件-——-Service"><a href="#四大组件-——-Service" class="headerlink" title="四大组件 —— Service"></a>四大组件 —— Service</h2><h3 id="1-定义一个服务"><a href="#1-定义一个服务" class="headerlink" title="1. 定义一个服务"></a>1. 定义一个服务</h3><p>基本的Service这样定义，onBind 是service中唯一一个抽象方法，所以必须在子类中进行实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public IBinder onBind(Intent intent)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让服务去处理一些事情，逻辑应该写在哪里呢？</p>
<p>我们又重写onCreate()，onStartCommand()和onDestroy(）方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个新加的方法是每个服务中最常用的方法</p>
<ol>
<li>oncreate() 在服务创建的时候调用</li>
<li>onStartCommand() 会在每次服务启动的时候调用</li>
<li>onDestroy() 会在服务销毁的时候调用</li>
</ol>
<p>所以一旦服务启动就需要执行的动作，逻辑写在onStartCommand()方法中，在onDestroy中回收那些不需要的资源。</p>
<p><strong>注意：</strong>每个服务都需要在AndroidManifest.xml中注册才能生效，这似乎是四大组件的共同特点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    package&#x3D;&quot;com.example.servicetest&quot;</span><br><span class="line">    android:versionCode&#x3D;&quot;1&quot;</span><br><span class="line">    android:versionName&#x3D;&quot;1.0&quot; &gt;</span><br><span class="line">    ……</span><br><span class="line">    &lt;application</span><br><span class="line">        android:allowBackup&#x3D;&quot;true&quot;</span><br><span class="line">        android:icon&#x3D;&quot;@drawable&#x2F;ic_launcher&quot;</span><br><span class="line">        android:label&#x3D;&quot;@string&#x2F;app_name&quot;</span><br><span class="line">        android:theme&#x3D;&quot;@style&#x2F;AppTheme&quot; &gt;</span><br><span class="line">        ……</span><br><span class="line">        &lt;service android:name&#x3D;&quot;.MyService&quot; &gt;</span><br><span class="line">        &lt;&#x2F;service&gt;</span><br><span class="line">    &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-启动和停止服务"><a href="#2-启动和停止服务" class="headerlink" title="2. 启动和停止服务"></a>2. 启动和停止服务</h3><p>启动和停止服务主要借助Intent来实现</p>
<p>启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent starIntent &#x3D; new Intent(this, MyService.class);</span><br><span class="line">startService(starIntent);</span><br></pre></td></tr></table></figure>
<p>停止服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent stopIntent &#x3D; new Intent(this, MyService.class);</span><br><span class="line">stopService(stopIntent);</span><br></pre></td></tr></table></figure>
<p>服务除了由活动来决定何时停止外，它也能自己让自己停下来，只需要服务自己调用stopSelf()方法即可</p>
<h3 id="3-活动与服务进行通信"><a href="#3-活动与服务进行通信" class="headerlink" title="3.活动与服务进行通信"></a>3.活动与服务进行通信</h3><p>​        上面使用的方法在活动中启动和停止服务，但是服务启动后活动和服务基本没有关系了，无法得知服务的状态，如何才能让活动和服务联系更加紧密呢，让活动能随时指挥服务去执行某些任务？这就需要用到刚才那个我们必须要重写的<strong>onBind()</strong>方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line">    private DownloadBinder mBinder &#x3D; new DownloadBinder();</span><br><span class="line">    class DownloadBinder extends Binder &#123;</span><br><span class="line">        public void startDownload() &#123;</span><br><span class="line">        	Log.d(&quot;MyService&quot;, &quot;startDownload executed&quot;);</span><br><span class="line">    	&#125;</span><br><span class="line">        public int getProgress() &#123;</span><br><span class="line">            Log.d(&quot;MyService&quot;, &quot;getProgress executed&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">    	return mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        这里我们在刚才建的MyService类中新建一个DownloadBinder类，并继承自Binder，这个类里提供方法供外部使用，我们这里提供了<strong>开始下载</strong>方法和<strong>获取下载进度</strong>的方法。然后在MyService中创建了DownloadBinder实例，并在onBind()方法中返回该实例。</p>
<p>​        如何在活动中调用服务里的方法呢？实际上当一个活动与服务绑定了之后，就可以调用Binder提供的方法了。</p>
<p>​        在活动中，我们首先创建ServiceConnection 匿名类，在里面重写onServiceConnected()方法和 onServiceDisconnected()方法，这两个方法分别在活动与服务成功绑定和解除绑定时调用。在onServiceConnecter()方法中，我们又向下转型得到的DownloadBinder实例，有了实例，我们就可以在活动中调用DownloadBinder中的任何public方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private MyService.DownloadBinder downloadBinder;</span><br><span class="line">private ServiceConnection connection &#x3D; new ServiceConnection()&#123;</span><br><span class="line">	@Override</span><br><span class="line">    public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">        downloadBinder &#x3D; (MyService.DownloadBinder) service;</span><br><span class="line">        downloadBinder.startDownload();</span><br><span class="line">        downloadBinder.getProgress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        别高兴太早，我们还没实现绑定呢。绑定方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent bindIntent &#x3D; new Intent(this, Myservice.class);</span><br><span class="line">bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<p>​        bindService()接收三个参数，第一个就是刚构建出来的Intent对象，第二个参数是前面创角出来的ServiceConnection实例，第三个参数是标志位，BIND_AUTO_CREATE表示在活动和服务进行绑定后自动创建服务，此时MyService中的onCreate()方法会执行，但onStartCommand()方法不会执行。</p>
<p>​        解绑方法比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unbindService(connetion);</span><br></pre></td></tr></table></figure>
<p>​        <em>注意：</em>任何一个服务在整个应用程序范围内都是通用的，即任何一个活动都可与之绑定，而且绑定后他们都可以获取到相同的DownloadBinder实例。</p>
<h3 id="4-服务的生命周期"><a href="#4-服务的生命周期" class="headerlink" title="4.服务的生命周期"></a>4.服务的生命周期</h3><p>onCreate() ,onStartCommand(),onBind(),onDestroy()等方法都是在服务生命周期里可能回调的方法。</p>
<p>1.项目中任意位置调用Context的startService()方法，相应的服务就会启动，并回调onStartCommand()方法，假如服务没创建过，onCreat()方法会先于onStartCommand()方法执行。</p>
<p>2.服务启动后一直保持运行，直到stopService()或stopSelf()被调用</p>
<p>每次调用startService()方法，onStartCommand()方法就会调用一次，但每个服务只会有一个实例，无论调用多少次startService()，只需要调用一次stopService()或stopSelf()即可停止该服务</p>
<p>3.调用Context的bindService()方法，获取一个服务的持久连接，这是就会回调服务的onBind()方法，如果服务没创建过，onCreate()会先于onBind()方法执行。调用方可以获取onBind()方法里返回的IBinder对象的实例，这样即可与服务自由的通信了。调用方与服务之间的连接没有断开，服务就会一直保持运行状态。</p>
<p>4.调用startService()方法后，又调用stopService()方法，onDestroy()方法就会执行，此时服务已经销毁。类似的，调用bindService()方法后又调用unbindService()方法，onDestroy()方法也会执行。</p>
<p>5.Android系统机制规定，一个服务被启动或者被绑定后，就会一直处于运行状态，必须同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。</p>
<h3 id="5-前台服务"><a href="#5-前台服务" class="headerlink" title="5.前台服务"></a>5.前台服务</h3><p>服务的系统优先级比较低，内存不足时，可能被回收，而前台服务就不会因为内存不足而被回收。</p>
<p><strong>与普通服务最大区别：</strong>会有一个正在运行的图标在系统状态栏显示。下拉状态栏可以看到详细信息，类似通知的效果。</p>
<p>创建方法类似创建通知方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line">    ……</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Notification notification &#x3D; new Notification(R.drawable.ic_launcher,</span><br><span class="line">        &quot;Notification comes&quot;, System. currentTimeMillis());</span><br><span class="line">        Intent notificationIntent &#x3D; new Intent(this, MainActivity.class);</span><br><span class="line">        PendingIntent pendingIntent &#x3D; PendingIntent.getActivity(this, 0,</span><br><span class="line">        notificationIntent, 0);</span><br><span class="line">        notification.setLatestEventInfo(this, &quot;This is title&quot;, &quot;This is</span><br><span class="line">        content&quot;, pendingIntent);</span><br><span class="line">        startForeground(1, notification);</span><br><span class="line">        Log.d(&quot;MyService&quot;, &quot;onCreate executed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="1-使用HTTP协议访问网络"><a href="#1-使用HTTP协议访问网络" class="headerlink" title="1.使用HTTP协议访问网络"></a>1.使用HTTP协议访问网络</h3><p>​        Android 上发送HTTP请求有两种，1.<strong>HttpURLConnection</strong>和 2. <strong>HttpClient</strong></p>
<h4 id="1-1-HttpURLConnection"><a href="#1-1-HttpURLConnection" class="headerlink" title="1.1 HttpURLConnection"></a>1.1 HttpURLConnection</h4><p>先获取HttpURLConnection实例，new出一个URL对象，传入目标的网络地址，然后调一下openConnection()方法即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class="line">HttpURLConnection connection &#x3D; (HttpURLConnection)url.openConnection();</span><br></pre></td></tr></table></figure>
<p>得到HttpURLConnection的实例后，设置HTTP请求所使用的方法。常用方法：GET 和 POST</p>
<p>​        GET：表示希望从服务器获取数据</p>
<p>​        POST :表示希望提交数据到服务器</p>
<h5 id="1-1-1-GET"><a href="#1-1-1-GET" class="headerlink" title="1.1.1 GET"></a>1.1.1 GET</h5><p>写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestMethod(&quot;GET&quot;);</span><br></pre></td></tr></table></figure>
<p>设置连接超时、读取超时的毫秒，以及服务器希望得到的一些消息头等。根据自己实际情况进行编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.setConnectTimeout(8000);</span><br><span class="line">connection.setReadTimeout(8000);</span><br></pre></td></tr></table></figure>
<p>之后调取getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream in &#x3D; connection.getInputStream();</span><br></pre></td></tr></table></figure>
<p>最后调用disconnect()方法关闭HTTP连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.disconnect();</span><br></pre></td></tr></table></figure>
<h5 id="1-1-2-POST"><a href="#1-1-2-POST" class="headerlink" title="1.1.2 POST"></a>1.1.2 POST</h5><p>需要向服务器提交数据，采用POST的方式，数据之间用&amp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">DataOutputStream out &#x3D; new DataOutputStream(connection.getOutputStream());</span><br><span class="line">out.writeBytes(&quot;username&#x3D;admin&amp;password&#x3D;123456&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="1-2-使用HttpClient"><a href="#1-2-使用HttpClient" class="headerlink" title="1.2. 使用HttpClient"></a>1.2. 使用HttpClient</h4><p>HttpClient是Apache提供的HTTP网络访问接口，一开始就被引入Android API中，几乎可以完成与HttpURLConnection同样的效果，只是用法有较大的差别。</p>
<p>HttpClient是一个接口，无法创建它的实例，通常会创建一个DefaultHttpClient的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient &#x3D; new DefaultHttpClient();</span><br></pre></td></tr></table></figure>
<h5 id="1-2-1-GET"><a href="#1-2-1-GET" class="headerlink" title="1.2.1 GET"></a>1.2.1 GET</h5><p>想发起一条GET请求，可以创建一个HttpGet对象，传入目标网络地址，然后调用HttpGet的execute()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpGet httpGet &#x3D; new HttpGet(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class="line">httpClient.excute(httpGet);</span><br></pre></td></tr></table></figure>
<h5 id="1-2-2-POST"><a href="#1-2-2-POST" class="headerlink" title="1.2.2 POST"></a>1.2.2 POST</h5><p>使用POST请求比GET复杂一点，需创建HttpPost对象，并传入目标地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpPost httpPost &#x3D; new HttpPost(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);</span><br></pre></td></tr></table></figure>
<p>1.然后通过一个NameValuePair集合来存放待提交的参数，</p>
<p>2.并将这个参数集合传入一个UrlEncodedFormEntity中，</p>
<p>3.然后调用HttpPost的setEntity()方法将构建好的UrlEncodedFormEntity传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;NameValuePair&gt; params &#x3D; new ArrayList&lt;NameValuePair&gt;();</span><br><span class="line">params.add(new BasicNameValuePair(&quot;username&quot;,&quot;admin&quot;));</span><br><span class="line">params.add(new BasicNameValuePair(&quot;password&quot;,&quot;123456&quot;));</span><br><span class="line">UrlEncodedFormEntity entity &#x3D; new UrlEncodedFormEntity(params, &quot;utf-8&quot;);</span><br><span class="line">httpPost.setEntity(entity);</span><br></pre></td></tr></table></figure>
<p>4.接下来就和HttpGet一样，调用HttpClient的execute()方法，并将HttpPost对象传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure>
<h5 id="1-2-3-处理返回结果"><a href="#1-2-3-处理返回结果" class="headerlink" title="1.2.3 处理返回结果"></a>1.2.3 处理返回结果</h5><p>执行完上面的操作，会返回一个HttpResponse对象，包含服务器返回的所有信息。通常我们会先取出服务器返回的状态码，等于200说明请求和响应都成功了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (httpResponse.getStatusLine().getStatusCode() &#x3D;&#x3D; 200)&#123;</span><br><span class="line">	&#x2F;&#x2F;请求、响应都成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如得到状态码200，则可调用getEntity()方法获取到一个HttpEntity实例，然后调用EntityUtils.toString()这个静态方法将HttpEntity转换成字符串即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpEntity entity &#x3D; httpResponse.getEntity();</span><br><span class="line">String response &#x3D; EntityUtils.toString(entity);</span><br></pre></td></tr></table></figure>
<p>假如返回数据中包含中文，EntityUtils.toString()方法会出现乱码，需要将字符集指定为utf-8：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String response &#x3D; EntityUtils.toString(entity, &quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="基于位置的服务"><a href="#基于位置的服务" class="headerlink" title="基于位置的服务"></a>基于位置的服务</h2><p>简称LBS，利用无线电通信网络或者GPS等定位方式，确定出移动设备所在的位置。安卓中使用LocationManager类就能实现。</p>
<h3 id="1-LocationManager基本用法"><a href="#1-LocationManager基本用法" class="headerlink" title="1.LocationManager基本用法"></a>1.LocationManager基本用法</h3><p>获取LocationManager实例，可以调用Context的getSystemService()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocationManager locationManager &#x3D;(LocationManager)getSystemService(Context.LOCATION_SERVICE);</span><br></pre></td></tr></table></figure>
<p>接着需要选择一个位置提供器来确定设备当前的位置。Android中一般有三种位置提供器供选择，<strong>GPS_PROVIDER</strong>、<strong>NETWORK_PROVIDER</strong> 和 <strong>PASSIVE_PROVIDER</strong></p>
<h4 id="1-1-获取位置"><a href="#1-1-获取位置" class="headerlink" title="1.1 获取位置"></a>1.1 获取位置</h4><p>将选择好的内容提供器传入到getLastKnownLocation()方法中，就可以得到一个Location对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String provider &#x3D; LocationManager.NETWORK_PROVIDER;</span><br><span class="line">Location location &#x3D; LocationManager.getLastKnownLocation(provider);</span><br></pre></td></tr></table></figure>
<p>Location对象中包含经度，纬度，海拔等一系列位置信息，我们从中取出想要的数据即可。</p>
<p>想要经度较高的数据，需要用GPS定位功能，使用之前需要先确定定位功能是否启用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; providerList &#x3D; locationManager.getProviders(true);</span><br></pre></td></tr></table></figure>
<p>getProviders()方法传入true表示只有启用位置提供器才会被返回，之后再从providerList中判断是否包含GPS定位功能就行。</p>
<h4 id="1-2-监听位置变化"><a href="#1-2-监听位置变化" class="headerlink" title="1.2 监听位置变化"></a>1.2 监听位置变化</h4><p>getLastKnownLocation()  方法可以获取设备当前位置信息，想要知道设备位置变化，可以使用LocationManager的requestLocationUpdates()方法，只需要传入一个LocatiionListener，配置几个参数即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">locationManager.requestLocationUpadtes(LocationManager.GPS_PROVIDER, 5000, 10, new LocationListener()&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onStatusChanged(String provider, int status, Bundle extras) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onProviderEnabled(String provider) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onProviderDisabled(String provider) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLocationChanged(Location location) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>参数一：位置提供器类型</p>
<p>参数二 : 监听位置变化的时间间隔，单位：毫秒</p>
<p>参数三：监听位置变化的距离间隔，以米为单位</p>
<p>参数四：LocationListener监听器</p>
<p>所以上面例子的效果是：监听GPS位置变化，每5秒检测一下，距离超过10米时，调用LocationListener的onLocationChanged()方法，把新的位置信息作为参数传入。</p>
<h3 id="2-Geocoding-API用法（反向地理编码）"><a href="#2-Geocoding-API用法（反向地理编码）" class="headerlink" title="2. Geocoding API用法（反向地理编码）"></a>2. Geocoding API用法（反向地理编码）</h3></div><div class="post-copyright"><blockquote><p>原文作者: lingengxiong</p><p>原文链接: <a href="http://yoursite.com/2019/12/28/android笔记/">http://yoursite.com/2019/12/28/android笔记/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/01/03/hexo%E7%AC%94%E8%AE%B0/" class="pre">hexo笔记</a><a href="/2019/02/27/webpack%E7%AC%94%E8%AE%B0/" class="next">webpack笔记</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'd5dd8867ef8d47352834',
  clientSecret: 'bca9f103cf3548ecae6cd334284e91656753bae6',
  repo: 'blogtalk',
  owner: 'lingengxiong',
  admin: ['lingengxiong'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Intent"><span class="toc-text">Intent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四大组件-——-Activity"><span class="toc-text">四大组件 —— Activity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#活动的启动模式"><span class="toc-text">活动的启动模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-standard"><span class="toc-text">1.standard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-singleTop"><span class="toc-text">2.singleTop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-singleTask"><span class="toc-text">3.singleTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-singleInstance"><span class="toc-text">4.singleInstance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四种布局"><span class="toc-text">四种布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LinearLayout"><span class="toc-text">1.LinearLayout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RelativeLayout"><span class="toc-text">2.RelativeLayout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-FrameLayout"><span class="toc-text">3.FrameLayout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TableLayout"><span class="toc-text">4.TableLayout</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单位和尺寸"><span class="toc-text">单位和尺寸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四大组件-——-Broadcast-Receive"><span class="toc-text">四大组件 ——- Broadcast Receive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-标准广播"><span class="toc-text">1.标准广播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-有序广播"><span class="toc-text">2.有序广播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-注册广播"><span class="toc-text">3.注册广播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久化计算"><span class="toc-text">持久化计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-文件存储"><span class="toc-text">1.文件存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SharedPreferences存储"><span class="toc-text">2.SharedPreferences存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-getSharedPreferences"><span class="toc-text">2.1. getSharedPreferences</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-getSharedPreferences"><span class="toc-text">2.2.getSharedPreferences</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-getDefaultSharedPreferences"><span class="toc-text">2.3.getDefaultSharedPreferences</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-向SharedPreferences文件中存储数据"><span class="toc-text">a.向SharedPreferences文件中存储数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-从SharedPreferences文件中读取数据"><span class="toc-text">b.从SharedPreferences文件中读取数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SQLite数据库存储"><span class="toc-text">3.SQLite数据库存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1创建数据库："><span class="toc-text">3.1创建数据库：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2升级数据库"><span class="toc-text">3.2升级数据库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3SQLite数据类型"><span class="toc-text">3.3SQLite数据类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四大组件-——-Content-Provider"><span class="toc-text">四大组件 —— Content Provider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-访问其他程序中的数据"><span class="toc-text">1.访问其他程序中的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步消息处理机制"><span class="toc-text">异步消息处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Messgae"><span class="toc-text">1.Messgae</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Handler"><span class="toc-text">2.Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MessageQueue"><span class="toc-text">3.MessageQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Looper"><span class="toc-text">4.Looper</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask"><span class="toc-text">AsyncTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Params"><span class="toc-text">1.Params</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Progress"><span class="toc-text">2.Progress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Result"><span class="toc-text">3.Result</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-onPreExecute"><span class="toc-text">3.1.onPreExecute()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-doInBackground-Params"><span class="toc-text">3.2.doInBackground(Params)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-onProgressUpdate-Progress…"><span class="toc-text">3.3.onProgressUpdate(Progress…)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-onPostExecute-Result"><span class="toc-text">3.4.onPostExecute(Result)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四大组件-——-Service"><span class="toc-text">四大组件 —— Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-定义一个服务"><span class="toc-text">1. 定义一个服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-启动和停止服务"><span class="toc-text">2. 启动和停止服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-活动与服务进行通信"><span class="toc-text">3.活动与服务进行通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-服务的生命周期"><span class="toc-text">4.服务的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-前台服务"><span class="toc-text">5.前台服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络"><span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-使用HTTP协议访问网络"><span class="toc-text">1.使用HTTP协议访问网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-HttpURLConnection"><span class="toc-text">1.1 HttpURLConnection</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-GET"><span class="toc-text">1.1.1 GET</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-POST"><span class="toc-text">1.1.2 POST</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-使用HttpClient"><span class="toc-text">1.2. 使用HttpClient</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-GET"><span class="toc-text">1.2.1 GET</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-POST"><span class="toc-text">1.2.2 POST</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-处理返回结果"><span class="toc-text">1.2.3 处理返回结果</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于位置的服务"><span class="toc-text">基于位置的服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LocationManager基本用法"><span class="toc-text">1.LocationManager基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-获取位置"><span class="toc-text">1.1 获取位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-监听位置变化"><span class="toc-text">1.2 监听位置变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Geocoding-API用法（反向地理编码）"><span class="toc-text">2. Geocoding API用法（反向地理编码）</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">markdown数学公式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/Unity%20Shader%E5%AD%A6%E4%B9%A03%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6/">Unity Shader学习3——数学</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/09/lua%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">lua</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/npm/">npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/hexo%E7%AC%94%E8%AE%B0/">hexo笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/28/android%E7%AC%94%E8%AE%B0/">Android笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/27/webpack%E7%AC%94%E8%AE%B0/">webpack笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javaScripts/">javaScripts</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/javaScripts/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/npm/" style="font-size: 15px;">npm</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/Shader/" style="font-size: 15px;">Shader</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/lingengxiong" title="github" target="_blank">github</a><ul></ul><a href="https://gitee.com/lingengxiong" title="码云" target="_blank">码云</a><ul></ul><a href="https://blog.csdn.net/lgx1134569285" title="csdn" target="_blank">csdn</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">lingengxiong.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>